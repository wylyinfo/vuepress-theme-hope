const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;q(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&q(e.slice(0,-1),n,u)}},q=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",$="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},N=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:$,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=G(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:G(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(N),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(N),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":245,\"nextId\":245,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-184f4da6\",\"2\":\"v-1473bf53\",\"3\":\"v-1473bf53@0\",\"4\":\"v-4e65ec78\",\"5\":\"v-4e65ec78@0\",\"6\":\"v-4e65ec78@1\",\"7\":\"v-c151bf32\",\"8\":\"v-c151bf32@0\",\"9\":\"v-c151bf32@1\",\"10\":\"v-33d62ebc\",\"11\":\"v-33d62ebc@0\",\"12\":\"v-33d62ebc@1\",\"13\":\"v-438ffe52\",\"14\":\"v-438ffe52#markdown-介绍\",\"15\":\"v-438ffe52#markdown-配置\",\"16\":\"v-438ffe52#markdown-扩展\",\"17\":\"v-438ffe52#vuepress-扩展\",\"18\":\"v-438ffe52#主题扩展\",\"19\":\"v-438ffe52#提示容器\",\"20\":\"v-438ffe52#代码块\",\"21\":\"v-438ffe52#上下角标\",\"22\":\"v-438ffe52#自定义对齐\",\"23\":\"v-438ffe52#attrs\",\"24\":\"v-438ffe52#脚注\",\"25\":\"v-438ffe52#标记\",\"26\":\"v-438ffe52#任务列表\",\"27\":\"v-438ffe52#图片增强\",\"28\":\"v-438ffe52#组件\",\"29\":\"v-438ffe52@0\",\"30\":\"v-438ffe52@1\",\"31\":\"v-6e19edb7\",\"32\":\"v-6e19edb7#页面标题\",\"33\":\"v-6e19edb7#页面信息\",\"34\":\"v-6e19edb7#页面内容\",\"35\":\"v-6e19edb7#组件\",\"36\":\"v-6e19edb7@0\",\"37\":\"v-6e19edb7@1\",\"38\":\"v-2bc6566a\",\"39\":\"v-2bc6566a#标题-2\",\"40\":\"v-2bc6566a#标题-3\",\"41\":\"v-2bc6566a@0\",\"42\":\"v-2bc6566a@1\",\"43\":\"v-24b7c48d\",\"44\":\"v-24b7c48d#标题-2\",\"45\":\"v-24b7c48d#标题-3\",\"46\":\"v-24b7c48d@0\",\"47\":\"v-24b7c48d@1\",\"48\":\"v-f0ec4556\",\"49\":\"v-f0ec4556#标题-2\",\"50\":\"v-f0ec4556#标题-3\",\"51\":\"v-f0ec4556@0\",\"52\":\"v-f0ec4556@1\",\"53\":\"v-df8b6e0c\",\"54\":\"v-df8b6e0c#标题-2\",\"55\":\"v-df8b6e0c#标题-3\",\"56\":\"v-df8b6e0c@0\",\"57\":\"v-df8b6e0c@1\",\"58\":\"v-e6502464\",\"59\":\"v-e6502464#方案1-全局事务-dtp模型\",\"60\":\"v-e6502464#实际方案-基于xa协议的两阶段提交\",\"61\":\"v-e6502464#方案2-基于可靠消息服务的分布式事务-事务消息中间件\",\"62\":\"v-e6502464#方案3-最大努力通知-定期校对-也叫本地消息表\",\"63\":\"v-e6502464#方案4-tcc-两阶段型、补偿型\",\"64\":\"v-43a1a3c2\",\"65\":\"v-43a1a3c2#分布式系统面临的问题\",\"66\":\"v-43a1a3c2#分布式理论-cap定理\",\"67\":\"v-43a1a3c2#cap原则权衡\",\"68\":\"v-43a1a3c2#关于p的理解\",\"69\":\"v-43a1a3c2#ca非0-1的选择\",\"70\":\"v-43a1a3c2#base理论\",\"71\":\"v-43a1a3c2#最终一致性分为5种\",\"72\":\"v-43a1a3c2#分布式事务\",\"73\":\"v-43a1a3c2#分布式锁\",\"74\":\"v-43a1a3c2#分布式session\",\"75\":\"v-43a1a3c2#负载均衡\",\"76\":\"v-43a1a3c2#高可用之-脑裂\",\"77\":\"v-43a1a3c2#_2pc-two-phase-commit\",\"78\":\"v-43a1a3c2#_3pc-three-phase-commit\",\"79\":\"v-43a1a3c2#paxos\",\"80\":\"v-43a1a3c2#basic-paxos\",\"81\":\"v-43a1a3c2#multi-paxos\",\"82\":\"v-43a1a3c2#raft\",\"83\":\"v-43a1a3c2#zab-zookeeper-atomic-broadcast-protocol\",\"84\":\"v-43a1a3c2#选举、多数派和租约\",\"85\":\"v-43a1a3c2#选举-election\",\"86\":\"v-43a1a3c2#多数派-quorum\",\"87\":\"v-43a1a3c2#租约-lease\",\"88\":\"v-0ef7c120\",\"89\":\"v-0ef7c120#分布式锁实现方式\",\"90\":\"v-0ef7c120#一、数据库锁\",\"91\":\"v-0ef7c120#_1-基于mysql锁表\",\"92\":\"v-0ef7c120#_2-采用乐观锁增加版本号\",\"93\":\"v-0ef7c120#二、缓存锁\",\"94\":\"v-0ef7c120#_1-基于-sex-px-nx\",\"95\":\"v-0ef7c120#_2-redlock算法\",\"96\":\"v-0ef7c120#zookeeper分布式锁\",\"97\":\"v-0ef7c120#分布式锁比较\",\"98\":\"v-fd1aa6e0\",\"99\":\"v-fd1aa6e0#线性结构\",\"100\":\"v-fd1aa6e0#栈与队列\",\"101\":\"v-fd1aa6e0#栈-限定仅在表尾进行插入和删除操作的线性结构\",\"102\":\"v-fd1aa6e0#队列-只允许在一端进行插入操作-而在另一端进行删除操作的线性结构\",\"103\":\"v-fd1aa6e0#二叉树\",\"104\":\"v-fd1aa6e0#散列表-哈希表\",\"105\":\"v-fd1aa6e0#跳跃表\",\"106\":\"v-fd1aa6e0#java\",\"107\":\"v-fd1aa6e0#arraylist-底层基于数组\",\"108\":\"v-fd1aa6e0#linkedlist-循环双向链表\",\"109\":\"v-fd1aa6e0#hashmap-数组-链表-红黑树\",\"110\":\"v-fd1aa6e0#copyonwritearraylist-线程安全-可重入锁\",\"111\":\"v-fd1aa6e0#concurrenthashmap-线程安全-cas-synchronized\",\"112\":\"v-fd1aa6e0#mysql\",\"113\":\"v-fd1aa6e0#索引实现\",\"114\":\"v-fd1aa6e0#b-tree索引-b-树\",\"115\":\"v-fd1aa6e0#hash索引-哈希表\",\"116\":\"v-fd1aa6e0#事务实现-redo-undo-log-锁-mvcc\",\"117\":\"v-fd1aa6e0#redo-log\",\"118\":\"v-fd1aa6e0#undo-log\",\"119\":\"v-fd1aa6e0#读写锁-shared-lock-exclusive-lock\",\"120\":\"v-fd1aa6e0#mvcc-multiversion-concurrency-control-多版本并发控制\",\"121\":\"v-fd1aa6e0#redis\",\"122\":\"v-fd1aa6e0#redisobject-结构\",\"123\":\"v-fd1aa6e0#简单动态字符串-simple-dynamic-string-sds\",\"124\":\"v-fd1aa6e0#压缩列表-ziplist\",\"125\":\"v-fd1aa6e0#链表\",\"126\":\"v-fd1aa6e0#字典\",\"127\":\"v-fd1aa6e0#跳跃表-1\",\"128\":\"v-fd1aa6e0#整数集合\",\"129\":\"v-fd1aa6e0#列表对象\",\"130\":\"v-fd1aa6e0#哈希对象\",\"131\":\"v-fd1aa6e0#集合对象\",\"132\":\"v-fd1aa6e0#有序集合对象\",\"133\":\"v-fd1aa6e0#elasticsearch\",\"134\":\"v-fd1aa6e0#索引结构\",\"135\":\"v-fd1aa6e0#lucene内部结构\",\"136\":\"v-fd1aa6e0#lucene文件内容\",\"137\":\"v-fd1aa6e0#读写数据原理\",\"138\":\"v-fd1aa6e0#react-vue\",\"139\":\"v-fd1aa6e0#react\",\"140\":\"v-fd1aa6e0#vue\",\"141\":\"v-fd1aa6e0#hbase\",\"142\":\"v-fd1aa6e0#mongodb\",\"143\":\"v-fd1aa6e0#kafka\",\"144\":\"v-fd1aa6e0#rabbitmq\",\"145\":\"v-fd1aa6e0#rocketmq\",\"146\":\"v-132cd25c\",\"147\":\"v-132cd25c#选择排序\",\"148\":\"v-132cd25c#递归\",\"149\":\"v-132cd25c#快速排序\",\"150\":\"v-132cd25c#散列表-hash-table\",\"151\":\"v-132cd25c#广度优先搜索-breadth-first-search-bfs\",\"152\":\"v-132cd25c#狄克斯特拉算法\",\"153\":\"v-132cd25c#贪婪算法\",\"154\":\"v-132cd25c#np完全问题\",\"155\":\"v-132cd25c#动态规划\",\"156\":\"v-132cd25c#k最近邻算法-k-nearest-neighbours-knn\",\"157\":\"v-132cd25c#其他\",\"158\":\"v-2c9d690e\",\"159\":\"v-4a777ccc\",\"160\":\"v-4a777ccc#单一职责原则-srp\",\"161\":\"v-4a777ccc#开放-关闭原则-the-open-closed-principle-ocp\",\"162\":\"v-4a777ccc#依赖倒转原则\",\"163\":\"v-4a777ccc#里式代换原则-lsp\",\"164\":\"v-4a777ccc#迪米特法则-lod\",\"165\":\"v-4a777ccc#合成-聚合复用原则-carp\",\"166\":\"v-4a777ccc#简单工厂模式\",\"167\":\"v-4a777ccc#策略模式-strategy\",\"168\":\"v-4a777ccc#装饰模式-decorator\",\"169\":\"v-4a777ccc#代理模式-proxy\",\"170\":\"v-4a777ccc#工厂方法模式-factory-method\",\"171\":\"v-4a777ccc#原型模式-prototype\",\"172\":\"v-4a777ccc#模板方法模式-templatemethod\",\"173\":\"v-4a777ccc#外观模式-facade-门面模式\",\"174\":\"v-4a777ccc#建造者模式-builder\",\"175\":\"v-4a777ccc#观察者模式-observer-发布-订阅publish-subscribe模式\",\"176\":\"v-4a777ccc#抽象工厂模式-abstract-factory\",\"177\":\"v-4a777ccc#状态模式-state\",\"178\":\"v-4a777ccc#适配器模式-adapter\",\"179\":\"v-4a777ccc#备忘录模式-memento\",\"180\":\"v-4a777ccc#组合模式-composite\",\"181\":\"v-4a777ccc#迭代器模式-iterator\",\"182\":\"v-4a777ccc#单例模式-singleton\",\"183\":\"v-4a777ccc#桥接模式-bridge\",\"184\":\"v-4a777ccc#命令模式-command\",\"185\":\"v-4a777ccc#职责链模式-chain-of-responsibility\",\"186\":\"v-4a777ccc#中介者模式-调停者模式-mediator\",\"187\":\"v-4a777ccc#享元模式-flyweight\",\"188\":\"v-4a777ccc#解释器模式-interpreter\",\"189\":\"v-4a777ccc#访问者模式-visitor\",\"190\":\"v-4a777ccc#创建型模式\",\"191\":\"v-4a777ccc#结构型模式\",\"192\":\"v-4a777ccc#行为型模式\",\"193\":\"v-2e53fefa\",\"194\":\"v-2e53fefa#使用场景\",\"195\":\"v-2e53fefa#实现方式\",\"196\":\"v-2e53fefa#定期轮询-数据库等\",\"197\":\"v-2e53fefa#delayqueue\",\"198\":\"v-2e53fefa#timer\",\"199\":\"v-67b8c712\",\"200\":\"v-67b8c712#标题-2\",\"201\":\"v-67b8c712#标题-3\",\"202\":\"v-67b8c712@0\",\"203\":\"v-67b8c712@1\",\"204\":\"v-696d9fb1\",\"205\":\"v-696d9fb1#标题-2\",\"206\":\"v-696d9fb1#标题-3\",\"207\":\"v-696d9fb1@0\",\"208\":\"v-696d9fb1@1\",\"209\":\"v-6b227850\",\"210\":\"v-6b227850#标题-2\",\"211\":\"v-6b227850#标题-3\",\"212\":\"v-6b227850@0\",\"213\":\"v-6b227850@1\",\"214\":\"v-6cd750ef\",\"215\":\"v-6cd750ef#标题-2\",\"216\":\"v-6cd750ef#标题-3\",\"217\":\"v-6cd750ef@0\",\"218\":\"v-6cd750ef@1\",\"219\":\"v-7a07405d\",\"220\":\"v-7a07405d#标题-2\",\"221\":\"v-7a07405d#标题-3\",\"222\":\"v-7a07405d@0\",\"223\":\"v-7a07405d@1\",\"224\":\"v-7bbc18fc\",\"225\":\"v-7bbc18fc#标题-2\",\"226\":\"v-7bbc18fc#标题-3\",\"227\":\"v-7bbc18fc@0\",\"228\":\"v-7bbc18fc@1\",\"229\":\"v-7d70f19b\",\"230\":\"v-7d70f19b#标题-2\",\"231\":\"v-7d70f19b#标题-3\",\"232\":\"v-7d70f19b@0\",\"233\":\"v-7d70f19b@1\",\"234\":\"v-7f25ca3a\",\"235\":\"v-7f25ca3a#标题-2\",\"236\":\"v-7f25ca3a#标题-3\",\"237\":\"v-7f25ca3a@0\",\"238\":\"v-7f25ca3a@1\",\"239\":\"v-e1e3da16\",\"240\":\"v-4bfe2a66\",\"241\":\"v-b795acf0\",\"242\":\"v-3e43d972\",\"243\":\"v-08f42f4a\",\"244\":\"v-30be3cd5\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,11],\"1\":[1,2],\"2\":[1],\"3\":[null,null,1],\"4\":[1,18],\"5\":[null,null,1],\"6\":[null,null,1],\"7\":[1,7],\"8\":[null,null,1],\"9\":[null,null,1],\"10\":[1,20],\"11\":[null,null,1],\"12\":[null,null,1],\"13\":[2,11],\"14\":[2,8],\"15\":[2,13],\"16\":[2,11],\"17\":[2,10],\"18\":[1,10],\"19\":[1,19],\"20\":[1,1],\"21\":[1,3],\"22\":[1,3],\"23\":[1,5],\"24\":[1,2],\"25\":[1,3],\"26\":[1,6],\"27\":[1,2],\"28\":[1],\"29\":[null,null,1],\"30\":[null,null,1],\"31\":[1,3],\"32\":[1,19],\"33\":[1,20],\"34\":[1,12],\"35\":[1,13],\"36\":[null,null,1],\"37\":[null,null,2],\"38\":[1],\"39\":[2,2],\"40\":[2,2],\"41\":[null,null,1],\"42\":[null,null,3],\"43\":[1],\"44\":[2,2],\"45\":[2,2],\"46\":[null,null,2],\"47\":[null,null,2],\"48\":[1],\"49\":[2,2],\"50\":[2,2],\"51\":[null,null,2],\"52\":[null,null,2],\"53\":[1],\"54\":[2,2],\"55\":[2,2],\"56\":[null,null,1],\"57\":[null,null,2],\"58\":[1],\"59\":[4,42],\"60\":[2,22],\"61\":[4,108],\"62\":[4,42],\"63\":[5,40],\"64\":[1,23],\"65\":[1,33],\"66\":[2,31],\"67\":[1,45],\"68\":[1,8],\"69\":[2,33],\"70\":[1,26],\"71\":[1,27],\"72\":[1],\"73\":[1,86],\"74\":[1,25],\"75\":[1,46],\"76\":[3,74],\"77\":[5,27],\"78\":[5,28],\"79\":[1,4],\"80\":[2,115],\"81\":[2,24],\"82\":[1,58],\"83\":[6,85],\"84\":[2,18],\"85\":[3,7],\"86\":[3,20],\"87\":[3,33],\"88\":[1,20],\"89\":[1],\"90\":[2],\"91\":[2,18],\"92\":[2,4],\"93\":[2],\"94\":[5,6],\"95\":[2,42],\"96\":[1,47],\"97\":[1,24],\"98\":[1,16],\"99\":[1,9],\"100\":[1],\"101\":[2,10],\"102\":[3,8],\"103\":[1,33],\"104\":[3,6],\"105\":[1,9],\"106\":[1],\"107\":[2,47],\"108\":[2,13],\"109\":[2,92],\"110\":[4,34],\"111\":[6,134],\"112\":[1],\"113\":[1],\"114\":[4,26],\"115\":[3,41],\"116\":[7],\"117\":[2,19],\"118\":[2,7],\"119\":[5,45],\"120\":[5,65],\"121\":[1],\"122\":[2,38],\"123\":[6,34],\"124\":[3,34],\"125\":[1,29],\"126\":[1,83],\"127\":[1,33],\"128\":[1,30],\"129\":[1,7],\"130\":[1,11],\"131\":[1,8],\"132\":[1,26],\"133\":[1],\"134\":[1,74],\"135\":[1,31],\"136\":[1,110],\"137\":[1,100],\"138\":[2,18],\"139\":[1,59],\"140\":[1,17],\"141\":[1,19],\"142\":[1],\"143\":[1,121],\"144\":[1],\"145\":[1],\"146\":[1],\"147\":[1],\"148\":[1,21],\"149\":[1,26],\"150\":[4,13],\"151\":[6,28],\"152\":[1,36],\"153\":[1,14],\"154\":[1,20],\"155\":[1,11],\"156\":[6,18],\"157\":[1,34],\"158\":[1,46],\"159\":[1],\"160\":[3,6],\"161\":[8,17],\"162\":[1,4],\"163\":[3,1],\"164\":[3,11],\"165\":[4,24],\"166\":[1,1],\"167\":[3,26],\"168\":[3,28],\"169\":[3,25],\"170\":[4,29],\"171\":[3,11],\"172\":[3,15],\"173\":[4,28],\"174\":[3,16],\"175\":[6,26],\"176\":[4,31],\"177\":[3,16],\"178\":[3,17],\"179\":[3,27],\"180\":[3,22],\"181\":[3,28],\"182\":[3,29],\"183\":[3,14],\"184\":[3,32],\"185\":[5,20],\"186\":[4,33],\"187\":[3,30],\"188\":[3,48],\"189\":[3,29],\"190\":[1,5],\"191\":[1,7],\"192\":[1,11],\"193\":[1,5],\"194\":[1,26],\"195\":[1],\"196\":[3,7],\"197\":[1,12],\"198\":[1,12],\"199\":[2],\"200\":[2,2],\"201\":[2,2],\"202\":[null,null,1],\"203\":[null,null,3],\"204\":[2,2],\"205\":[2,2],\"206\":[2,2],\"207\":[null,null,1],\"208\":[null,null,3],\"209\":[2],\"210\":[2,2],\"211\":[2,2],\"212\":[null,null,2],\"213\":[null,null,3],\"214\":[2],\"215\":[2,2],\"216\":[2,2],\"217\":[null,null,2],\"218\":[null,null,3],\"219\":[2],\"220\":[2,2],\"221\":[2,2],\"222\":[null,null,2],\"223\":[null,null,3],\"224\":[2,4],\"225\":[2,2],\"226\":[2,2],\"227\":[null,null,2],\"228\":[null,null,3],\"229\":[2],\"230\":[2,2],\"231\":[2,2],\"232\":[null,null,1],\"233\":[null,null,3],\"234\":[2],\"235\":[2,2],\"236\":[2,2],\"237\":[null,null,1],\"238\":[null,null,3],\"239\":[1],\"240\":[1],\"241\":[1],\"242\":[1],\"243\":[1],\"244\":[1]},\"averageFieldLength\":[1.964411707026663,21.563924984864848,0.9791895544461594],\"storedFields\":{\"0\":{\"h\":\"首页\",\"t\":[\"这是一个博客主页的案例。\",\"要使用此布局，你应该在页面前端设置 layout: BlogHome 和 home: true。\",\"相关配置文档请见 博客主页。\"]},\"1\":{\"h\":\"介绍页\",\"t\":[\"将你的个人介绍和档案放置在此处。\"]},\"2\":{\"h\":\"主要功能与配置演示\"},\"3\":{\"c\":[\"使用指南\"]},\"4\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"5\":{\"c\":[\"使用指南\"]},\"6\":{\"c\":[\"禁用\"]},\"7\":{\"h\":\"密码加密的文章\",\"t\":[\"实际的文章内容。\",\"段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。\",\"段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。\"]},\"8\":{\"c\":[\"使用指南\"]},\"9\":{\"c\":[\"加密\"]},\"10\":{\"h\":\"布局\",\"t\":[\"布局包括:\",\"导航栏\",\"侧边栏\",\"页脚\",\"同时每个页面包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"主题也带有以下元素:\",\"夜间模式按钮\",\"返回顶部按钮\",\"打印按钮\",\"你可以在主题选项和页面的 frontmatter 中自定义它们。\"]},\"11\":{\"c\":[\"指南\"]},\"12\":{\"c\":[\"布局\"]},\"13\":{\"h\":\"Markdown 展示\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"14\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"15\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"相关信息\",\"Frontmatter 是 VuePress 中很重要的一个概念，如果你不了解它，你需要阅读 Frontmatter 介绍。\"]},\"16\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"17\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"18\":{\"h\":\"主题扩展\",\"t\":[\"通过 vuepress-plugin-md-enhance，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\"]},\"19\":{\"h\":\"提示容器\",\"t\":[\"安全的在 Markdown 中使用 {{ variable }}。\",\"自定义标题\",\"信息容器，包含 代码 与 链接。\",\"const a = 1; \",\"自定义标题\",\"提示容器\",\"自定义标题\",\"警告容器\",\"自定义标题\",\"危险容器\",\"自定义标题\",\"详情容器\",\"查看详情\"]},\"20\":{\"h\":\"代码块\",\"t\":[\"查看详情\"]},\"21\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"22\":{\"h\":\"自定义对齐\",\"t\":[\"我是居中的\",\"我在右对齐\",\"查看详情\"]},\"23\":{\"h\":\"Attrs\",\"t\":[\"一个拥有 ID 的 单词。\",\"查看详情\"]},\"24\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注^first.\",\"查看详情\"]},\"25\":{\"h\":\"标记\",\"t\":[\"你可以标记 重要的内容 。\",\"查看详情\"]},\"26\":{\"h\":\"任务列表\",\"t\":[\"[x] 计划 1\",\"[ ] 计划 2\",\"查看详情\"]},\"27\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小\",\"查看详情\"]},\"28\":{\"h\":\"组件\"},\"29\":{\"c\":[\"使用指南\"]},\"30\":{\"c\":[\"Markdown\"]},\"31\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"32\":{\"h\":\"页面标题\",\"t\":[\"The first H1 title in Markdown will be regarded as page title.\",\"Markdown 中的第一个 H1 标题会被视为页面标题。\",\"你可以在 Markdown 的 Frontmatter 中设置页面标题。\",\"--- title: 页面标题 --- \"]},\"33\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"34\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"图片引入\",\"你可以将图片和 Markdown 文件放置在一起使用相对路径进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\"]},\"35\":{\"h\":\"组件\",\"t\":[\"每个 Markdown 页面都会被转换为一个 Vue 组件，这意味着你可以在 Markdown 中使用 Vue 语法：\",\"{{ 1 + 1 }}\",\"{{ i }}\",\"你也可以创建并引入你自己的组件。\"]},\"36\":{\"c\":[\"使用指南\"]},\"37\":{\"c\":[\"页面配置\",\"使用指南\"]},\"38\":{\"h\":\"樱桃\"},\"39\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"40\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"41\":{\"c\":[\"樱桃\"]},\"42\":{\"c\":[\"红\",\"小\",\"圆\"]},\"43\":{\"h\":\"火龙果\"},\"44\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"45\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"46\":{\"c\":[\"火龙果\",\"水果\"]},\"47\":{\"c\":[\"红\",\"大\"]},\"48\":{\"h\":\"草莓\"},\"49\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"50\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"51\":{\"c\":[\"水果\",\"草莓\"]},\"52\":{\"c\":[\"红\",\"小\"]},\"53\":{\"h\":\"番茄\"},\"54\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"55\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"56\":{\"c\":[\"蔬菜\"]},\"57\":{\"c\":[\"红\",\"圆\"]},\"58\":{\"h\":\"分布式事务\"},\"59\":{\"h\":\"方案1：全局事务(DTP模型)\",\"t\":[\"DTP是由X/Open组织提出的一种分布式事务模型-X/Open Distributed Transaction Processing Reference Model。规定要实现分布式事务，需要三种角色：\",\"AP: Application应用系统。可以使用资源管理器提供的事务接口来实现分布式事务\",\"TM: Transaction Manager事务管理器。分布式事务的实现由事务管理器来完成，会提供分布式事务的操作接口供业务系统调用。这些接口称为TX接口；事务管理器还管理着所有的资源管理器，通过提供的XA接口来统一调度资源管理器，以实现分布式事务\",\"RM: Resource Manager资源管理器。能够提供数据服务的对象都可以是资源管理器，比如：数据库、消息中间件、缓存等，大部分场景下，数据库即为分布式事务中的资源管理器；资源管理器能够提供单数据库的事务能力，通过XA接口，将本数据库的提交、回滚等能力提供给事务管理器调用，以帮助事务管理器实现分布式事务管理；XA是DTP模型定义的接口，用于向事务管理器提供该资源管理器的提交、回滚等能力；DTP只是一套实现分布式事务的规范，RM具体的实现是由数据库厂商来完成\"]},\"60\":{\"h\":\"实际方案：基于XA协议的两阶段提交\",\"t\":[\"XA是一个分布式事务协议，分为事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、DB2都实现了XA接口，事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。\",\"XA协议比较简单，而且一旦商业数据库实现XA协议，使用分布式事务的成本比较低。缺点：性能不理想，特别是在交易下单链路，往往并发量很高，XA无法满足高并发场景。XA目前商业数据库支持比较理想，mysql数据库支持不太理想，mysql的XA实现，没有记录prepare节点日志，主备切换会导致主库与备库数据不一致。许多nosql也没有支持XA，让XA应用场景变得非常狭隘\"]},\"61\":{\"h\":\"方案2：基于可靠消息服务的分布式事务（事务消息中间件）\",\"t\":[\"1）在系统A处理任务A前，先向消息中间件发送一条消息；\",\"2）消息中间件收到后将该消息持久化，但并不投递。此时下游系统B仍然不知道该消息的存在；\",\"3）消息中间件持久化成功后，向系统A返回一个确认应答；\",\"4）系统A收到确认应答后，则可以开始处理任务A；\",\"5）任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程结束，可以处理别的任务。但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统出现不一致，可由消息中间件的事务回查机制完成；\",\"6）消息中间件收到Commit指令后，向系统B投递该消息，从而触发任务B的执行；\",\"7）任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已成功消费，此时，该分布式事务完成\",\"消息中间件扮演分布式事务协调者的角色；系统A完成任务A后，到任务B执行完成之间，会存在一定的时间差。在这个时间差内，整个系统处于数据不一致的状态，但短暂的不一致性是可以接受的，因为经过短暂的时间后，系统又可以保持数据一致性，满足BASE理论\",\"如果任务A处理失败，会向消息中间件发送Rollback请求。发完则认为回滚已经完成。消息中间件收到回滚请求，直接将消息丢弃，而不投递给系统B，从而不会触发系统B的任务B\",\"系统A除了实现正常的业务流程外，还需提供一个事务询问的接口，供消息中间件调用。当消息中间件收到一条事务型消息后开始计时，如果到了超时时间没收到系统A发来的Commit或Rollback指令，会主动调用系统A提供的事务询问接口询问系统目前的状态。这种超时询问机制能够防止上游系统因在传输过程中丢失Commit/Rollback指令而导致的系统不一致情况，而且能降低上游系统的阻塞时间，提升系统的并发度。\",\"消息中间件向下游系统投递完消息后进入阻塞等待状态，下游系统便立即进行任务处理，任务处理完成后向消息中间件返回应答。消息中间件收到确认应答后认为事务处理完毕。如果消息在投递过程中丢失，或消息的确认应答在返回途中丢失，那么消息中间件在等待确认应答超时之后会重新投递，直到下游消费者返回消费成功响应为止。一般消息中间件可以设置消息重试的次数和时间间隔。如果多次重试后仍然投递失败，则这条消息需要人工干预。\",\"消息投递失败后为什么不回滚消息，而是不断尝试重新投递？涉及整套分布式事务系统的实现成本问题。如果消息投递失败需要回滚，就需要让系统A事先提供回滚接口，增加额外的开发成本，业务系统的复杂度也将提高。对于一个业务系统的设计目标是，在保证性能的前提下，最大限度降低系统复杂度，从而降低系统的运维成本.\",\"上游系统向消息中间件投递消息是异步，消息中间件将消息投递给下游系统是同步？首先，上游系统和消息中间件之间采用异步通信是为了提高系统并发度和用户体验。但异步通信可能引起Commit/Rollback指令丢失的问题，由消息中间件的超时询问机制弥补。其次，异步能提升系统性能，但会增加系统复杂度，同步虽然降低系统并发度，但实现成本较低。因此，在对并发度要求不要的情况下，或服务器资源较为充裕的情况下，可以选择同步来降低系统复杂度。消息中间件是一个独立于业务的第三方中间件，不和任何业务系统产生直接的耦合，不和用户产生直接的关联，一般部署在独立的服务器集群上，具有良好的可扩展性，如果处理速度无法满足要求，可以增加机器解决。而且消息中间件产生的时延导致事务短暂的不一致是可以接受的。\"]},\"62\":{\"h\":\"方案3：最大努力通知（定期校对）也叫本地消息表\",\"t\":[\"1）上游系统在完成任务后，向消息中间件同步发送一条消息，确保消息中间件成功持久化；\",\"2）消息中间件收到消息后将消息同步投递给下游系统，并触发下游系统的任务执行；\",\"3）下游系统处理成功后，向消息中间件反馈确认应答，消息中间件将消息删除，从而事务完成\",\"消息中间件向下游系统投递消息失败：消息中间件有重试机制，如果多次重试失败，记录在失败消息表中，消息中间件提供失败消息的查询接口，下游系统定期查询失败消息，将其消费，即“定期校对”\",\"上游系统向消息中间件发送消息失败：需要在上游系统中建立消息重发机制。在上游系统建立一张本地消息表，将任务处理过程和向本地消息表插入消息放在一个本地事务完成。有一个专门的消息发送者发送本地消息表的消息，如果发送失败会重试。\",\"对于不支持事务型消息的消息中间件，如果要实现分布式事务，就可以采用这种方式。可通过重试机制+定期校对实现分布式事务，但是相比方案2，达到数据一致性的周期较长，需要在上游系统中实现消息重试发布机制，以确保消息成功发布给消息中间件，增加业务系统开发成本，使得业务系统不够纯粹，占用业务系统硬件资源，从而影响性能\",\"因此，尽量选择支持事务型消息的消息中间件来实现分布式事务，如RocketMQ\"]},\"63\":{\"h\":\"方案4：TCC（两阶段型、补偿型）\",\"t\":[\"解决应用拆分带来的跨应用业务操作原子性问题。Try: 预留业务资源 Confirm:确认执行业务操作 Cancel:取消执行业务操作\",\"1）Try: 尝试执行业务。完成所有业务检查（一致性）预留必须业务资源（准隔离性）2）Confirm: 确认执行业务。真正执行业务 不做任何业务检查 只使用Try阶段预留的业务资源 3）Cancel：取消执行业务 释放Try阶段预留的业务资源\",\"主业务服务为整个业务活动的发起方，从业务服务负责提供TCC业务操作，是整个业务活动的操作方。从业务服务必须实现Try、Confirm和Cancel接口，供主业务服务调用。要求Confirm和Cancel接口必须幂等。业务活动管理器管理控制整个业务活动，包括记录维护TCC全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时确认所有的TCC型操作的confirm操作，在业务活动取消时调用所有TCC型操作的cancel操作。\",\"优点：解决跨应用业务操作的原子性，把数据库层的二阶段提交提到应用层实现，对于数据库来说是一阶段提交，规避数据库层2PC性能低下问题。\",\"缺点：Try、Confirm和Cancel操作功能需业务提供，开发成本高\"]},\"64\":{\"h\":\"分布式架构\",\"t\":[\"分布式系统主要特征：\",\"分布性：分布式系统中的多台计算机之间在空间位置上可以随意分布，同时，机器分布情况也会随时变动\",\"对等性：分布式系统中的计算机没有主从之分，所有计算机节点都是对等的。副本(Replica)是分布式系统最常见概念之一，指的是分布式系统对数据和服务提供的一种冗余方式\",\"并发性：同一个分布式系统中的多个节点，可能会并发地操作一些共享的资源，如何准确并高效地协调分布式并发操作也成为分布式系统架构与设计中最大的挑战之一\",\"缺乏全局时钟：分布式系统缺乏一个全局的时钟序列控制\",\"故障总是会发生：组成分布式系统的所有计算机，都有可能发生任何形式的故障。除非需求指标允许，在系统设计时不能放过任何异常情况\"]},\"65\":{\"h\":\"分布式系统面临的问题\",\"t\":[\"通信异常：分布式系统需要在各个节点之间进行网络通信，因此网络通信都会伴随着网络不可用的风险或是系统不可用都会导致最终分布式系统无法顺利完成一次网络通信。另外，即使分布式系统各节点之间的网络通信能够正常进行，其延时也会远大于单机操作，会影响消息的收发的过程，因此消息丢失和消息延迟变得非常普遍\",\"网络分区：当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点之间能够进行正常通信，而另一些节点不能。这个现象称为网络分区，俗称\\\"脑裂\\\"。当网络分区出现时，分布式系统会出现局部小集群，在极端情况下，这些局部小集群会独立完成原本需要整个分布式才能完成的功能，这就对分布式一致性提出挑战\",\"三态：分布式系统的每一次请求与响应，存在特有的\\\"三态\\\"概念，即成功、失败与超时。当出现超时现象时，网络通信的发起方时无法确定当前请求是否被成功处理\",\"节点故障：节点故障则是分布式环境下另一个比较常见的问题，指的是组成分布式系统的服务器节点出现的宕机或僵死现象\"]},\"66\":{\"h\":\"分布式理论-CAP定理\",\"t\":[\"一个分布式系统中，Consistency(一致性)，Availability(可用性), Partition tolerance(分区容错性)这三个基本需求，最多只能同时满足其中2个\",\"Consistency 数据在多个副本之间能够保持一致的特性（严格的一致性）\",\"Availability 系统提供的服务必须一直处于可用状态，每次请求都能获取到非错的响应（不保证获取的数据为最新数据）\",\"Partition tolerance 分布式系统在遇到任何网络分区故障时，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障\",\"在某时刻如果满足AP，分隔的节点同时对外服务但不能相互通信，将导致状态不一致，即不能满足C；如果满足CP，网络分区的情况下为达成C，请求只能一直等待，即不能满足A；如果满足CA，在一定时间内要达到节点状态一致，要求不能出现网络分区，则不能满足P。\"]},\"67\":{\"h\":\"CAP原则权衡\",\"t\":[\"CA without P 如果不要求P（不允许分区），则C(强一致性)和A(可用性)可以保证。但分区始终会存在，因此CA系统更多的是允许分区后各子系统依然保持CA。如涉及钱财的场景，C必须保证，网络发生故障宁可停止服务，保证CA，舍弃P\",\"CP without A 如果不要求A（可用），相当于每个请求都需要在server之间强一致，而P(分区)会导致同步时间无限延长，CP可以保证。很多传统数据库分布式事务都属于属于这种模式。如保证CP，舍弃A，例如网络故障时只读不写\",\"AP without C 高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多NoSQL都属于此类。如多数大型互联网应用的场景，一般要保证服务可用性达到N个9，即保证P和A，只有舍弃C，退而求其次保证最终一致性\"]},\"68\":{\"h\":\"关于P的理解\",\"t\":[\"现实情况下我们面对的是一个不可靠的网络、有一定概率宕机的设备，这两个因素都会导致Partition，因而分布式系统实现中P是一个必须项，而不是可选项。CAP理论更合适的描述是：在满足分区容错的前提下，没有算法能同时满足数据一致性和服务可用性\"]},\"69\":{\"h\":\"CA非0/1的选择\",\"t\":[\"强一致要求多节点组成的被调要能像单节点一样运作、操作具备原子性，数据在时间、时序上都有要求。\",\"序列一致性(sequential consistency)：不要求时序一致，A操作先于B操作，在B操作后如果所有调用端操作得到A操作的结果，满足序列一致性\",\"最终一致性(eventual consistency): 放宽对时间的要求，在被调完成操作响应后的某个时间点，被调多个节点的数据最终达成一致\",\"工程实践中，较常见的做法是通过异步拷贝副本(asynchronous replication)、quorum/NRW，实现在调用端看来数据强一致，被调端最终一致，在调用端看来服务可用、被调端允许部分节点不可用(或被网络分隔)的效果\",\"CAP理论并没有涵盖分布式工程实践中的所有重要因素。如延时(latency)，衡量系统可用性、与用户体验直接相关的一项重要指标\"]},\"70\":{\"h\":\"BASE理论\",\"t\":[\"Basically Available(基本可用), Soft State(软状态), Eventually Consistent(最终一致性)\",\"基本可用：响应时间上的损失，功能上的损失\",\"软状态：相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种硬状态。软状态指的是，允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时\",\"最终一致性：不可能一直是软状态，必须有个时间期限。在期限后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时，系统负载，数据复制方案设计等因素\"]},\"71\":{\"h\":\"最终一致性分为5种\",\"t\":[\"因果一致性Causal consistency: 如果节点A在更新完某个数据后通知节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。与此同时，和节点A无因果关系的节点C的数据访问没有这样的限制\",\"读已之缩写 Read your writes: 节点A更新一个数据后，自身总是能访问自身更新过的最新值，而不会看到旧值\",\"会话一致性 Session consistency: 将对系统数据的访问过程框定在一个会话中，系统保证在同一个有效的会话中实现\\\"读已之所写\\\"的一致性\",\"单调读一致性 Monotonic read consistency: 如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值\",\"单调写一致性 Monotonic write consistency: 一个系统要能够保证来自同一个节点的写操作顺序执行\"]},\"72\":{\"h\":\"分布式事务\"},\"73\":{\"h\":\"分布式锁\",\"t\":[\"锁可以有阻塞锁和乐观锁两种实现方式。阻塞锁通常使用互斥量来实现，互斥量为1表示有其它进程在使用锁，为0表示未锁定状态\",\"实现：\",\"数据库唯一索引： 当想要获得锁时，向表中插入一条记录，释放锁时删除记录。唯一索引可以保证该记录只被插入一次，通过用这个记录是否存在判断是否锁定。存在问题：锁没有失效时间，解锁失败会导致死锁，其他线程无法再获得锁。只能是非阻塞锁，插入失败直接报错，无法重试。不可重入，同一线程在没有释放锁之前无法再获得锁\",\"Redis的SETNX指令\",\"Redis的RedLock算法：使用多个Redis实例实现分布式锁，保证在发生单点故障时仍然可用。尝试从N个独立Redis实例获取锁，如果一个实例不可用，尝试下一个。计算获取锁消耗时间，只有当这个时间小于锁的过期时间，并且从大多数(N/2+1)实例上获取锁，则认为锁获取成功。如果获取失败，会到每个实例上释放锁\",\"Zookeeper的有序节点：\",\"1）抽象模型：提供一种树形结构的命名空间\",\"2）节点类型：永久节点：不会因为会话结束或者超时消失；临时节点：如果会话结束或者超时就会消失；有序节点：会在节点名的后面加一个数字后缀，并且是有序的\",\"3）监听器：为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息\",\"4）分布式锁实现：创建一个锁目录/lock，创建临时且有序的子节点，第一个客户端对应子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推；客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；执行业务代码，完成后删除对应的子节点\",\"5）会话超时：如果一个已经获得锁的会话超时，因为创建的是临时节点，所以会话对应的临时节点会被删除，其他会话就可以获得锁\",\"6）羊群效应：一个节点未获得锁，需要监听自己的前一个子节点，这是因为如果监听所有子节点，那么任意一个子节点状态改变，其他所有子节点都会收到通知（羊群效应），而我们只希望它的后一个子节点收到通知\"]},\"74\":{\"h\":\"分布式Session\",\"t\":[\"1）Sticky Sessions 需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，可以把用户的Session存放在该服务器节点中。缺点：当服务器节点宕机时，将丢失该服务器节点上的所有Session\",\"2）Session Replication 在服务器节点上进行Session同步操作，用户可以访问任何一个服务器节点。缺点：需要更好的服务器硬件条件；需要对服务器进行配置\",\"3）Persistent DataStore 将Session信息持久化到一个数据库中。缺点：有可能需要去实现存取Session代码\",\"4）In-Memory DataStore 可使用Redis和Memcached内存型数据库对Session进行存储\"]},\"75\":{\"h\":\"负载均衡\",\"t\":[\"1）轮询（Round Robin) 轮询算法把每个请求轮流发送到每个服务器上。适合每个服务器的性能差不多的场景\",\"2）加权轮询（Weighted Round Robin) 加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值\",\"3）最少连接（least Connections）由于每个请求的连接时间不一样，使用轮询或者加权轮询算法，可能会让一台服务器当前连接数过大，而另一台服务器连接过小，造成负载不均衡。最少连接是将请求发送给当前最少连接数的服务器上\",\"4）加权最少连接（Weighted Least Connection) 在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数\",\"5）随机算法（Random）把请求随机发送到服务器上\",\"6）原地址哈洗发(IP Hash) 源地址哈希通过对客户端IP哈希计算得到的一个数值，用该数值对服务器数量进行取模运算，获取目标服务器的序号。优点：保证同一IP客户端都会被hash到同一台服务器上。缺点：不利于集群扩展，后台服务器数量变更都会影响hash结果。可用一致性Hash改进\"]},\"76\":{\"h\":\"高可用之\\\"脑裂\\\"\",\"t\":[\"当两(多) 个节点同时认为自己是唯一处于活动状态的服务器从而出现争用资源的情况，即\\\"脑裂\\\"(split-brain)或\\\"区间集群\\\"(partitioned cluster)\",\"由于相互联系，都以为对方出了故障，争抢共享资源，应用服务，会发生严重后果：或者共享资源被瓜分，两边服务都起不来；或者两边服务都起来，但同时读写共享存储，导致数据损坏（常见如数据库轮询的联机日志出错）\",\"全认同(agreement): 所有N个节点都认同一个结果；值合法(validity): 该结果必须由N个节点中的节点提出；可结束(termination)：决议过程在一定时间内结束，不会无休止地进行下去\",\"问题：消息传递异步无序(asynchronous)：现实网络不是一个可靠的信道，存在消息延时，丢失，节点间消息传递做不到同步有序(synchronous)；节点宕机(fail-stop)：节点持续宕机，不会恢复；节点宕机恢复(fail-recover)：接地那宕机一段时间后恢复，在分布式系统中最常见；网络分化(network partition)：网络链路出现问题，将N个节点隔离成多个部分；拜占庭将军问题(byzantine failure): 节点或宕机或逻辑失败，甚至不按套路出牌抛出干扰决议的信息\",\"一致性还具备两个属性，一个是强一致（safety)，要求所有节点状态一致、共进退；一个是可用（liveness），要求分布式系统24*7无间断对外服务。\",\"FLP定理(FLP impossibility)已经证明在一个收窄的模型中（异步环境并只存在节点宕机），不能同时满足safety和liveness\"]},\"77\":{\"h\":\"2PC(two phase commit)\",\"t\":[\"先由一方进行提议(propose)并收集其他节点的反馈(vote)，再根据反馈决定提交(commit)或中止(abort)事务。将提议的节点称为协调者(coordinator)，其他参与决议节点称为参与者(participants, 或cohorts)\",\"coordinator如果在发起提议后宕机，那么participant将进入阻塞(block)状态，一直等待回应以完成该次决议。需要另一角色把系统从不可结束的状态中带出来，新增的角色叫协调者备份(coordinator watchdog)，通过问询各participant的状态，决定阶段2是提交还是中止。要求coordinator/participant记录历史状态。\"]},\"78\":{\"h\":\"3PC(three phase commit)\",\"t\":[\"在2PC中一个participant的状态只有它自己和coordinator知晓，假如coordinator提议后自身宕机，在watchdog启用前一个participant又宕机，其他participant就进入既不能回滚，又不能强制commit的阻塞状态，直到participant宕机恢复\",\"propose+precommit+commit，防止participant宕机后整个系统进入阻塞态\",\"阶段1：coordinator或watchdog未收到宕机participant的vote，直接中止事务；宕机的participant恢复后，读取logging发现未发出赞成vote，自行中止该事务；\",\"阶段2：coordinator未收到宕机participant的precommit ACK，但因为之前已经收到宕机participant的赞成反馈，coordinator进行commit；watchdog通过问询其他participant获得这些信息，过程同理；宕机的participant恢复后发现收到precommit或已经发出赞成vote，则自行commit事务\",\"阶段3：即使coordinator或watchdog未收到宕机participant的commit ACK，也结束该事务；宕机的participant恢复后发现收到commit或者precommit，也自行commit该事务\"]},\"79\":{\"h\":\"Paxos\",\"t\":[\"Paxos协议在节点宕机恢复、消息无序或丢失、网络分化的场景下能保证决议的一致性，是被讨论最广泛的一致性协议\"]},\"80\":{\"h\":\"Basic Paxos\",\"t\":[\"一致性问题是在节点宕机、消息无序等场景可能出现的情况下，相互独立的节点间如何达成决议的问题，作为解决一致性问题的协议，Paxos的核心是节点间如何确定并只确定一个值(value)\",\"Paxos先把节点分为两类，发起提议(proposal)的一方为proposer，参与决议的一方为acceptor。如只有一个proposer发起提议，并且节点不宕机、消息不丢包，那么acceptor做到以下这点可以确定一个值：一个acceptor接受它收到的第一项提议(P1)\",\"假设多个proposer可以同时发起提议，proposer和acceptor需满足：1）proposer发起的每项提议分别用一个ID标识，提议的组成因此变为(ID, value)；2）acceptor可以接受(accept)不止一项提议，当多数(quorum)acceptor接受一项提议时被确定(chosen)。\",\"约定后面发起的提议的ID比前面提议的ID大，并假设可以有多项提议被确定，为做到确定并只确定一个值acceptor需做到：如果一项值为v的提议被确定，那么后续只确定值为v的提议(P2)。\",\"由于一项提议被确定前必须先被多数派acceptor接受，为实现P2，acceptor需要做到：如果一项值为v的提议被确定，那么acceptor后续只接受值为v的提议(P2a)。\",\"假设acceptor c宕机一段时间后恢复，c宕机期间其他acceptor已经确定了一项值为v的决议但c因为宕机并不知晓；c恢复后如果有proposer马上发起一项值不是v的提议，由于条件P1，c会接受该提议，这与P2a矛盾。需要对proposer做约束：如果一项值为v的提议被确定，那么proposer后续只发起值为v的提议(P2b)。\",\"P2b约束的是提议被确定后proposer的行为，提议被确定前proposer应该怎么做：对于提议(n,v)，acceptor的多数派S中，如果存在acceptor最近一次(即ID值最大)接受的提议的值v'，那么要求v=v'；否则v可为任意值\",\"如果proposer/acceptor满足以下3点，那么在少数节点宕机、网络分化隔离的情况下，在确定并只确定一个值可以保证一致性：\",\"B1(β)：β中每一轮决议中都有唯一的ID标识；B2(β): 如果决议β被acceptor多数派接受，则确定决议B；B3(β)：对于β中的任意提议B(n,v),acceptor的多数派中如果存在acceptor最近一次(即ID值最大)接受的提议值为v'，那么要求v=v'；否则v可为任意值(注：希腊字母β表示多轮决议的集合，字母B表示一轮决议)\",\"为保证P2c，对acceptor做两个要求：1.记录曾接受的ID最大的提议，因proposer需要问询该信息以决定提议值；2.在回应提议ID为n的proposer自己曾接受过ID最大的提议时，acceptor同时保证(promise)不再接受ID小于n的提议\",\"proposer/acceptor完成一轮决议可归纳为prepare和accept两个阶段。prepare阶段proposer发起提议问询提议值、acceptor回应问询并进行promise；accept阶段完成决议。\",\"假如proposer A发起ID为n的提议，在提议未完成前proposer B又发起ID为n+1的提议，在n+1提议未完成前proposer C又发起ID为n+2的提议...如此acceptor不能完成决议、形成活锁(livelock)，虽然不影响一致性，但一般不想让这样情况发生。解决方法是从proposer中选出一个leader，提议统一由leader发起\",\"最后再引入一个新角色：learner，learner依附于acceptor，用于习得已确定的决议。以上决议过程都只要求acceptor多数派参与，而我们希望尽量所有acceptor的状态一致。如果部分acceptor因宕机等原因未知晓已确定决议，宕机恢复后可经本机learner采用pull方式从其他acceptor习得\"]},\"81\":{\"h\":\"Multi Paxos\",\"t\":[\"不断进行”确定一个值“的过程，再为每个过程编上序号，就能得到具有全序关系(total order)的系列值，进而能应用在数据库副本存储等很多场景。把单次\\\"确定一个值\\\"的过程称为实例(instance)，由proposer/acceptor/learner组成。\",\"proposer leader在Multi Paxos中有助于提升性能，常态下统一由leader发起提议，可节省prepare步骤(leader不用问询acceptor曾接受过的ID最大的提议，只有leader提议也不需要acceptor进行promise)直至发生leader宕机、重新选主\"]},\"82\":{\"h\":\"Raft\",\"t\":[\"Leader统一处理变更操作请求，一致性协议的作用具化为保证节点间操作日志副本(log replication)一致，以term作为逻辑时钟(logical clock)保证时序，节点运行相同状态机(state machine)得到一致结果。\",\"具体过程如下：Client发起请求，每一条请求包含操作指令；请求交由Leader处理，Leader将操作指令(entry)追加(append)至操作日志，紧接着对Follower发起AppendEntries请求、尝试让操作日志副本在Follower落地；如果Follower多数派(quorum)同意AppendEntries请求，Leader进行commit操作、把指令交由状态机处理；状态机处理完成后将结果返回给Client\",\"指令通过log index(指令id)和term number保证时序，正常情况下Leader、Follower状态机按相同顺序执行指令，得出相同结果、状态一致。宕机、网络分化等情况可引起Leader重新选举(每次选举产生新Leader的同时，产生新的term)、Leader/Follower间状态不一致。Raft中Leader为自己和所有Follower各维护一个nextIndex值，其表示Leader紧接下来要处理的指令id以及将要发个Follower的指令id，LnextIndex不等于FnextIndex时代表Leader操作日志和Follower操作日志存在不一致，这时将从Follower操作日志中最初不一致的地方开始，由Leader操作日志覆盖Follower，直到LnextIndex、FnextIndex相等。\",\"Paxos中Leader的存在是为了提升决议效率，Leader的有无和数目并不影响决议一致性，Raft要求具备唯一Leader，并把一致性问题具体化为保持日志副本的一致性，以此实现相较Paxos而言更容易理解、更容易实现的目标\"]},\"83\":{\"h\":\"Zab(Zookeeper atomic broadcast protocol)\",\"t\":[\"Zookeeper内部用到的一致性协议。相比Paxos，Zab最大特点是保证强一致性(strong consistency), 或叫线性一致性(linearizable consistency)\",\"Zab要求唯一Leader参与决议，Zab可以分解成discovery、sync、broadcast三个阶段：\",\"1）discovery：选举产生PL(prospective leader)，PL收集Follower epoch(cepoch)，根据Follower的反馈PL产生newepoch（每次选举产生新Leader的同时产生新epoch，类似Raft的term）\",\"2）sync: PL补齐相比Follower多数派缺失的状态、之后各Follower再补齐相比PL缺失的状态，PL和Follower完成状态同步后PL变成正式Leader(established leader)\",\"3）broadcast: Leader处理Client的写操作，并将状态变更广播至Follower，Follower多数派通过之后Leader发起将状态变更落地(deliver/commit)\",\"Leader和Follower之间通过心跳判别健康状态，正常情况下Zab处在broadcast阶段，出现Leader宕机、网络隔离等异常情况时Zab重新回到discovery阶段\",\"Zab通过约束事务先后顺序达到强一致性，先广播的事务先commit、FIFO，Zab称为primary order(PO)。实现PO的核心是zxid。Zab中每个事务对应一个zxid，由两部分组成<e,c>，e即Leader选举时生成的epoch，c表示当次epoch内事务的编号、依次递增。假设有两个事务的zxid分别是z、z'，当满足z.e<z'.e或者z.e=z'.e&&z.c<z'.c时，定义z先于z'发生(z<z')\",\"为实现PO，Zab对Follower、Leader有以下约束：\",\"1）有事务z和z'，如果Leader先广播z，则Follower需保证先commit z对应的事务\",\"2）有事务z和z'，z由Leader p广播，z'由Leader q广播，Leader p先于Leader q，则Follower需保证先commit z对应的事务\",\"3）有事务z和z'，z由Leader p广播，z'由Leader q广播，Leader p先于Leader q，如果Follower已经commit z，则q需保证已commit z才能广播z'\",\"第1/2点保证事务FIFO，第3点保证Leader上具备所有已commit的事务\",\"相比Paxos，Zab约束了事务顺序、适用于有强一致性需求的场景\"]},\"84\":{\"h\":\"选举、多数派和租约\",\"t\":[\"选举(election)是分布式系统实践中常见的问题，通过打破节点间的对等关系，选得的leader(或叫master、coordinator)有助于实现事务原子性、提升决议效率。多数派(quorum)的思路帮助我们在网络分化的情况下达成决议一致性，在leader选举的场景下帮助我们选出唯一leader。租约(lease)在一定期限内给予节点特定权利，也可以用于实现leader选举。\"]},\"85\":{\"h\":\"选举(election)\",\"t\":[\"一致性问题(consistency)是独立节点间如何达成协议的问题。Bully算法是最常见的选举算法，其要求每个节点对应一个序号，序号最高的节点为leader。\"]},\"86\":{\"h\":\"多数派(quorum)\",\"t\":[\"在网络分化的场景下Bully算法会遇到一个问题，被分隔的节点都认为自己具有最大的序号、将产生多个leader，需要引入多数派(quorum)。多数派的思路在分布式系统很常见，其确保网络分化情况下决议唯一。\",\"多数派原理：假如节点总数为2f+1，则一项决议得到多于f节点赞成则获得通过。leader选举中，网络分化场景下只有具备多数派节点的部分才可能选出leader，避免多leader的产生。\",\"多数派的思路还被应用于副本(replica)管理，根据业务实际读写比例调整写副本数Vw，读副本数Vr，用以在可靠性和性能方面取得平衡。\"]},\"87\":{\"h\":\"租约(lease)\",\"t\":[\"通过心跳(heart beat)判别leader状态是否正常，但在网络拥塞或瞬断的情况下，容易导致出现双主。\",\"原理：每次租约时长内只有一个节点获得租约、到期后必须重新颁发租约。假设有租约颁发节点Z，节点0、1和2竞选leader\",\"租约过程：a) 节点0、1、2在Z上注册自己，Z根据一定的规则(例如先到先得)颁发租约给节点，该租约同时对应一个有效时长；假设节点0获得租约、成为leader；b) leader宕机时，只有租约到期(timeout)后才重新发起选举。\",\"租约机制确保了一个时刻最多只有一个leader，避免只使用心跳机制产生双主的问题。在实践应用中，zookeeper、ectd可用于租约颁发。\"]},\"88\":{\"h\":\"分布式锁需要具备哪些条件\",\"t\":[\"获取锁和释放锁的性能要好\",\"判断是否获得锁必须是原子性的，否则可能导致多个请求都获取到锁\",\"网络中断或宕机无法释放锁时，锁必须被清除，不然会发生死锁\",\"可重入一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接 执行调用的方法，而无需重新获得锁（避免死锁）\",\"阻塞锁和非阻塞锁，阻塞锁即没有获取到锁，则继续等待获取锁；费阻塞锁即没有获取到锁后，不继续等待，直接返回锁失败。\"]},\"89\":{\"h\":\"分布式锁实现方式\"},\"90\":{\"h\":\"一、数据库锁\"},\"91\":{\"h\":\"1.基于MySQL锁表\",\"t\":[\"完全依靠数据库唯一索引实现，当想要获得锁时，即向数据库中插入一条记录，释放锁时就删除该记录。存在以下问题：1）锁没有失效时间，解锁失败会导致死锁，其他线程无法再获取到锁，因为唯一索引insert都会返回失败；2）只能是非阻塞锁，insert失败直接报错，无法进入队列重试；3）不可重入，同一线程在没有释放锁之前无法再获取到锁。\"]},\"92\":{\"h\":\"2.采用乐观锁增加版本号\",\"t\":[\"根据版本号来判断更新之前有没有其他线程更新过，如果被更新过，则获取锁失败。\"]},\"93\":{\"h\":\"二、缓存锁\"},\"94\":{\"h\":\"1.基于 sex PX NX\",\"t\":[\"PX miillseconds 设置键key的过期时间，单位毫秒，NX 只有键key不存在时才会设置key的值\"]},\"95\":{\"h\":\"2.RedLock算法\",\"t\":[\"1）获取当前时间；2）尝试从5个相互独立redis客户端获取锁；3）计算获取所有锁消耗的时间，当且仅当客户端从多数节点获取锁，并且获取锁的时间小于锁的有效时间，认为获得锁；4）重新计算有效期时间，原有效时间减去获取锁消耗的时间；5）删除所有实例的锁。\",\"redlock算法相对于单节点redis锁可靠性更高，实现条件较为苛刻：1）必须部署5个节点才能让Redlock的可靠性更强。2）需要请求5个节点才能获取到锁，通过Future方式，先并发向5个节点请求，再一起获得响应结果，能缩短响应时间，不过还是比单节点redis锁耗费更多时间。由于必须获取到5个节点中3个以上，可能出现获取锁冲突，即都获得1-2把锁，结果都不能获取到锁。redlock采用通过冲突后在随机时间开始，降低冲突时间，但不能很好避免，特别是第一次获取锁时，所以获取锁的时间成本增加。如果5个节点有2个宕机，此时锁的可用性会极大降低，首先必须等待这两个宕机节点的结果超时才能返回，另外只有3个节点，客户端必须获取到全部3个节点的锁才能拥有锁，难度加大了。如果出现网络分区，可能出现客户端永远无法获取锁的情况。\"]},\"96\":{\"h\":\"zookeeper分布式锁\",\"t\":[\"zookeeper为分布式应用提供一致性服务，内部是一个分层的文件系统目录树结构，规定一个目录下只能有一个唯一文件名。\",\"数据模型：永久节点：节点创建后，不会因为会话失效而消失；临时节点：与永久节点相反，如果客户端连接失效，则立即删除节点；顺序节点：会自动在节点名后加一个数字后缀，并且有序。\",\"监视器(watcher)：当创建一个节点时，可以注册一个该节点的监视器，当节点状态发生改变时，watch被触发时，zookeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次。\",\"实现分布式锁：1）创建一个锁目录lock；2）希望获得锁的线程A在lock目录下，创建临时顺序节点；3）获取锁目录下所有子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；4）线程B获取所有节点，判断自己不是最小节点，设置监听（watcher）比自己次小的节点（只关注比自己次小的节点是为了防止发生“羊群效应”)；5）线程A处理完，删除自己的节点，线程B监听到变更时间，判断自己是最小节点，获得锁。\"]},\"97\":{\"h\":\"分布式锁比较\",\"t\":[\"数据库锁：优点：直接使用数据库，使用简单；缺点：分布式系统大多数瓶颈都在数据库，使用数据库锁会增加数据库负担。\",\"缓存锁：优点：性能高，实现方便，在允许偶发的锁失效的情况，不影响系统正常使用，建议采用缓存锁；缺点：通过锁超时机制不是十分可靠，当线程获得锁后，处理时间过长导致锁超时，就失去锁的作用\",\"zookeeper锁：优点：不依靠超时时间释放锁，可靠性高，系统要求高可靠性时，建议采用zookeeper锁；缺点：性能比不上缓存锁，因为要频繁创建删除节点\"]},\"98\":{\"h\":\"数据结构\",\"t\":[\"研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题\",\"逻辑结构：集合结构、线性结构、树形结构、图形结构\",\"物理结构：顺序存储结构、链式存储结构\",\"程序运行时间，依赖于算法好坏和问题输入规模（忽略因素：软件编译产生的代码质量，硬件机器执行指令的速度）\"]},\"99\":{\"h\":\"线性结构\",\"t\":[\"顺序存储：存取数据时间复杂度o(1)，插入删除时间复杂度o(n)，适合数据存取，需要预分配存储空间\",\"链式存储：存取数据时间复杂度o(n)，插入删除时间复杂度o(1)，适合频繁插入删除\"]},\"100\":{\"h\":\"栈与队列\"},\"101\":{\"h\":\"栈：限定仅在表尾进行插入和删除操作的线性结构\",\"t\":[\"顺序栈：必须事先确定存储空间大小，存在内存空间浪费，时间复杂度o(1)\",\"链栈：每个元素都有指针域，增加了内存开销，长度无限制，时间复杂度o(1)\"]},\"102\":{\"h\":\"队列：只允许在一端进行插入操作，而在另一端进行删除操作的线性结构\",\"t\":[\"循环顺序队列：时间复杂度o(1)，事先申请空间，使用期间不释放\",\"链队列：时间复杂度o(1)，需要指针域，会产生空间开销\"]},\"103\":{\"h\":\"二叉树\",\"t\":[\"平衡二叉树（AVL树）：二叉排序树，左右子树高度差至多等于1，查找、插入删除时间复杂度o(log(n))\",\"多路查找树（B树）：子结点可以多于两个，每个结点可存储多个元素（降低磁盘IO）\",\"B+树：所有叶子结点包含全部关键字及其指针，且顺序链接(适合范围查找)\",\"红黑树：根结点为黑色，所有节点都是黑色或红色，所有叶子节点(Null)都是黑色，红色节点子节点一定是黑色，任一节点到叶子节点所有路径上黑色节点数量相同。AVL树是严格平衡二叉树，要求每个节点左右子树高度差不超过1，查找效率，平衡调整成本更高，适合频繁查找；红黑树要求任何一条路径长度不超过其他路径长度2倍，适合频繁插入删除。\"]},\"104\":{\"h\":\"散列表（哈希表）\",\"t\":[\"查找时间复杂度o(1)，影响因素：散列函数是否均匀，处理冲突的方法，散列表的装填因子\"]},\"105\":{\"h\":\"跳跃表\",\"t\":[\"底层基于链表实现，含有多层，每个节点的每层都有指向表尾方向最近一个节点的指针，查询原理类似二分查找，查找、插入删除时间复杂度o(log(n))，维持结构平衡成本比较低\"]},\"106\":{\"h\":\"JAVA\"},\"107\":{\"h\":\"ArrayList：底层基于数组\",\"t\":[\"类内部使用默认缺省时对象数组的容量大小，自动扩容\",\"private static final int DEFAULT_CAPACITY = 10; transient Object[] elementData;//缓存数组，通常会预留容量 private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); if (newCapacity - minCapacity < 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } \"]},\"108\":{\"h\":\"LinkedList: 循环双向链表\",\"t\":[\"transient Node<E> first;//结点保存前驱和后继的引用 transient Node<E> last; private static class Node<E> { E item; Node<E> next; Node<E> prev; } \"]},\"109\":{\"h\":\"HashMap：数组+链表+红黑树\",\"t\":[\"数组长度是2的n次幂（散列分布均匀）\",\"static final int tableSizeFor(int cap) { int n = cap - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } \",\"元素个数超过数组大小*loadFactor，会进行数组扩容（降低碰撞几率）\",\"static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; static final float DEFAULT_LOAD_FACTOR = 0.75f; final Node<K,V>[] resize() { Node<K,V>[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) newThr = oldThr << 1; // double threshold } else if (oldThr > 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } //... } \",\"链表与红黑树转换（Poisson distribution链表长度等于8的概率约为0.00000006，查找性能o(n) -> o(log(n))，空间复杂度接近翻倍）\",\"static final int TREEIFY_THRESHOLD = 8;//转为树 static final int UNTREEIFY_THRESHOLD = 6;//转为链表 static final int MIN_TREEIFY_CAPACITY = 64;//转为树，数组最小容量 \",\"散列函数（hash取余计算综合高位低位，减少hash冲突）\",\"static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } index = (n - 1) & hash(key) //n表示长度 \"]},\"110\":{\"h\":\"CopyOnWriteArrayList 线程安全(可重入锁)\",\"t\":[\"public boolean add(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1);//写时复制，内存占用大，适合写多读少的并发场景 newElements[len] = e; setArray(newElements); return true; } finally { lock.unlock(); } }//只能保证数据最终一致性，不保证实时一致性；并发性比Vector好 \"]},\"111\":{\"h\":\"ConcurrentHashMap 线程安全(CAS + synchronized)\",\"t\":[\"private static final sun.misc.Unsafe U; private transient volatile int sizeCtl; transient volatile Node<K,V>[] table; private static final long SIZECTL; private static final long ABASE; private static final int ASHIFT; SIZECTL = U.objectFieldOffset (k.getDeclaredField(\\\"sizeCtl\\\")); ABASE = U.arrayBaseOffset(ak); int scale = U.arrayIndexScale(ak); if ((scale & (scale - 1)) != 0) throw new Error(\\\"data type scale not a power of two\\\"); ASHIFT = 31 - Integer.numberOfLeadingZeros(scale); final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; for (Node<K,V>[] tab = table;;) { Node<K,V> f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); //初始化table else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null))) break; // no lock when adding to empty bin } else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; synchronized (f) { //链表或红黑树添加节点，加锁 //... } //... } } addCount(1L, binCount); return null; } static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) { return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE); } static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i, Node<K,V> c, Node<K,V> v) { return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v); } private final Node<K,V>[] initTable() { Node<K,V>[] tab; int sc; while ((tab = table) == null || tab.length == 0) { if ((sc = sizeCtl) < 0) //数组初始化或扩容 Thread.yield(); // lost initialization race; just spin else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { //JVM会根据处理器类型，为汇编指令cmpxhg，比较并交换操作数，多处理器加上Lock前缀，单处理器则忽略（确保对内存读-改-写操作原子执行，禁止该指令与前后读写指令重排序，把写缓冲区中的所有数据刷新到内存） //CAS缺点：存在ABA问题，采用版本号解决；循环时间长，开销大；只能保证一个共享变量 try { if ((tab = table) == null || tab.length == 0) { int n = (sc > 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\\\"unchecked\\\") Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n]; table = tab = nt; sc = n - (n >>> 2); } } finally { sizeCtl = sc; } break; } } return tab; } \"]},\"112\":{\"h\":\"MYSQL\"},\"113\":{\"h\":\"索引实现\"},\"114\":{\"h\":\"B-Tree索引(B+树)\",\"t\":[\"叶子节点存放所有索引值，非叶子节点用于快速定位包含目标值的叶子节点；叶子节点的值有序；叶子节点之间以链表关联\",\"InnoDb：如使用聚簇索引（索引和行数据在一起存储，一种数据存储组织方式，通过主键实现，如果没有主键会选择唯一非空索引，如果还是没有，隐式生成一个主键），则叶子节点包含行数据，直接返回；如果使用非聚簇索引（普通索引），则根据叶子节点的主键查询聚簇索引，最后返回数据。\",\"MyISAM: 叶子节点除索引值只存储指向行数据的指针，根据该指针从表文件查询数据\",\"支持范围查找，支持排序，分组，支持前缀匹配；占用空间较大\"]},\"115\":{\"h\":\"Hash索引(哈希表)\",\"t\":[\"查找速度最快o(1)；不支持范围查找，需要处理hash冲突，必须全值精确匹配\",\"ibdata：innoDB表元数据（表，列，索引，索引列），undo log, change buffer, doublewrite buffer。启用innodb_file_per_table选项，新创建表的数和索引将存储在单独的.ibd文件(show GLOBAL VARIABLES like '%innodb_file%')\",\"ib_logfile: 事务日志/redo日志，采用顺序循环写入，每开启一个事务，会记录对数据文件修改的物理位置或偏移量。文件个数由innodb_log_files_in_group控制(show GLOBAL VARIABLES like '%innodb_log%')。记录所有innodb表数据变化，正在执行的dml及ddl语句，系统崩溃数据恢复\"]},\"116\":{\"h\":\"事务实现（redo&undo log, 锁, MVCC）\"},\"117\":{\"h\":\"redo log\",\"t\":[\"redo log buffer & redo log，分别在内存和磁盘，用于恢复数据，保障MySQL宕机时已提交事务的持久化(mysql修改会先存到Buffer Pool(缓冲池，包含磁盘数据页的映射)，读数据会先从缓冲池读取，如果缓冲池没有，则从磁盘读取再放入缓冲池；写数据会先写入缓冲池，然后用后台线程定期同步缓冲池到磁盘)\",\"redo log顺序存储，缓存同步随机操作；缓存同步是以数据页为单位，每次传输数据大小大于redo log\"]},\"118\":{\"h\":\"undo log\",\"t\":[\"记录事务修改之前版本的数据信息，用于回滚数据，保障未提交事务的原子性。数据变更操作都生成一条undo log，并且回滚日志必须先于数据持久化到磁盘，事务回滚就是根据回滚日志做逆向操作\"]},\"119\":{\"h\":\"读写锁（shared lock / exclusive lock）\",\"t\":[\"InnoDB行锁：共享锁（允许事务读一行，阻止其他事务获得相同数据集的排他锁, select * from table_name where ... lock in share mode），排他锁（允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的读写锁, select * from table_name where ... for update），如果没有及时commit/rollback，可能会造成其他事务长时间等待，影响并发效率\",\"行锁实现方式：通过给索引上的索引项加锁实现，只有通过索引条件检索数据，才使用行锁，否则将使用表锁\",\"意向锁（intention locks，表锁，为了允许行锁和表锁共存），意向共享锁(IS)，意向排他锁(IX)，事务打算给数据行加共享/排他锁，在加锁前必须先取得该表的意向锁\",\"间隙锁（范围检索数据时，请求共享或排他锁时，会给符合条件的已有数据记录索引项加锁，范围内不存在的记录也会加锁），阻塞范围键值并发插入，造成锁等待\"]},\"120\":{\"h\":\"MVCC（MultiVersion Concurrency Control) 多版本并发控制\",\"t\":[\"通过每行记录后面保存两个隐藏列实现（保存行的创建时间，过期时间，实际存储系统版本号，每开启一个新事务，系统版本号会自动递增，用于和查询到的每行记录版本号比较），通过数据多版本实现不加锁读进而做到读写并行。实现依赖：undo log记录某行数据多个版本数据，read view判断当前版本数据的可见性（https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html）\",\"READ UNCOMMITTED: 读写并行，性能高；造成脏读，未提交事务的数据也会被读取到\",\"READ COMMITTED: 写锁，读不加锁；造成不可重复读（事务中会读取到其他事务新提交的数据，造成多次读取结果不一样），幻读\",\"REPEATABLE READ:\",\"写锁，读不加锁采用MVCC，读写并行\",\"select: 只查找版本小于等于当前事务版本的数据行，确保在事务开始前已经存在或事务自身插入或修改; 行删除版本未定义或大于当前事务版本号，确保事务读取到的行，在事务开始之前未被删除\",\"insert: 为新插入行保存当前系统版本号作为行版本号\",\"delete: 为删除行保存当前系统版本号作为行删除标识\",\"update: 插入一行新记录保存当前系统版本号作为行版本号，同时保存为原来行作为行删除标识\",\"会产生幻读（如果事务中有其他新事务提交的新插入行，查询记录是否存在，不存在，准备插入该记录，但是执行发现此记录已存在，无法插入）\",\"SERIALIZABLE: 加锁读，读写串行，性能低\"]},\"121\":{\"h\":\"Redis\"},\"122\":{\"h\":\"redisObject 结构\",\"t\":[\"typedef struct redisObject { // 类型(string,list,hash,set,zset) unsigned type:4; // 编码(通过OBJECT ENCODING key查看, int:long类型整数，embstr:embstr编码的简单动态字符串，raw:简单动态字符串，hashtable:字典，linkedlist:双端链表，ziplist:压缩列表，intset:整数集合，skiplist：跳跃表和字典) unsigned encoding:4; // 指向底层实现数据结构的指针 void *ptr; // ... } robj; \"]},\"123\":{\"h\":\"简单动态字符串(simple dynamic string, SDS)\",\"t\":[\"//简单动态字符串(simple dynamic string, SDS) //获取字符串长度复杂度o(1); 修改字符串时，会检查内存空间再进行字符串修改，杜绝缓冲区溢出；采用空间预分配和惰性释放空间 struct sdshdr { // buf 中已占用空间的长度 int len; // buf 中剩余可用空间的长度 int free; // 数据空间，以'\\\\0'作为结束标识符 char buf[] }; //字符串对象：int编码，保存整数值；raw编码，字符串保存大于32字节字符串，内存分配次数两次；embstr编码，字符串保存小于等于32字节字符串，内存分配只需一次 \"]},\"124\":{\"h\":\"压缩列表(ziplist)\",\"t\":[\"一系列特殊编码的连续内存块组成的顺序存储结构，不同于数组，为节省内存每个元素所占内存大小可以不同。内存占用少，容易加载到CPU缓存，结构紧凑，减少内存碎片，平均时间复杂度o(n)；连锁更新\",\"zlbytes: ziplist的长度（单位: 字节)，是一个32位无符号整数\",\"zltail: ziplist最后一个节点的偏移量，反向遍历ziplist或者pop尾部节点的时候有用。\",\"zllen: ziplist的节点（entry）个数\",\"entry: 节点(prevlengh: 记录上一个节点的长度，为了方便反向遍历ziplist; encoding: 当前节点的编码规则; data: 当前节点的值，可以是数字或字符串)\",\"zlend: 值为0xFF，用于标记ziplist的结尾\"]},\"125\":{\"h\":\"链表\",\"t\":[\"typedef struct list { // 表头节点 listNode * head; // 表尾节点 listNode * tail; // 链表所包含的节点数量 unsigned long len; // 节点值复制函数 void *(*dup)(void *ptr); // 节点值释放函数 void (*free)(void *ptr); // 节点值对比函数 int (*match)(void *ptr,void *key); } list; typedef struct listNode { // 前置节点 struct listNode * prev; // 后置节点 struct listNode * next; // 节点的值 void * value; }listNode; \"]},\"126\":{\"h\":\"字典\",\"t\":[\"//dict.h //字典 或称符号表symbol table, 关联数组associative array, 映射map typedef struct dict { // 类型特定函数 dictType *type; // 私有数据 void *privdata; // 哈希表，rehash操作，为ht[1]分配空间，重新计算ht[0]哈希值，放到ht[1]，迁移完成后，将ht[1]设置为ht[0]，释放ht[0]，并创建空白ht[1],为下次rehash做准备 dictht ht[2]; // rehash索引，分多次渐进式rehash，完成后rehashidx增加1，迁移完成rehashidx设为-1，标识rehash完成。期间，查找先找ht[0]，再找ht[1]；添加操作一律添加到ht[1] int rehashidx; /* rehashing not in progress if rehashidx == -1 */ int iterators; /* number of iterators currently running */ } dict; //字典内部hashtable typedef struct dictht { // 哈希表数组 dictEntry **table; // 哈希表大小 unsigned long size; // 哈希表大小掩码，用于计算索引值，size-1 unsigned long sizemask; // 已有节点数量 unsigned long used; } dictht; //hashtable节点 typedef struct dictEntry { // key void *key; // 值 union { void *val; uint64_t u64; int64_t s64; } v; // 指向下个哈希表节点，形成链表 struct dictEntry *next; } dictEntry; \"]},\"127\":{\"h\":\"跳跃表\",\"t\":[\"//每个节点有多个指向其他节点的指针，从而快速访问节点 typedef struct zskiplist { // 表头节点和表尾节点 structz skiplistNode *header, *tail; // 表中节点的数量 unsigned long length; // 表中层数最大的节点的层数 int level; } zskiplist; typedef struct zskiplistNode { // 层 struct zskiplistLevel { // 前进指针 struct zskiplistNode *forward; // 跨度 unsigned int span; } level[]; // 后退指针 struct zskiplistNode *backward; // 分值 double score; // 成员对象 robj *obj; } zskiplistNode; \"]},\"128\":{\"h\":\"整数集合\",\"t\":[\"//当集合只包含整数元素，并且元素个数不多时，作为集合键的底层实现，可以保存int16_t,int32_t,int64_t整数值，不会出现重复元素 //升级操作：原来保存的是小类型(如int16_t)的整数，当插入比其类型大(如int64_t)的整数，会把集合里的元素数据类型转换成大的类型，节约内存，但不支持降级操作 typedef struct intset { // 编码方式 uint32_t encoding; // 集合包含的元素数量 uint32_t length; // 保存元素的数组 int8_t contents[]; } intset; \"]},\"129\":{\"h\":\"列表对象\",\"t\":[\"ziplist编码：每个节点保存一个列表元素。满足所有字符串长度都小于64字节，元素数量小于512\",\"linkedlist编码：每个节点都保存一个字符串对象，每个字符串对象保存一个列表元素\"]},\"130\":{\"h\":\"哈希对象\",\"t\":[\"ziplist编码：key-value键值对以紧密相连的方式放入，总是向表尾添加。满足所有键值字符串长度都小于64字节，键值对数量小于512个\",\"hashtable编码：字典实现，字典的键值都是字符串对象，字典的键保存key，字典值保存value\"]},\"131\":{\"h\":\"集合对象\",\"t\":[\"intset编码：所有元素都保存在整数集合。满足所有元素都是整数值，元素个数小于等于512个\",\"hashtable编码：字典每个键都是字符串对象，保存集合元素，字典值都是NULL\"]},\"132\":{\"h\":\"有序集合对象\",\"t\":[\"ziplist编码：类似哈希对象，两个紧密相连的压缩列表节点，第一个保存元素的成员，第二个保存元素的分值，分值小的靠近表头，大的靠近表尾。满足所有元素小于64字节，元素个数小于128个\",\"skiplist编码：同时使用跳跃表和字典，跳跃表节点保存集合元素，按分值从小到大排列，节点object属性保存元素成员，score属性保存分值；字典每个键值对保存集合元素，字典键保存元素成员，字典值保存分值。跳跃表有序，但查询分值复杂度o(logn)，字典查询分值复杂度o(1)，但是无序；采用两种结构但是集合元素成员和分值是共享的，通过指针指向同一地址\"]},\"133\":{\"h\":\"ElasticSearch\"},\"134\":{\"h\":\"索引结构\",\"t\":[\"分布式可扩展：用户查询在index上完成，index由shard组成。shard是数据存储的最小单元，对应lucene的library。\",\"Elasticsearch为每个field建立倒排索引term，对应符合的文档id存储在Posting List（要求有序）。将磁盘里的东西尽量搬进内存，减少磁盘随机读取次数，压缩内存使用空间\",\"通过term的前缀与Term Dictionary的block之间的映射关系，结合FST(有穷状态转换器，Finite State Transducers，空间占用小，此单单词重复利用，压缩存储空间，查询速度快o(len(str)))压缩，将term index缓存到内存，从term index查到对应term dictionary的block位置，再在磁盘上找term，减少磁盘随机读次数\",\"Posting list压缩（Frame Of Reference，增量编码压缩，将大数变小数，仅存储增量值，按bit排队（头部存储Bits per value: 1 byte，具体按实际所需bits大小存储），最后按字节存储）\",\"Roaring bitmaps，将posting list按照65535（2^16-1，2个字节表示最大数，short存储单位）为界限分块，以<商，余数>组合表示每一组id，如果块包含大于4096的值，采用bit set，否则用2个字节的数组\",\"联合索引：跳跃表（对最短posting list的每个id，在另外的posting list中查找是否存在，最后得到交集的结果）；bitset（直接按位与，得到的结果就是最后的交集）\"]},\"135\":{\"h\":\"lucene内部结构\",\"t\":[\"lucene内部数据由segment组成，写入的数据先写在内存中，经过refresh间隔将该时段的全部数据refresh成一个segment，然后merge成更大的segment。查询时会遍历每个segment，由于在内存中完成写入效率高，但存在丢失数据的风险，Elasticsearch实现了translog，防止数据丢失\",\"doc: lucene中一条记录\",\"field: 记录中的字段概念\",\"term: 索引最小单位，如果field对应内容是全文检索类型，会进行分词，结果由term组成。不分词，字段内容是一个term\",\"倒排索引(inverted index): 实现term到doc list的映射\",\"正排数据：原始数据(doc list)\",\"docvalues: 列式存储的名称，用作分析和排序\"]},\"136\":{\"h\":\"lucene文件内容\",\"t\":[\"由很多segment文件组成，每个segment包含如下文件\",\"Name\",\"Extension\",\"Brief Description\",\"Segment Info\",\".si\",\"segment的元数据文件，记录segment文档数量，对应文件列表\",\"Compound File\",\".cfs, .cfe\",\"一个segment包含了如下表的各个文件，为减少打开文件的数量，在segment小的时候，segment的所有文件内容都保存在cfs文件中，cfe文件保存了lucene各文件在cfs文件的位置信息\",\"Fields\",\".fnm\",\"保存了fields的相关信息，包括field数量，类型，是否存储，索引，分词，列存\",\"Field Index\",\".fdx\",\"正排存储文件的元数据信息\",\"Field Data\",\".fdt\",\"存储了正排存储数据，写入的原文存储在这\",\"Term Dictionary\",\".tim\",\"倒排索引的元数据信息\",\"Term Index\",\".tip\",\"倒排索引文件，存储了所有的倒排索引数据，倒排索引实现为FST tree，内存空间占用低\",\"Frequencies\",\".doc\",\"保存了每个term的doc id列表和term在doc中的词频\",\"Positions\",\".pos\",\"Stores position information about where a term occurs in the index 全文索引的字段，会有该文件，保存了term在doc中的位置\",\"Payloads\",\".pay\",\"Stores additional per-position metadata information such as character offsets and user payloads 全文索引的字段，使用了一些像payloads的高级特性会有该文件，保存了term在doc中的一些高级特性\",\"Norms\",\".nvd, .nvm\",\"文件保存索引字段加权数据\",\"Per-Document Values\",\".dvd, .dvm\",\"lucene的docvalues文件，即数据的列式存储，用作聚合和排序\",\"Term Vector Data\",\".tvx, .tvd, .tvf\",\"Stores offset into the document data file 保存索引字段的矢量信息，用在对term进行高亮，计算文本相关性中使用\",\"Live Documents\",\".liv\",\"记录了segment中删除的doc\"]},\"137\":{\"h\":\"读写数据原理\",\"t\":[\"写入数据：客户端发送请求，通过coordinating node(协调节点)对document进行路由，将请求转发给对应的node处理，然后同步到replica node，如果发现primary node和所有replica node处理完成后返回后请求到客户端\",\"写入数据底层原理(refresh, flush, translog, merge)\",\"先写入buffer(buffer里面数据搜索不到）同时写入translog日志文件；\",\"buffer快满，或一段时间后，将buffer数据refresh到新的OS cache中，每秒将OS cache数据写入segment file。如果每秒没有新数据到buffer，会创建新的空segment file，只要buffer中数据被refresh到OS cache中，数据就可以被搜索到。只要数据输入到OS cache中，buffer内容就清空。同时数据到shard后，会写入translog，每隔5秒将translog中的数据持久化到磁盘\",\"当translog文件变大到一定程度，会触发commit操作，将一个commit point写入到磁盘文件，标识对应的所有segment file，将OS cache中数据fsync到磁盘（在commit前，所有数据都在buffer或OS cache中，一旦宕机则数据丢失，重启会读取translog日志文件数据恢复）。将translog文件清空，重新启动一个translog，默认每隔30分钟commit。整个commit过程叫做一个flush操作\",\"删除操作，commit时会产生.del文件，将doc标记为delete状态\",\"更新操作，将原来的doc标识为delete状态，重新写入\",\"会产生很多segment file文件，将定期执行merge操作，将多个segment file合并为一个，同时将标记为delete文件删除，将新segment file写入磁盘，会写一个commit point，标识所有新的segment file\",\"读数据：客户端发送请求，通过coordinating node对document路由转发，在primary shard及所有replica中随机选择一个，让读请求负载均衡，接受请求的node，返回document给coordinate node，再返回给客户端\",\"搜索数据：客户端发送请求，通过coordinating node将搜索请求转发给所有的shard对应的primary shard或replica shard，每个shard将搜索结果（唯一标识），返回给协调节点进行数据合并，排序，分页等操作，然后根据唯一标识去各节点拉取数据，最后返回给客户端\",\"搜索底层原理\",\"将广播请求到搜索的每一个节点的分片拷贝，查询请求可被主分片或副分片处理，协调节点在之后请求轮询所有分片拷贝\",\"每个分片将在本地构建优先级队列，若要求返回结果排序从from开始数量为size的结果集，每个节点都会产生from+size的结果集，然会把结果集中每个文档ID和排序所需信息返回给协调节点\",\"协调节点将所有结果汇总，进行全局排序，确定实际需要的文档，向含有该文档的分片请求，然后返回给客户端\"]},\"138\":{\"h\":\"React / Vue\",\"t\":[\"虚拟DOM，就是用一个JS对象描述一个DOM节点。产生的原因以及最大用途：数据驱动视图，数据发生变化视图就要随之更新，更新视图时需要操作DOM，而操作真实DOM非常耗费性能，因为浏览器的标准把DOM设计得非常复杂，真正的DOM元素非常庞大。可以用JS模拟出一个DOM节点，当数据发生变化时，对比变化前后的虚拟DOM节点，通过DOM-Diff算法计算出需要更新的地方，然后更新需要更新的视图。传统diff算法复杂度o(n^3)\"]},\"139\":{\"h\":\"React\",\"t\":[\"将Virtual DOM树转换成actual DOM树的最少操作过程称为协调(Reconciliation)。V16版本前协调机制是Stack reconciler(修改期间，主线程被js占用，因此任何交互、布局、渲染都会停止)，diff算法策略（复杂度o(n)）\",\"web UI跨级移动操作非常少，可忽略不计(tree diff)\",\"拥有相同类型的两个组件产生的DOM结构相似，反之则不尽相同(component diff, React基于组件开发)\",\"对于同一层级的一组子节点，通过分配唯一id进行区分(Element diff)\",\"V16版本是Fiber reconciler(Fiber, 纤维，比线程控制得更精密的并发处理机制，将任务分片，划分优先级，同时能够实现类似操作系统中对线程抢占式调度，packages\\\\react-reconciler\\\\src ReactInternalTypes.js )，从依赖于内置堆栈的同步递归模型，变为具有链表和指针的异步模型，每个Element对应一个Fiber Node，成为Fiber Tree（层次遍历，diff策略建立在节点操作都在节点树同一层级中进行），记录当前页面状态，采用双缓存的策略(double buffering)，创建WorkInProgress Tree, 反映要刷新到屏幕的未来状态，构造完毕，将当前指针指向WorkInProgress Tree，丢弃旧Fiber Tree，复用内部对象(fiber)，节省内存分配和GC时间开销。\"]},\"140\":{\"h\":\"Vue\",\"t\":[\"VNode类(src/core/vdom/vnode.js)可以实例出不同类型的虚拟DOM节点，视图渲染前，template模板先编译成VNode并缓存，数据变化后生成的VNode与前一次缓存的VNode比较，有差异的VNode对应的真实DOM节点重新渲染插入视图，完成一次视图更新\",\"diff策略：只进行同层级比较，忽略跨级操作（src/core/vdom/patch.js）\"]},\"141\":{\"h\":\"HBase\",\"t\":[\"基于列存储，数据持久化在HDFS（HDFS块block设置，如果过大，从磁盘传输数据时间会明显大于寻址时间，导致处理数据时较慢，如果过小，大量小文件会占用NameNode大量内存存储元数据，寻址时间增大，HDFS中凭据寻址时间大概为10ms，当寻址时间为传输时间的1%，为最佳状态，目前磁盘传输速率普遍为100MB/s，最佳block大小为100MB，设为128MB）。分布式数据库，使用zookeeper管理集群，分为Master和RegionServer\"]},\"142\":{\"h\":\"MongoDB\"},\"143\":{\"h\":\"Kafka\",\"t\":[\"工作模式：启动zookeeper的server；启动kafka的server；producer生产数据，通过zookeeper找到broker(每个kafka实例称为broker)，再将数据push到Broker保存；customer通过zookeeper找到broker，再主动pull数据\",\"Producer: 生产message到topic\",\"Consumer: 订阅topic消费message，consumer作为一个线程消费，消费消息策略（roundrobin）\",\"Consumer Group: 包含多个consumer，维护一个下标文件offset，记录当前组消费数据下标，消费一条，offset递增1。partition中每个message只能被一个组中的consumer消费，其他consumer不能消费同一topic中同一分区的数据，不同组consumer可以消费同一topic同一分区的数据\",\"Broker：kafka节点(中间存储阵列)，多个broker组成kafka集群，负责持久化和备份具体kafka消息\",\"Topic: 一类消息，消息存放的目录即主题（轮询：顺序分发，仅针对message没有key时；Hash分区：message有key时，key.hash%分区个数，增加分区时，partition里的message不会重分配，数据继续写入才会参与load balance）\",\"Partition: 分区，topic物理上分组，每个partition是一个有序的队列，对应文件夹{topicname}{partition}{序号}，集群负载均衡基本单位，每条消息在partition中位置称为offset偏移量，类型为long型数字，消息被消费，不会立即删除，根据borker设置(基于时间存储或基于大小)，到期不管消息是否消费，都清除\",\"Segment: partition物理上由多个segment组成，每个Segment存储多个message信息（默认1G，7天后删除），每个message由key-value和时间戳组成。包括index file（.index，元数据指向数据文件message物理偏移地址）和data file(.log)。第一个segment文件名从0开始，后续为上一个最后一条消息的offset，数字最大为64位long，19位数字字符长度，没有数字用0填充\",\"Segment data file\",\"8 byte offset\",\"消息id(offset)\",\"4 byte message size\",\"message大小\",\"4 byte CRC32\",\"用crc32校验message\",\"1 byte magic\",\"kafka服务程序协议版本号\",\"1 byte attributes\",\"独立版本、或标识压缩类型、或编码类型\",\"4 byte key length\",\"key的长度，key为-1时，K byte key字段不填\",\"K byte key\",\"可选\",\"value bytes payload\",\"实际消息数据\",\"查找message步骤：根据offset二分查找文件列表，定位文件，在.index文件中有两列（序列，地址），其中序列=查找message的偏移量-当前文件的起始偏移量，根据序列对应的地址，找到相应位置的message\",\"zookeeper保存Consumer和Producer信息\"]},\"144\":{\"h\":\"RabbitMQ\"},\"145\":{\"h\":\"RocketMQ\"},\"146\":{\"h\":\"算法简介\"},\"147\":{\"h\":\"选择排序\"},\"148\":{\"h\":\"递归\",\"t\":[\"如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要\",\"每个递归函数都有两部分：基线条件(base case，函数不再调用自己，避免形成无限循环)和递归条件(recursive case，函数调用自己)\",\"栈包含未完成的函数调用，无需自己跟踪。但是存储详尽的信息可能占用大量的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息（考虑使用循环）\"]},\"149\":{\"h\":\"快速排序\",\"t\":[\"分而治之(divide and conquer, D&C)\",\"合并排序和快速排序：快速查找的常量比合并查找小，所以快速查找速度将更快\",\"平均情况和最糟情况：假设总是将第一个元素用作基准值，且要处理的数组是有序的，快速排序不检查输入数组是否有序，导致栈长为o(n)，最佳情况下，栈长为o(logn)。调用栈每层都涉及o(n)个元素。所以最糟情况是o(n^2)，最佳情况是o(nlogn)。只要每次都随机选择一个数组元素作为基准值，最佳情况也是平均情况\"]},\"150\":{\"h\":\"散列表(hash table)\",\"t\":[\"被用于大海捞针式的查找。如将网址映射到IP地址，称为DNS解析(DNS resolution)\",\"避免冲突：较低的填装因子（越低发生冲突的可能性越小，经验规则：一旦填装因子大于0.7，就调整散列表的长度），良好的散列函数\"]},\"151\":{\"h\":\"广度优先搜索(breadth-first search, BFS)\",\"t\":[\"解决最短路径问题(shortest-path problem)的算法\",\"广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系。\",\"创建一个队列，用于存储要检查的对象，从队列弹出一个对象，检查是否符合条件，如果不符合，将这个对象的所有邻居都加入队列，循环反复，使用一个列表记录检查过的对象（避免导致无限循环），如找到，则结束，如队列为空，则说明没有符合条件的对象\",\"时间复杂度o(V+E)，V为顶点(vertice)数，E为边数\"]},\"152\":{\"h\":\"狄克斯特拉算法\",\"t\":[\"找出总权重最小的路径，只适用于有向无环图(directed acyclic graph, DAG)。找出可在最短时间内到达的节点，对于该节点的邻居，检查是否有前往它们的更短路径，如有，更新其开销，重复直到对图中每个节点都进行计算，计算最终路径\",\"需要三个散列表，GRAPH(节点所有邻居),COSTS(开销),PARENTS(存储父节点)，一个数组，用于记录处理过的节点\",\"如果有负权边，就不能使用狄克斯特拉算法(没有比不支付任何费用更便宜的方式，基于假设：对于处理过的节点，没有前往该节点的更短路径，仅在没有负权边时才成立)\",\"包含负权边的图，可使用贝尔曼-福德算法(Bellman-Ford algorithm)\"]},\"153\":{\"h\":\"贪婪算法\",\"t\":[\"每步都选择局部最优解，最终得到的就是全局最优解\",\"当只需找到能够大致解决问题的算法，可使用贪婪算法，因为实现容易，得到的结果与正确结果接近\",\"近似算法(approximation algorithm)：在获得精确解需要时间太长，可使用。判断标准：速度，近似解与最优解的接近程度\"]},\"154\":{\"h\":\"NP完全问题\",\"t\":[\"以难解著称的问题，如旅行商问题和集合覆盖问题\",\"判断是不是NP完全问题：\",\"元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢；\",\"涉及“所有组合”的问题通常是NP完全问题；\",\"不能将问题分成小问题，必须考虑各种可能的情况，可能是；\",\"如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，可能是；\",\"如果问题涉及集合（如广播台集合）且难以解决，可能是；\",\"如果问题可转换为集合覆盖问题或旅行商问题，肯定是。\"]},\"155\":{\"h\":\"动态规划\",\"t\":[\"每个子问题都是离散的，即不依赖于其他子问题时\",\"费曼算法（Feyman algorithm)：将问题写下来；好好思考；将答案写下来\",\"应用场景：需要在给定约束条件下优化某种指标；问题可分解为离散子问题时\"]},\"156\":{\"h\":\"K最近邻算法(k-nearest neighbours, KNN)\",\"t\":[\"余弦相似度(consine similarity) 不计算两个矢量的距离，而比较角度，更适合处理不同用户评分方式的差异\",\"推荐系统\",\"光学字符识别(OCR, optional character recognition)\",\"垃圾邮件过滤器 朴素贝叶斯分类器(Naive Bayes classifier)\",\"预测股票市场\"]},\"157\":{\"h\":\"其他\",\"t\":[\"树\",\"反向索引(inverted index)\",\"傅里叶变换\",\"并行算法：速度提升并非线性(并行性管理开销，负载均衡)\",\"MapReduce：映射(map)，归并(reduce)\",\"布隆过滤器和HyperLogLog(近似计算集合中不同元素数)\",\"SHA(安全散列，secure hash algorithm)算法\",\"局部敏感的散列算法(Simhash，对字符串做细微修改，生成的散列值也只存在细微的差别，用于检查两项内容的相似程度)\",\"Diffe-Hellman密钥交换(公钥，私钥)\",\"线性规划：在给定约束条件下最大限度改善指定的指标 Simplex算法\"]},\"158\":{\"h\":\"正则表达式\",\"t\":[\"在编写处理字符串的程序或网页时，经常有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\",\"常用元字符\",\"代码\",\"说明\",\".\",\"匹配除换行符以外的任意字符\",\"\\\\w\",\"匹配字母或数字或下划线\",\"\\\\s\",\"匹配任意的空白符\",\"\\\\d\",\"匹配数字\",\"\\\\b\",\"匹配单词的开始或结束\",\"^\",\"匹配字符串的开始\",\"$\",\"匹配字符串的结束\",\"常用限定符\",\"代码/语法\",\"说明\",\"*\",\"重复零次或更多次\",\"+\",\"重复一次或更多次\",\"?\",\"重复零次或一次\",\"重复n次\",\"重复n次或更多次\",\"重复n到m次\",\"常用反义词\",\"代码/语法\",\"说明\",\"\\\\W\",\"匹配任意不是字母，数字，下划线，汉字的字符\",\"\\\\S\",\"匹配任意不是空白符的字符\",\"\\\\D\",\"匹配任意非数字的字符\",\"\\\\B\",\"匹配不是单词开头或结束的位置\",\"[^x]\",\"匹配除了x以外的任意字符\",\"[^aeiou]\",\"匹配除了aeiou这几个字母以外的任意字符\"]},\"159\":{\"h\":\"大话设计模式\"},\"160\":{\"h\":\"单一职责原则（SRP）\",\"t\":[\"就一个类而言，应该仅有一个引起它变化的原因。如果能够想到多于一个动机去改变一个类，那么这个类就具有多于一个的职责[ASD]，就应该考虑类的职责分离\"]},\"161\":{\"h\":\"开放-关闭原则（The Open-Closed Principle, OCP）\",\"t\":[\"软件实体（类、模块、函数等）应该可以扩展，但不可修改。对于扩展开放(Open for extension)，对于更改封闭（Closed for modification）。可维护，可扩展，可复用，灵活性好\"]},\"162\":{\"h\":\"依赖倒转原则\",\"t\":[\"抽象不应该依赖细节，细节应该依赖于抽象。高层模块不应该依赖低层模块，两个都应该依赖抽象\"]},\"163\":{\"h\":\"里式代换原则(LSP)\",\"t\":[\"子类型不许能够替换掉它们的父类型\"]},\"164\":{\"h\":\"迪米特法则(LoD)\",\"t\":[\"如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用\",\"在类的结构设计上，每一个类都应当尽量降低成员的访问权限。强调了类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及\"]},\"165\":{\"h\":\"合成/聚合复用原则（CARP）\",\"t\":[\"尽量使用合成(Composition)/聚合(Aggregation)，尽量不要使用类继承（继承是一种强耦合的结构，父类变，子类就必须要变，要在是'is-a'的关系时再考虑使用）\",\"聚合表示一种弱的拥有关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的拥有关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样\",\"优先使用对象的合成/聚合将有助于保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。\"]},\"166\":{\"h\":\"简单工厂模式\",\"t\":[\"用一个单独的类来做创造一个接口各子类实例\"]},\"167\":{\"h\":\"策略模式(Strategy)\",\"t\":[\"定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户\",\"Strategy类，定义所有支持的算法的公共接口\",\"ConcreteStrategy，封装具体算法或行为，继承Strategy\",\"Context上下文，用ConcreteStrategy配置，维护对Strategy对象的引用\",\"以相同方式调用所有算法，减少各种算法类与使用算法类之间的耦合[DPE]，Context定义了 一系列可重用的算法或行为，继承有助于析取这些算法中的公共功能[DP]，简化单元测试。如果可以用它封装几乎任何类型的规则，只要 在分析过程中需要在不同时间应用不同的业务规则，就可以用策略模式处理这种变化的可能性[DPE]\"]},\"168\":{\"h\":\"装饰模式(Decorator)\",\"t\":[\"动态给一个对象添加一些额外的职责，就增加功能而言，装饰模式比生成子类更为灵活。\",\"把要装饰的功能放在单独的类中，并让这个类包装所要修饰的对象，因此需要执行特殊行为时，可以在运行时根据需要使用装饰功能包装对象。有效地把类的核心职责和装饰功能区分开，可以去除相关类中重复的装饰逻辑\",\"Component: 定义一个对象接口，可以给对象动态添加职责\",\"ConcreteComponent: 定义一个具体对象，也可以给对象添加一些职责\",\"Decorator: 装饰抽象类，继承Component，从外类扩展Component类的功能，但对于Component来说，无需知道Decorator存在（利用SetComponent包装对象，装饰对象的实现和如何使用对象分离，每个装饰对象只关心自己的功能，不需关心如何被添加到对象链中）\",\"ConcreteDecorator: 具体的装饰对象，起到Component添加职责的功能\"]},\"169\":{\"h\":\"代理模式（Proxy）\",\"t\":[\"为其他对象提供一种代理以控制这个对象的访问\",\"Subject类：定义RealSubject和Proxy的共用接口，就可以在任何使用RealSubject的地方使用Proxy\",\"RealSubject类：定义Proxy所代表的真实实体\",\"Proxy类：保存一个引用使得代理可以访问实体\",\"应用场景：1）远程代理，为一个对象在不同的地址空间提供局部代表，可以隐藏一个对象存在不同地址空间的事实；2）虚拟代理，根据需要创建开销很大的对象，存放实例化需要很长时间的真实对象；3）安全代理，控制真实对象访问时的权限；4）智能指引，当调用真实对象时，代理处理另外一些事。\"]},\"170\":{\"h\":\"工厂方法模式（Factory Method）\",\"t\":[\"定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。\",\"简单工厂模式最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关类，对于客户端来说，去除了与具体产品的依赖。工厂方法把简单工厂的内部逻辑判断移到客户端代码来进行。工厂方法克服简单工厂违背开放-封闭原则的缺点，保持了封装对象创建过程的优点。它们都是集中封装了对象的创建，使得要更换对象时，不要做大的改动就可实现，降低客户程序与产品对象的耦合。工厂方法模式是简单工厂模式进一步抽象和推广，缺点是每加一个产品，就要加一个产品工厂的类，增加了额外的开发量。\",\"Product: 定义工厂方法所创建对象的接口\",\"ConcreteProduct: 具体的产品，实现Product接口\",\"Creator: 声明工厂方法，返回一个Product类型的对象\",\"ConcreteCreator: 重定义工厂方法以返回一个ConcreteProduct实例\"]},\"171\":{\"h\":\"原型模式 (Prototype)\",\"t\":[\"用原型实例指定创建对象的种类，并且通过拷贝这些原型对象创建新的对象\",\"Prototype: 原型类，声明一个克隆自身的接口\",\"ConcretePrototype: 具体原型类，实现一个克隆自身的操作\",\"Client: 让一个原型克隆自身，从而创建一个新的对象\"]},\"172\":{\"h\":\"模板方法模式(TemplateMethod)\",\"t\":[\"当要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，通常考虑用模板方法模式处理\",\"定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤\",\"AbstractClass: 实现一个模板方法，定义算法骨架，具体子类将重定义PrimitiveOperation以实现一个算法步骤\",\"ConcreteClass: 实现PrimitiveOperation以完成算法中与特定子类相关的步骤\",\"模板方法模式通过把不变行为搬移到超类，去除子类中重复代码。\"]},\"173\":{\"h\":\"外观模式（Facade，门面模式）\",\"t\":[\"为子系统中的一组接口提供一个一致的界面。此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\",\"Facade: 外观类，知道哪些子系统类负责处理请求，将客户的请求代理给适当的子系统对象\",\"SubSystem Classes: 子系统类集合，实现子系统的功能，处理Facade对象指派的任务。子类中没有Facade的任何信息，即没有对Facade对象的引用\",\"应用场景：设计初期，应该有意识的将不同的两个层分离，层与层之间建立外观Facade；开发阶段，系统往往因为不断重构演化而变得越来越复杂，增加外观Facade提供一个简单的接口，减少它们之间的依赖；维护一个遗留的大型系统，可能系统已经非常难以维护和扩展，可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作\"]},\"174\":{\"h\":\"建造者模式（Builder）\",\"t\":[\"将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\",\"Builder: 为创建一个Product对象的各个部件指定的抽象接口\",\"ConcreteBuilder: 具体建造者，实现Builder接口，构造和装配各个部件\",\"Director: 指挥者，是构建一个使用Builder接口的对象\",\"应用场景：创建一些复杂对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。\"]},\"175\":{\"h\":\"观察者模式（Observer, 发布-订阅Publish/Subscribe模式）\",\"t\":[\"定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己\",\"Subject: 把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象\",\"ConcreteSubject: 具体主题，将有关状态存入具体观察者对象，在具体主题的内部状态改变时，给所有登记过的观察者发出通知\",\"Observer: 抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己\",\"ConcreteObserver: 具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调\",\"应用场景 ：当一个对象的改变需要同时改变其他对象，而不知道具体有多少对象要改变\"]},\"176\":{\"h\":\"抽象工厂模式（Abstract Factory)\",\"t\":[\"提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类\",\"AbstractFactory: 抽象工厂接口，包含所有产品创建的抽象方法\",\"ConcreteFactory: 具体工厂，创建具有特定实现的产品对象\",\"AbstractProduct: 抽象产品，可能有不同的实现\",\"Product: 对抽象产品的具体分类的实现\",\"好处：易于交换产品系列，由于具体工厂类，只需初始化时出现一次；让具体的创建实例过程与客户端分离，客户端通过抽象接口操纵实例\",\"缺点：如果增加产品，需要增加抽象产品及实现类，还需要修改抽象工厂和具体工厂，不便维护；另外多处使用就要多次声明具体工厂类，不利于修改\",\"所有用简单工厂的地方，都可以考虑用反射技术（将程序由编译时转为运行时）去除swith或if，解除分支判断带来的耦合\"]},\"177\":{\"h\":\"状态模式（State）\",\"t\":[\"当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类\",\"主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。如果状态判断很简单，就没必要用状态模式\",\"State类，抽象状态类，定义一个接口以封装与Context的一个特定状态相关的行为\",\"ConcreteState类，具体状态，每一个子类实现一个与Context的一个状态相关的行为\",\"Context类，维护一个ConcreteState子类的实例，这个实例定义当前的状态\"]},\"178\":{\"h\":\"适配器模式(Adapter)\",\"t\":[\"将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作\",\"系统的数据和行为都正确，但接口不符时，应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况\",\"Target：客户所期待的接口，目标可以是具体的或抽象的类，也可以是接口\",\"Adaptee: 需要适配的类\",\"Adapter: 通过在内部包装一个Adaptee对象，把源接口转换成目标接口\"]},\"179\":{\"h\":\"备忘录模式(Memento)\",\"t\":[\"在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态\",\"Originator(发起人)：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态\",\"Memento(备忘录)：负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据\",\"Caretaker(管理者)：负责保存好备忘录Memento，不能对备忘录的内容进行操作或检查\",\"Memento模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，Originator可以根据保存的Memento信息还原到前一状态\"]},\"180\":{\"h\":\"组合模式(Composite)\",\"t\":[\"将对象组合成树形结构以表示\\\"部分-整体\\\"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性\",\"Component：组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component的子部件\",\"Leaf: 在组合中表示叶节点对象，叶结点没有子节点\",\"Composite: 定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关的操作，比如增加Add和删除Remove\",\"需求中是体现部分与整体层次的结构时，希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式\"]},\"181\":{\"h\":\"迭代器模式(Iterator)\",\"t\":[\"提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示\",\"当需要访问一个聚集对象，而且不管这些对象是什么都需要遍历时，应该考虑用迭代器模式\",\"Iterator：迭代抽象类，用于定义得到开始对象，得到下一个对象，判断是否到结尾，当前对象等抽象方法，统一接口\",\"ConcreteIterator: 具体迭代器类，继承Iterator，实现开始，下一个，是否结尾，当前对象等方法\",\"Aggregate: 聚集抽象类\",\"ConcreteAggregate: 具体聚集类 继承Aggregate\",\"迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，既可以做到不暴露集合的内部结构，又可以让外部代码透明地访问集合内部的数据\"]},\"182\":{\"h\":\"单例模式(Singleton)\",\"t\":[\"保证一个类仅有一个实例，并提供一个访问它的全局访问点\",\"通常可以让一个全局变量使得一个对象被访问，但不能防止实例化多个对象。一个最好的办法是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法\",\"Singleton类，定义一个GetInstance操作，允许客户访问它的唯一实例。GetInstance是一个静态方法，主要负责创建自己的唯一实例\",\"多线程时的单例，加锁\",\"Double-Check Locking（双重锁定）: 先判断实例是否存在，不存在再加锁处理\",\"饿汉式单例类：在类加载时就实例化，提前占用系统资源\",\"懒汉式单例类：在第一次被引用时，才会实例化，会面临多线程访问的安全性问题，需要双重锁定才能保证线程安全\"]},\"183\":{\"h\":\"桥接模式(Bridge)\",\"t\":[\"将抽象部分与它的实现部分分离，使它们都可以独立地变化\",\"Implementor类：实现\",\"ConcreteImplementorA和ConcreteImplementorB等派生类：具体实现\",\"Abstraction类：抽象\",\"RefinedAbstraction类：被提炼的抽象\",\"实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合\"]},\"184\":{\"h\":\"命令模式(Command)\",\"t\":[\"将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作\",\"Command类：用来声明执行操作的接口\",\"ConcreteCommand类：将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现Execute\",\"Invoker类：要求该命令执行这个请求\",\"Receiver类：知道如何实施与执行一个请求相关的操作，任何类都可能作为一个接收者\",\"优点：能较容易设计一个命令队列；在需要的情况下，容易将命令记录日志；允许接收请求一方决定是否要否决要求；可以容易实现对请求的撤销和重做；由于加进新的具体命令类不影响其他的类，因此新增具体命令类很容易。命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。\",\"敏捷开发原则：不要为代码添加基于猜测的，实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般不要着急实现，只有在真正需要如撤销、恢复操作等功能时，把原来的代码重构为命令模式才有意义\"]},\"185\":{\"h\":\"职责链模式(Chain of Responsibility)\",\"t\":[\"使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止\",\"Handler：定义一个处理请示的接口\",\"ConcreteHandler: 具体处理者类，处理它所负责的请求，可访问它的后继者，如果可处理该请求，就处理之，否则就将该请求转发给它的后继者\",\"接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。\"]},\"186\":{\"h\":\"中介者模式（调停者模式，Mediator）\",\"t\":[\"用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互\",\"Mediator类：抽象中介类，定义同事对象到中介者对象的接口\",\"Colleague类：抽象同事类\",\"ConcreteMediator：具体中介者对象，实现抽象类的方法，需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令\",\"ConcreteColleague：具体同事类，每个具体同事只知道自己的行为，而不了解其他同事类的情况，但它们却都认识中介者对象\",\"优点：Mediator的出现减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator；由于把对象如何协作进行抽象，将中介作为一个独立的概念并封装在一个对象中，关注的对象从对象各自本身的行为转移到它们之间的交互来。\",\"缺点：由于ConcreteMediator控制了集中化，把交互复杂性变为中介者的复杂性，使得中介者会变得比任何一个ConcreteColleague都复杂。\",\"中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多子类的场合\"]},\"187\":{\"h\":\"享元模式(Flyweight)\",\"t\":[\"运用共享技术有效地支持大量细粒度的对象\",\"Flyweight类：所有具体享元类的超类或接口，通过这个接口，Flyweight可以接受并作用于外部状态\",\"ConcreteFlyweight：继承Flyweight超类或实现Flyweight接口，并为内部状态增加存储空间\",\"UnsharedConcreteFlyweight: 不需要共享的Flyweight子类，因为Flyweight接口共享成为可能，但并不强制共享\",\"FlyweightFactory: 享元工厂，用来创建并管理Flyweight对象。主要用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个\",\"应用场景：如果一个应用程序使用了大量的对象，而大量的这些对象造成很大的存储开销时就应该考虑使用；还有对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象\",\"使用享元模式需要维护一个记录了系统已有的所有享元的列表，本身需要耗费资源，另外使得系统更加复杂，为了使对象可以共享，需要将一些状态外部化，使得程序逻辑复杂化\"]},\"188\":{\"h\":\"解释器模式(interpreter)\",\"t\":[\"给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子\",\"如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样可以构建一个解释器，该解释器通过解释这些句子来解决该问题\",\"比如正则表达式，与其为每一个特定需求都写一个算法函数，不如用一种通用的搜索算法来解释执行一个正则表达式\",\"AbstractExpression 抽象表达式，声明一个抽象的解释操作，这个接口为抽象语法树总所有的节点所共享\",\"TerminalExpression 终结符表达式，实现与文法中的终结符相关联的解释操作。实现抽象表达式中所要求的的接口，主要是一个interpret()方法。文法中每一个终结符都有一个具体终结表达式与之相对应\",\"NonterminalExpression 非终结符表达式，为文法中的非终结符实现解释操作。对文法中每一条规则R1,R2....Rn都需要一个具体的非终结符表达式类。通过实现抽象表达式的interpret()方法实现解释操作。解释操作以递归方法调用R1,R2...Rn中各个符号的实例变量\",\"Context 包含解释器之外的一些全局信息\",\"当有一个语言需要解释执行，并且可将语言中的句子表示为一个抽象语法树时，可使用解释器模式。容易地改变和扩展文法，因为该模式使用类来表示文法规则，可使用继承来改变或扩展该文法。比较容易实现文法，因为定义抽象语法树中各个节点的类实现大体类似，易于直接编写\",\"不足：为文法中每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他技术如语法分析程序或编译生成器来处理\"]},\"189\":{\"h\":\"访问者模式(Visitor)\",\"t\":[\"表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作\",\"Visitor: 为该对象结构中ConcreteElement的每一个类声明一个Visit操作\",\"ConcreteVistior: 具体访问者，实现每个由Visitor声明的操作。每个操作实现算法的一部分，而该算法片段是对应结构中对象的类\",\"Element: 定义一个Accept操作，以一个访问者为参数\",\"ConcreteElement: 具体元素，实现Accept操作\",\"ObjectStructure: 能枚举它的元素，可以提供一个高层接口以允许访问者访问它的元素\",\"应用场景：适用于数据结构比较稳定，又有易于变化的算法\",\"优点：把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。增加新的操作很容易，因为新的操作意味着一个新的访问者，将有关行为集中到一个访问者对象\",\"缺点：使增加新的数据结构变得困难\"]},\"190\":{\"h\":\"创建型模式\",\"t\":[\"抽象工厂，建造者，工厂方法，原型，单例\"]},\"191\":{\"h\":\"结构型模式\",\"t\":[\"适配器，桥接，组合，装饰，外观，享元，代理\"]},\"192\":{\"h\":\"行为型模式\",\"t\":[\"观察者，模板方法，命令，状态，职责链，解释器，中介者，访问者，策略，备忘录，迭代器\"]},\"193\":{\"h\":\"延时队列\",\"t\":[\"https://juejin.im/post/6844903648397525006\"]},\"194\":{\"h\":\"使用场景\",\"t\":[\"关注空闲连接。服务器中客户端连接，空闲一段时间后需要关闭\",\"清理过期数据。如缓存对象超过空闲时间，需要从缓存中移除\",\"任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求\",\"订单超时取消。下单后三十分钟内没有付款自动取消订单\",\"订餐通知。下单成功后60s后给用户发送短信通知\",\"订单未支付退还库存。当订单一直处于未支付状态，如何及时关闭订单，并退还库存\",\"定期检查退款状态。如何定期检查处于退款状态的订单是否已经退款成功\",\"新创建店铺，N天内没有上传商品，系统如何知道该信息，并发送激活短信\",\"定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行\"]},\"195\":{\"h\":\"实现方式\"},\"196\":{\"h\":\"定期轮询（数据库等）\",\"t\":[\"定期轮询数据库，设置状态。\",\"优点：实现简单\",\"缺点：数据量过大时会消耗太多的IO资源，效率太低\"]},\"197\":{\"h\":\"DelayQueue\",\"t\":[\"无界，延迟，阻塞队列\",\"BlockingQueue+PriorityQueue（堆排序）+Delayed\",\"DelayQueue中存放的对象需要实现compareTo()方法和getDelay()方法\",\"getDelay方法返回该元素距离失效剩余时间，当<=0时元素失效，就可以从队列中取到\"]},\"198\":{\"h\":\"Timer\",\"t\":[\"ScheduledExecutorService\",\"时间轮(kafka)\",\"RabbitMQ\",\"Quartz\",\"Redis Zset\",\"Koala\",\"JCronTab\",\"SchedulerX(阿里)\",\"有赞延迟队列\"]},\"199\":{\"h\":\"苹果 1\"},\"200\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"201\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"202\":{\"c\":[\"苹果\"]},\"203\":{\"c\":[\"红\",\"大\",\"圆\"]},\"204\":{\"h\":\"苹果 2\",\"t\":[\"一个被星标了的苹果文章。\"]},\"205\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"206\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"207\":{\"c\":[\"苹果\"]},\"208\":{\"c\":[\"红\",\"大\",\"圆\"]},\"209\":{\"h\":\"苹果 3\"},\"210\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"211\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"212\":{\"c\":[\"苹果\",\"水果\"]},\"213\":{\"c\":[\"红\",\"大\",\"圆\"]},\"214\":{\"h\":\"苹果 4\"},\"215\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"216\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"217\":{\"c\":[\"苹果\",\"水果\"]},\"218\":{\"c\":[\"红\",\"大\",\"圆\"]},\"219\":{\"h\":\"香蕉 1\"},\"220\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"221\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"222\":{\"c\":[\"香蕉\",\"水果\"]},\"223\":{\"c\":[\"黄\",\"弯曲的\",\"长\"]},\"224\":{\"h\":\"香蕉 2\",\"t\":[\"一个被数字 10 星标了的香蕉文章。\"]},\"225\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"226\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"227\":{\"c\":[\"香蕉\",\"水果\"]},\"228\":{\"c\":[\"黄\",\"弯曲的\",\"长\"]},\"229\":{\"h\":\"香蕉 3\"},\"230\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"231\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"232\":{\"c\":[\"香蕉\"]},\"233\":{\"c\":[\"黄\",\"弯曲的\",\"长\"]},\"234\":{\"h\":\"香蕉 4\"},\"235\":{\"h\":\"标题 2\",\"t\":[\"这里是内容。\"]},\"236\":{\"h\":\"标题 3\",\"t\":[\"这里是内容。\"]},\"237\":{\"c\":[\"香蕉\"]},\"238\":{\"c\":[\"黄\",\"弯曲的\",\"长\"]},\"239\":{\"h\":\"Posts\"},\"240\":{\"h\":\"分布式\"},\"241\":{\"h\":\"数据结构与算法\"},\"242\":{\"h\":\"知识点\"},\"243\":{\"h\":\"Apple\"},\"244\":{\"h\":\"Banana\"}},\"dirtCount\":0,\"index\":[[\"知识点\",{\"0\":{\"242\":1}}],[\"知道如何实施与执行一个请求相关的操作\",{\"1\":{\"184\":1}}],[\"知道哪些子系统类负责处理请求\",{\"1\":{\"173\":1}}],[\"星标了的香蕉文章\",{\"1\":{\"224\":1}}],[\"长\",{\"2\":{\"223\":1,\"228\":1,\"233\":1,\"238\":1}}],[\"长度无限制\",{\"1\":{\"101\":1}}],[\"弯曲的\",{\"2\":{\"223\":1,\"228\":1,\"233\":1,\"238\":1}}],[\"黄\",{\"2\":{\"223\":1,\"228\":1,\"233\":1,\"238\":1}}],[\"香蕉\",{\"0\":{\"219\":1,\"224\":1,\"229\":1,\"234\":1},\"2\":{\"222\":1,\"227\":1,\"232\":1,\"237\":1}}],[\"苹果\",{\"0\":{\"199\":1,\"204\":1,\"209\":1,\"214\":1},\"2\":{\"202\":1,\"207\":1,\"212\":1,\"217\":1}}],[\"阿里\",{\"1\":{\"198\":1}}],[\"堆排序\",{\"1\":{\"197\":1}}],[\"延迟\",{\"1\":{\"197\":1}}],[\"延时队列\",{\"0\":{\"193\":1}}],[\"效率太低\",{\"1\":{\"196\":1}}],[\"订单未支付退还库存\",{\"1\":{\"194\":1}}],[\"订单超时取消\",{\"1\":{\"194\":1}}],[\"订餐通知\",{\"1\":{\"194\":1}}],[\"订阅publish\",{\"0\":{\"175\":1}}],[\"订阅topic消费message\",{\"1\":{\"143\":1}}],[\"清理过期数据\",{\"1\":{\"194\":1}}],[\"空闲一段时间后需要关闭\",{\"1\":{\"194\":1}}],[\"空间占用小\",{\"1\":{\"134\":1}}],[\"空间复杂度接近翻倍\",{\"1\":{\"109\":1}}],[\"服务器中客户端连接\",{\"1\":{\"194\":1}}],[\"策略\",{\"1\":{\"192\":1}}],[\"策略模式\",{\"0\":{\"167\":1}}],[\"访问者\",{\"1\":{\"192\":1}}],[\"访问者模式\",{\"0\":{\"189\":1}}],[\"职责链\",{\"1\":{\"192\":1}}],[\"职责链模式\",{\"0\":{\"185\":1}}],[\"命令\",{\"1\":{\"192\":1}}],[\"命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开\",{\"1\":{\"184\":1}}],[\"命令模式\",{\"0\":{\"184\":1}}],[\"观察者\",{\"1\":{\"192\":1}}],[\"观察者模式\",{\"0\":{\"175\":1}}],[\"桥接\",{\"1\":{\"191\":1}}],[\"桥接模式\",{\"0\":{\"183\":1}}],[\"易于直接编写\",{\"1\":{\"188\":1}}],[\"易于交换产品系列\",{\"1\":{\"176\":1}}],[\"非终结符表达式\",{\"1\":{\"188\":1}}],[\"非叶子节点用于快速定位包含目标值的叶子节点\",{\"1\":{\"114\":1}}],[\"方法和getdelay\",{\"1\":{\"197\":1}}],[\"方法实现解释操作\",{\"1\":{\"188\":1}}],[\"方法\",{\"1\":{\"188\":1,\"197\":1}}],[\"方案4\",{\"0\":{\"63\":1}}],[\"方案3\",{\"0\":{\"62\":1}}],[\"方案2\",{\"0\":{\"61\":1}}],[\"方案1\",{\"0\":{\"59\":1}}],[\"终结符表达式\",{\"1\":{\"188\":1}}],[\"给定一个语言\",{\"1\":{\"188\":1}}],[\"给所有登记过的观察者发出通知\",{\"1\":{\"175\":1}}],[\"本身需要耗费资源\",{\"1\":{\"187\":1}}],[\"本页面就是一个示例\",{\"1\":{\"4\":1}}],[\"享元\",{\"1\":{\"191\":1}}],[\"享元工厂\",{\"1\":{\"187\":1}}],[\"享元模式\",{\"0\":{\"187\":1}}],[\"运用共享技术有效地支持大量细粒度的对象\",{\"1\":{\"187\":1}}],[\"调停者模式\",{\"0\":{\"186\":1}}],[\"调用接收者相应的操作\",{\"1\":{\"184\":1}}],[\"调用栈每层都涉及o\",{\"1\":{\"149\":1}}],[\"恢复操作等功能时\",{\"1\":{\"184\":1}}],[\"敏捷开发原则\",{\"1\":{\"184\":1}}],[\"才会实例化\",{\"1\":{\"182\":1}}],[\"才使用行锁\",{\"1\":{\"119\":1}}],[\"懒汉式单例类\",{\"1\":{\"182\":1}}],[\"饿汉式单例类\",{\"1\":{\"182\":1}}],[\"双重锁定\",{\"1\":{\"182\":1}}],[\"双端链表\",{\"1\":{\"122\":1}}],[\"又有易于变化的算法\",{\"1\":{\"189\":1}}],[\"又可以让外部代码透明地访问集合内部的数据\",{\"1\":{\"181\":1}}],[\"又不能强制commit的阻塞状态\",{\"1\":{\"78\":1}}],[\"既可以做到不暴露集合的内部结构\",{\"1\":{\"181\":1}}],[\"聚集抽象类\",{\"1\":{\"181\":1}}],[\"聚合将有助于保持每个类被封装\",{\"1\":{\"165\":1}}],[\"聚合表示一种弱的拥有关系\",{\"1\":{\"165\":1}}],[\"聚合\",{\"1\":{\"165\":1}}],[\"聚合复用原则\",{\"0\":{\"165\":1}}],[\"统一接口\",{\"1\":{\"181\":1}}],[\"统一地使用组合结构中的所有对象时\",{\"1\":{\"180\":1}}],[\"迭代器\",{\"1\":{\"192\":1}}],[\"迭代器模式就是分离了集合对象的遍历行为\",{\"1\":{\"181\":1}}],[\"迭代器模式\",{\"0\":{\"181\":1}}],[\"迭代抽象类\",{\"1\":{\"181\":1}}],[\"需求中是体现部分与整体层次的结构时\",{\"1\":{\"180\":1}}],[\"需要从缓存中移除\",{\"1\":{\"194\":1}}],[\"需要将一些状态外部化\",{\"1\":{\"187\":1}}],[\"需要知道所有具体同事类\",{\"1\":{\"186\":1}}],[\"需要双重锁定才能保证线程安全\",{\"1\":{\"182\":1}}],[\"需要适配的类\",{\"1\":{\"178\":1}}],[\"需要增加抽象产品及实现类\",{\"1\":{\"176\":1}}],[\"需要在给定约束条件下优化某种指标\",{\"1\":{\"155\":1}}],[\"需要在上游系统中实现消息重试发布机制\",{\"1\":{\"62\":1}}],[\"需要在上游系统中建立消息重发机制\",{\"1\":{\"62\":1}}],[\"需要三个散列表\",{\"1\":{\"152\":1}}],[\"需要三种角色\",{\"1\":{\"59\":1}}],[\"需要处理hash冲突\",{\"1\":{\"115\":1}}],[\"需要指针域\",{\"1\":{\"102\":1}}],[\"需要预分配存储空间\",{\"1\":{\"99\":1}}],[\"需要请求5个节点才能获取到锁\",{\"1\":{\"95\":1}}],[\"需要引入多数派\",{\"1\":{\"86\":1}}],[\"需要对proposer做约束\",{\"1\":{\"80\":1}}],[\"需要对服务器进行配置\",{\"1\":{\"74\":1}}],[\"需要另一角色把系统从不可结束的状态中带出来\",{\"1\":{\"77\":1}}],[\"需要更好的服务器硬件条件\",{\"1\":{\"74\":1}}],[\"需要配置负载均衡器\",{\"1\":{\"74\":1}}],[\"需要监听自己的前一个子节点\",{\"1\":{\"73\":1}}],[\"叶结点没有子节点\",{\"1\":{\"180\":1}}],[\"叶子节点除索引值只存储指向行数据的指针\",{\"1\":{\"114\":1}}],[\"叶子节点之间以链表关联\",{\"1\":{\"114\":1}}],[\"叶子节点的值有序\",{\"1\":{\"114\":1}}],[\"叶子节点存放所有索引值\",{\"1\":{\"114\":1}}],[\"部分\",{\"1\":{\"180\":1}}],[\"部分和整体的生命周期一样\",{\"1\":{\"165\":1}}],[\"它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作\",{\"1\":{\"189\":1}}],[\"它们仅需保持一个指向其后继者的引用\",{\"1\":{\"185\":1}}],[\"它们都是集中封装了对象的创建\",{\"1\":{\"170\":1}}],[\"它只能将备忘录传递给其他对象\",{\"1\":{\"179\":1}}],[\"备忘录有两个接口\",{\"1\":{\"179\":1}}],[\"备忘录\",{\"1\":{\"179\":1,\"192\":1}}],[\"备忘录模式\",{\"0\":{\"179\":1}}],[\"捕获一个对象的内部状态\",{\"1\":{\"179\":1}}],[\"客户所期待的接口\",{\"1\":{\"178\":1}}],[\"客户端通过抽象接口操纵实例\",{\"1\":{\"176\":1}}],[\"客户端发送请求\",{\"1\":{\"137\":3}}],[\"客户端必须获取到全部3个节点的锁才能拥有锁\",{\"1\":{\"95\":1}}],[\"客户端获取\",{\"1\":{\"73\":1}}],[\"目标可以是具体的或抽象的类\",{\"1\":{\"178\":1}}],[\"目的是使控制范围之外的一个原有对象与某个接口匹配\",{\"1\":{\"178\":1}}],[\"目前磁盘传输速率普遍为100mb\",{\"1\":{\"141\":1}}],[\"好处\",{\"1\":{\"176\":1}}],[\"好好思考\",{\"1\":{\"155\":1}}],[\"构造和装配各个部件\",{\"1\":{\"174\":1}}],[\"构造完毕\",{\"1\":{\"139\":1}}],[\"建造者\",{\"1\":{\"190\":1}}],[\"建造者模式\",{\"0\":{\"174\":1}}],[\"建议当文法非常复杂时\",{\"1\":{\"188\":1}}],[\"建议采用zookeeper锁\",{\"1\":{\"97\":1}}],[\"建议采用缓存锁\",{\"1\":{\"97\":1}}],[\"来提供设计粗糙或高度复杂的遗留代码比较清晰简单的接口\",{\"1\":{\"173\":1}}],[\"来解析\",{\"1\":{\"16\":1}}],[\"外观\",{\"1\":{\"191\":1}}],[\"外观类\",{\"1\":{\"173\":1}}],[\"外观模式\",{\"0\":{\"173\":1}}],[\"门面模式\",{\"0\":{\"173\":1}}],[\"去除swith或if\",{\"1\":{\"176\":1}}],[\"去除子类中重复代码\",{\"1\":{\"172\":1}}],[\"去除了与具体产品的依赖\",{\"1\":{\"170\":1}}],[\"模板方法\",{\"1\":{\"192\":1}}],[\"模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤\",{\"1\":{\"172\":1}}],[\"模板方法模式通过把不变行为搬移到超类\",{\"1\":{\"172\":1}}],[\"模板方法模式\",{\"0\":{\"172\":1}}],[\"模块\",{\"1\":{\"161\":1}}],[\"声明一个抽象的解释操作\",{\"1\":{\"188\":1}}],[\"声明一个接口用于访问和管理component的子部件\",{\"1\":{\"180\":1}}],[\"声明一个克隆自身的接口\",{\"1\":{\"171\":1}}],[\"声明工厂方法\",{\"1\":{\"170\":1}}],[\"封闭原则的缺点\",{\"1\":{\"170\":1}}],[\"封装具体算法或行为\",{\"1\":{\"167\":1}}],[\"智能指引\",{\"1\":{\"169\":1}}],[\"控制真实对象访问时的权限\",{\"1\":{\"169\":1}}],[\"虚拟代理\",{\"1\":{\"169\":1}}],[\"虚拟dom\",{\"1\":{\"138\":1}}],[\"远程代理\",{\"1\":{\"169\":1}}],[\"代理\",{\"1\":{\"191\":1}}],[\"代理处理另外一些事\",{\"1\":{\"169\":1}}],[\"代理模式\",{\"0\":{\"169\":1}}],[\"代码块\",{\"0\":{\"20\":1}}],[\"代码\",{\"1\":{\"19\":1,\"158\":3}}],[\"起到component添加职责的功能\",{\"1\":{\"168\":1}}],[\"利用setcomponent包装对象\",{\"1\":{\"168\":1}}],[\"装饰\",{\"1\":{\"191\":1}}],[\"装饰对象的实现和如何使用对象分离\",{\"1\":{\"168\":1}}],[\"装饰抽象类\",{\"1\":{\"168\":1}}],[\"装饰模式比生成子类更为灵活\",{\"1\":{\"168\":1}}],[\"装饰模式\",{\"0\":{\"168\":1}}],[\"动态给一个对象添加一些额外的职责\",{\"1\":{\"168\":1}}],[\"动态规划\",{\"0\":{\"155\":1}}],[\"简化单元测试\",{\"1\":{\"167\":1}}],[\"简单工厂模式最大优点在于工厂类中包含了必要的逻辑判断\",{\"1\":{\"170\":1}}],[\"简单工厂模式\",{\"0\":{\"166\":1}}],[\"简单动态字符串\",{\"0\":{\"123\":1},\"1\":{\"122\":1,\"123\":1}}],[\"继承flyweight超类或实现flyweight接口\",{\"1\":{\"187\":1}}],[\"继承aggregate\",{\"1\":{\"181\":1}}],[\"继承iterator\",{\"1\":{\"181\":1}}],[\"继承component\",{\"1\":{\"168\":1}}],[\"继承有助于析取这些算法中的公共功能\",{\"1\":{\"167\":1}}],[\"继承strategy\",{\"1\":{\"167\":1}}],[\"继承是一种强耦合的结构\",{\"1\":{\"165\":1}}],[\"优先使用对象的合成\",{\"1\":{\"165\":1}}],[\"优点\",{\"1\":{\"63\":1,\"75\":1,\"97\":3,\"184\":1,\"186\":1,\"189\":1,\"196\":1}}],[\"体现了严格的部分和整体的关系\",{\"1\":{\"165\":1}}],[\"体现的是a对象可以包含b对象\",{\"1\":{\"165\":1}}],[\"父类变\",{\"1\":{\"165\":1}}],[\"尽量不要使用类继承\",{\"1\":{\"165\":1}}],[\"尽量使用合成\",{\"1\":{\"165\":1}}],[\"尽量选择支持事务型消息的消息中间件来实现分布式事务\",{\"1\":{\"62\":1}}],[\"合成则是一种强的拥有关系\",{\"1\":{\"165\":1}}],[\"合成\",{\"0\":{\"165\":1}}],[\"合并排序和快速排序\",{\"1\":{\"149\":1}}],[\"越有利于复用\",{\"1\":{\"164\":1}}],[\"越低发生冲突的可能性越小\",{\"1\":{\"150\":1}}],[\"强调了类之间的松耦合\",{\"1\":{\"164\":1}}],[\"强一致要求多节点组成的被调要能像单节点一样运作\",{\"1\":{\"69\":1}}],[\"强一致性\",{\"1\":{\"67\":1}}],[\"迪米特法则\",{\"0\":{\"164\":1}}],[\"子系统类集合\",{\"1\":{\"173\":1}}],[\"子类中没有facade的任何信息\",{\"1\":{\"173\":1}}],[\"子类就必须要变\",{\"1\":{\"165\":1}}],[\"子类型不许能够替换掉它们的父类型\",{\"1\":{\"163\":1}}],[\"子结点可以多于两个\",{\"1\":{\"103\":1}}],[\"里式代换原则\",{\"0\":{\"163\":1}}],[\"高层模块不应该依赖低层模块\",{\"1\":{\"162\":1}}],[\"高可用之\",{\"0\":{\"76\":1}}],[\"高可用并允许分区\",{\"1\":{\"67\":1}}],[\"细节应该依赖于抽象\",{\"1\":{\"162\":1}}],[\"抽象表达式\",{\"1\":{\"188\":1}}],[\"抽象同事类\",{\"1\":{\"186\":1}}],[\"抽象中介类\",{\"1\":{\"186\":1}}],[\"抽象\",{\"1\":{\"183\":1}}],[\"抽象出一个迭代器类来负责\",{\"1\":{\"181\":1}}],[\"抽象状态类\",{\"1\":{\"177\":1}}],[\"抽象产品\",{\"1\":{\"176\":1}}],[\"抽象工厂\",{\"1\":{\"190\":1}}],[\"抽象工厂接口\",{\"1\":{\"176\":1}}],[\"抽象工厂模式\",{\"0\":{\"176\":1}}],[\"抽象观察者\",{\"1\":{\"175\":1}}],[\"抽象主题提供一个接口\",{\"1\":{\"175\":1}}],[\"抽象不应该依赖细节\",{\"1\":{\"162\":1}}],[\"抽象模型\",{\"1\":{\"73\":1}}],[\"灵活性好\",{\"1\":{\"161\":1}}],[\"汉字的字符\",{\"1\":{\"158\":1}}],[\"$\",{\"1\":{\"158\":1}}],[\"匹配除了aeiou这几个字母以外的任意字符\",{\"1\":{\"158\":1}}],[\"匹配除了x以外的任意字符\",{\"1\":{\"158\":1}}],[\"匹配除换行符以外的任意字符\",{\"1\":{\"158\":1}}],[\"匹配不是单词开头或结束的位置\",{\"1\":{\"158\":1}}],[\"匹配任意非数字的字符\",{\"1\":{\"158\":1}}],[\"匹配任意不是空白符的字符\",{\"1\":{\"158\":1}}],[\"匹配任意不是字母\",{\"1\":{\"158\":1}}],[\"匹配任意的空白符\",{\"1\":{\"158\":1}}],[\"匹配字符串的结束\",{\"1\":{\"158\":1}}],[\"匹配字符串的开始\",{\"1\":{\"158\":1}}],[\"匹配字母或数字或下划线\",{\"1\":{\"158\":1}}],[\"匹配单词的开始或结束\",{\"1\":{\"158\":1}}],[\"匹配数字\",{\"1\":{\"158\":1}}],[\"说明\",{\"1\":{\"158\":3}}],[\"换句话说\",{\"1\":{\"158\":1}}],[\"私钥\",{\"1\":{\"157\":1}}],[\"私有数据\",{\"1\":{\"126\":1}}],[\"公钥\",{\"1\":{\"157\":1}}],[\"生成的散列值也只存在细微的差别\",{\"1\":{\"157\":1}}],[\"生产message到topic\",{\"1\":{\"143\":1}}],[\"局部敏感的散列算法\",{\"1\":{\"157\":1}}],[\"算法\",{\"1\":{\"157\":1}}],[\"算法简介\",{\"0\":{\"146\":1}}],[\"安全代理\",{\"1\":{\"169\":1}}],[\"安全散列\",{\"1\":{\"157\":1}}],[\"安全的在\",{\"1\":{\"19\":1}}],[\"布隆过滤器和hyperloglog\",{\"1\":{\"157\":1}}],[\"布局包括\",{\"1\":{\"10\":1}}],[\"布局\",{\"0\":{\"10\":1},\"1\":{\"139\":1},\"2\":{\"12\":1}}],[\"布局与功能禁用\",{\"0\":{\"4\":1}}],[\"归并\",{\"1\":{\"157\":1}}],[\"映射\",{\"1\":{\"157\":1}}],[\"映射map\",{\"1\":{\"126\":1}}],[\"傅里叶变换\",{\"1\":{\"157\":1}}],[\"树\",{\"1\":{\"157\":1}}],[\"树形结构\",{\"1\":{\"98\":1}}],[\"预测股票市场\",{\"1\":{\"156\":1}}],[\"预留必须业务资源\",{\"1\":{\"63\":1}}],[\"预留业务资源\",{\"1\":{\"63\":1}}],[\"朴素贝叶斯分类器\",{\"1\":{\"156\":1}}],[\"垃圾邮件过滤器\",{\"1\":{\"156\":1}}],[\"光学字符识别\",{\"1\":{\"156\":1}}],[\"推荐系统\",{\"1\":{\"156\":1}}],[\"余弦相似度\",{\"1\":{\"156\":1}}],[\"余数>组合表示每一组id\",{\"1\":{\"134\":1}}],[\"费曼算法\",{\"1\":{\"155\":1}}],[\"费阻塞锁即没有获取到锁后\",{\"1\":{\"88\":1}}],[\"肯定是\",{\"1\":{\"154\":1}}],[\"涉及\",{\"1\":{\"154\":1}}],[\"涉及整套分布式事务系统的实现成本问题\",{\"1\":{\"61\":1}}],[\"近似计算集合中不同元素数\",{\"1\":{\"157\":1}}],[\"近似解与最优解的接近程度\",{\"1\":{\"153\":1}}],[\"近似算法\",{\"1\":{\"153\":1}}],[\"速度提升并非线性\",{\"1\":{\"157\":1}}],[\"速度会变得非常慢\",{\"1\":{\"154\":1}}],[\"速度\",{\"1\":{\"153\":1}}],[\"贪婪算法\",{\"0\":{\"153\":1}}],[\"福德算法\",{\"1\":{\"152\":1}}],[\"检查是否有前往它们的更短路径\",{\"1\":{\"152\":1}}],[\"检查是否符合条件\",{\"1\":{\"151\":1}}],[\"找出可在最短时间内到达的节点\",{\"1\":{\"152\":1}}],[\"找出总权重最小的路径\",{\"1\":{\"152\":1}}],[\"找到相应位置的message\",{\"1\":{\"143\":1}}],[\"狄克斯特拉算法\",{\"0\":{\"152\":1}}],[\"广度优先搜索的执行过程中\",{\"1\":{\"151\":1}}],[\"广度优先搜索\",{\"0\":{\"151\":1}}],[\"良好的散列函数\",{\"1\":{\"150\":1}}],[\"经常有查找符合某些复杂规则的字符串的需要\",{\"1\":{\"158\":1}}],[\"经验规则\",{\"1\":{\"150\":1}}],[\"经过refresh间隔将该时段的全部数据refresh成一个segment\",{\"1\":{\"135\":1}}],[\"较低的填装因子\",{\"1\":{\"150\":1}}],[\"较常见的做法是通过异步拷贝副本\",{\"1\":{\"69\":1}}],[\"称为dns解析\",{\"1\":{\"150\":1}}],[\"且链中的对象自己也并不知道链的结构\",{\"1\":{\"185\":1}}],[\"且难以解决\",{\"1\":{\"154\":2}}],[\"且要处理的数组是有序的\",{\"1\":{\"149\":1}}],[\"且顺序链接\",{\"1\":{\"103\":1}}],[\"快速查找的常量比合并查找小\",{\"1\":{\"149\":1}}],[\"快速排序不检查输入数组是否有序\",{\"1\":{\"149\":1}}],[\"快速排序\",{\"0\":{\"149\":1}}],[\"考虑使用循环\",{\"1\":{\"148\":1}}],[\"无界\",{\"1\":{\"197\":1}}],[\"无需知道decorator存在\",{\"1\":{\"168\":1}}],[\"无需自己跟踪\",{\"1\":{\"148\":1}}],[\"无法插入\",{\"1\":{\"120\":1}}],[\"无法进入队列重试\",{\"1\":{\"91\":1}}],[\"无法重试\",{\"1\":{\"73\":1}}],[\"函数等\",{\"1\":{\"161\":1}}],[\"函数调用自己\",{\"1\":{\"148\":1}}],[\"函数不再调用自己\",{\"1\":{\"148\":1}}],[\"程序可能更容易理解\",{\"1\":{\"148\":1}}],[\"程序的性能可能更高\",{\"1\":{\"148\":1}}],[\"程序运行时间\",{\"1\":{\"98\":1}}],[\"递归\",{\"0\":{\"148\":1}}],[\"地址\",{\"1\":{\"143\":1}}],[\"独立版本\",{\"1\":{\"143\":1}}],[\"元数据指向数据文件message物理偏移地址\",{\"1\":{\"143\":1}}],[\"元素较少时算法的运行速度非常快\",{\"1\":{\"154\":1}}],[\"元素个数小于128个\",{\"1\":{\"132\":1}}],[\"元素个数小于等于512个\",{\"1\":{\"131\":1}}],[\"元素个数超过数组大小\",{\"1\":{\"109\":1}}],[\"元素数量小于512\",{\"1\":{\"129\":1}}],[\"默认1g\",{\"1\":{\"143\":1}}],[\"默认每隔30分钟commit\",{\"1\":{\"137\":1}}],[\"集群负载均衡基本单位\",{\"1\":{\"143\":1}}],[\"集合对象\",{\"0\":{\"131\":1}}],[\"集合包含的元素数量\",{\"1\":{\"128\":1}}],[\"集合结构\",{\"1\":{\"98\":1}}],[\"仅在没有负权边时才成立\",{\"1\":{\"152\":1}}],[\"仅针对message没有key时\",{\"1\":{\"143\":1}}],[\"仅存储增量值\",{\"1\":{\"134\":1}}],[\"维护一个concretestate子类的实例\",{\"1\":{\"177\":1}}],[\"维护一个遗留的大型系统\",{\"1\":{\"173\":1}}],[\"维护一个下标文件offset\",{\"1\":{\"143\":1}}],[\"维护对strategy对象的引用\",{\"1\":{\"167\":1}}],[\"维持结构平衡成本比较低\",{\"1\":{\"105\":1}}],[\"消费一条\",{\"1\":{\"143\":1}}],[\"消费消息策略\",{\"1\":{\"143\":1}}],[\"消息id\",{\"1\":{\"143\":1}}],[\"消息被消费\",{\"1\":{\"143\":1}}],[\"消息存放的目录即主题\",{\"1\":{\"143\":1}}],[\"消息不丢包\",{\"1\":{\"80\":1}}],[\"消息无序等场景可能出现的情况下\",{\"1\":{\"80\":1}}],[\"消息无序或丢失\",{\"1\":{\"79\":1}}],[\"消息传递异步无序\",{\"1\":{\"76\":1}}],[\"消息投递失败后为什么不回滚消息\",{\"1\":{\"61\":1}}],[\"消息中间件提供失败消息的查询接口\",{\"1\":{\"62\":1}}],[\"消息中间件有重试机制\",{\"1\":{\"62\":1}}],[\"消息中间件向下游系统投递消息失败\",{\"1\":{\"62\":1}}],[\"消息中间件向下游系统投递完消息后进入阻塞等待状态\",{\"1\":{\"61\":1}}],[\"消息中间件将消息删除\",{\"1\":{\"62\":1}}],[\"消息中间件将消息投递给下游系统是同步\",{\"1\":{\"61\":1}}],[\"消息中间件是一个独立于业务的第三方中间件\",{\"1\":{\"61\":1}}],[\"消息中间件扮演分布式事务协调者的角色\",{\"1\":{\"61\":1}}],[\"消息中间件收到消息后将消息同步投递给下游系统\",{\"1\":{\"62\":1}}],[\"消息中间件收到确认应答后认为事务处理完毕\",{\"1\":{\"61\":1}}],[\"消息中间件收到回滚请求\",{\"1\":{\"61\":1}}],[\"消息中间件收到commit指令后\",{\"1\":{\"61\":1}}],[\"消息中间件收到后将该消息持久化\",{\"1\":{\"61\":1}}],[\"消息中间件持久化成功后\",{\"1\":{\"61\":1}}],[\"消息中间件\",{\"1\":{\"59\":1}}],[\"启动kafka的server\",{\"1\":{\"143\":1}}],[\"启动zookeeper的server\",{\"1\":{\"143\":1}}],[\"启用innodb\",{\"1\":{\"115\":1}}],[\"工厂方法\",{\"1\":{\"190\":1}}],[\"工厂方法克服简单工厂违背开放\",{\"1\":{\"170\":1}}],[\"工厂方法把简单工厂的内部逻辑判断移到客户端代码来进行\",{\"1\":{\"170\":1}}],[\"工厂方法使一个类的实例化延迟到其子类\",{\"1\":{\"170\":1}}],[\"工厂方法模式是简单工厂模式进一步抽象和推广\",{\"1\":{\"170\":1}}],[\"工厂方法模式\",{\"0\":{\"170\":1}}],[\"工作模式\",{\"1\":{\"143\":1}}],[\"工程实践中\",{\"1\":{\"69\":1}}],[\"设计初期\",{\"1\":{\"173\":1}}],[\"设为128mb\",{\"1\":{\"141\":1}}],[\"设置状态\",{\"1\":{\"196\":1}}],[\"设置为ht\",{\"1\":{\"126\":1}}],[\"设置监听\",{\"1\":{\"96\":1}}],[\"设置键key的过期时间\",{\"1\":{\"94\":1}}],[\"寻址时间增大\",{\"1\":{\"141\":1}}],[\"忽略跨级操作\",{\"1\":{\"140\":1}}],[\"忽略因素\",{\"1\":{\"98\":1}}],[\"视图渲染前\",{\"1\":{\"140\":1}}],[\"复用内部对象\",{\"1\":{\"139\":1}}],[\"复杂度o\",{\"1\":{\"139\":1}}],[\"丢弃旧fiber\",{\"1\":{\"139\":1}}],[\"丢失\",{\"1\":{\"76\":1}}],[\"变为具有链表和指针的异步模型\",{\"1\":{\"139\":1}}],[\"划分优先级\",{\"1\":{\"139\":1}}],[\"纤维\",{\"1\":{\"139\":1}}],[\"反向索引\",{\"1\":{\"157\":1}}],[\"反向遍历ziplist或者pop尾部节点的时候有用\",{\"1\":{\"124\":1}}],[\"反映要刷新到屏幕的未来状态\",{\"1\":{\"139\":1}}],[\"反之则不尽相同\",{\"1\":{\"139\":1}}],[\"拥有相同类型的两个组件产生的dom结构相似\",{\"1\":{\"139\":1}}],[\"渲染都会停止\",{\"1\":{\"139\":1}}],[\"修改期间\",{\"1\":{\"139\":1}}],[\"修改字符串时\",{\"1\":{\"123\":1}}],[\"传统diff算法复杂度o\",{\"1\":{\"138\":1}}],[\"真正的dom元素非常庞大\",{\"1\":{\"138\":1}}],[\"真正执行业务\",{\"1\":{\"63\":1}}],[\"产生的原因以及最大用途\",{\"1\":{\"138\":1}}],[\"产生新的term\",{\"1\":{\"82\":1}}],[\"然会把结果集中每个文档id和排序所需信息返回给协调节点\",{\"1\":{\"137\":1}}],[\"然后更新需要更新的视图\",{\"1\":{\"138\":1}}],[\"然后返回给客户端\",{\"1\":{\"137\":1}}],[\"然后根据唯一标识去各节点拉取数据\",{\"1\":{\"137\":1}}],[\"然后同步到replica\",{\"1\":{\"137\":1}}],[\"然后merge成更大的segment\",{\"1\":{\"135\":1}}],[\"然后用后台线程定期同步缓冲池到磁盘\",{\"1\":{\"117\":1}}],[\"然后获取比自己小的兄弟节点\",{\"1\":{\"96\":1}}],[\"若要求返回结果排序从from开始数量为size的结果集\",{\"1\":{\"137\":1}}],[\"搜索范围从起点开始逐渐向外延伸\",{\"1\":{\"151\":1}}],[\"搜索底层原理\",{\"1\":{\"137\":1}}],[\"搜索数据\",{\"1\":{\"137\":1}}],[\"排序\",{\"1\":{\"137\":1}}],[\"排他锁\",{\"1\":{\"119\":2}}],[\"唯一标识\",{\"1\":{\"137\":1}}],[\"唯一索引可以保证该记录只被插入一次\",{\"1\":{\"73\":1}}],[\"返回一个product类型的对象\",{\"1\":{\"170\":1}}],[\"返回给协调节点进行数据合并\",{\"1\":{\"137\":1}}],[\"返回document给coordinate\",{\"1\":{\"137\":1}}],[\"返回顶部按钮\",{\"1\":{\"4\":1,\"10\":1}}],[\"让类自身负责保存它的唯一实例\",{\"1\":{\"182\":1}}],[\"让具体的创建实例过程与客户端分离\",{\"1\":{\"176\":1}}],[\"让多个观察者对象同时监听某一个主题对象\",{\"1\":{\"175\":1}}],[\"让新系统与facade对象交互\",{\"1\":{\"173\":1}}],[\"让一个原型克隆自身\",{\"1\":{\"171\":1}}],[\"让子类决定实例化哪一个类\",{\"1\":{\"170\":1}}],[\"让它们之间可以互相替换\",{\"1\":{\"167\":1}}],[\"让读请求负载均衡\",{\"1\":{\"137\":1}}],[\"让xa应用场景变得非常狭隘\",{\"1\":{\"60\":1}}],[\"协调节点将所有结果汇总\",{\"1\":{\"137\":1}}],[\"协调节点在之后请求轮询所有分片拷贝\",{\"1\":{\"137\":1}}],[\"协调节点\",{\"1\":{\"137\":1}}],[\"倒排索引实现为fst\",{\"1\":{\"136\":1}}],[\"倒排索引文件\",{\"1\":{\"136\":1}}],[\"倒排索引的元数据信息\",{\"1\":{\"136\":1}}],[\"倒排索引\",{\"1\":{\"135\":1}}],[\"防止数据丢失\",{\"1\":{\"135\":1}}],[\"防止participant宕机后整个系统进入阻塞态\",{\"1\":{\"78\":1}}],[\"联合索引\",{\"1\":{\"134\":1}}],[\"头部存储bits\",{\"1\":{\"134\":1}}],[\"按bit排队\",{\"1\":{\"134\":1}}],[\"按分值从小到大排列\",{\"1\":{\"132\":1}}],[\"增量编码压缩\",{\"1\":{\"134\":1}}],[\"增加新的操作很容易\",{\"1\":{\"189\":1}}],[\"增加外观facade提供一个简单的接口\",{\"1\":{\"173\":1}}],[\"增加了额外的开发量\",{\"1\":{\"170\":1}}],[\"增加了内存开销\",{\"1\":{\"101\":1}}],[\"增加分区时\",{\"1\":{\"143\":1}}],[\"增加业务系统开发成本\",{\"1\":{\"62\":1}}],[\"增加额外的开发成本\",{\"1\":{\"61\":1}}],[\"压缩\",{\"1\":{\"134\":1}}],[\"压缩存储空间\",{\"1\":{\"134\":1}}],[\"压缩内存使用空间\",{\"1\":{\"134\":1}}],[\"压缩列表\",{\"0\":{\"124\":1},\"1\":{\"122\":1}}],[\"键值对数量小于512个\",{\"1\":{\"130\":1}}],[\"总是向表尾添加\",{\"1\":{\"130\":1}}],[\"节省内存分配和gc时间开销\",{\"1\":{\"139\":1}}],[\"节约内存\",{\"1\":{\"128\":1}}],[\"节点所有邻居\",{\"1\":{\"152\":1}}],[\"节点object属性保存元素成员\",{\"1\":{\"132\":1}}],[\"节点的值\",{\"1\":{\"125\":1}}],[\"节点值对比函数\",{\"1\":{\"125\":1}}],[\"节点值释放函数\",{\"1\":{\"125\":1}}],[\"节点值复制函数\",{\"1\":{\"125\":1}}],[\"节点\",{\"1\":{\"124\":1}}],[\"节点创建后\",{\"1\":{\"96\":1}}],[\"节点0\",{\"1\":{\"87\":2}}],[\"节点运行相同状态机\",{\"1\":{\"82\":1}}],[\"节点或宕机或逻辑失败\",{\"1\":{\"76\":1}}],[\"节点持续宕机\",{\"1\":{\"76\":1}}],[\"节点宕机恢复\",{\"1\":{\"76\":1}}],[\"节点宕机\",{\"1\":{\"76\":1}}],[\"节点间消息传递做不到同步有序\",{\"1\":{\"76\":1}}],[\"节点类型\",{\"1\":{\"73\":1}}],[\"节点a更新一个数据后\",{\"1\":{\"71\":1}}],[\"节点之间可能会失去联系\",{\"1\":{\"67\":1}}],[\"节点故障则是分布式环境下另一个比较常见的问题\",{\"1\":{\"65\":1}}],[\"节点故障\",{\"1\":{\"65\":1}}],[\"升级操作\",{\"1\":{\"128\":1}}],[\"成为fiber\",{\"1\":{\"139\":1}}],[\"成为leader\",{\"1\":{\"87\":1}}],[\"成员对象\",{\"1\":{\"127\":1}}],[\"跨度\",{\"1\":{\"127\":1}}],[\"前进指针\",{\"1\":{\"127\":1}}],[\"前置节点\",{\"1\":{\"125\":1}}],[\"层与层之间建立外观facade\",{\"1\":{\"173\":1}}],[\"层次遍历\",{\"1\":{\"139\":1}}],[\"层\",{\"1\":{\"127\":1}}],[\"形成链表\",{\"1\":{\"126\":1}}],[\"形成活锁\",{\"1\":{\"80\":1}}],[\"已有节点数量\",{\"1\":{\"126\":1}}],[\"已经证明在一个收窄的模型中\",{\"1\":{\"76\":1}}],[\"添加操作一律添加到ht\",{\"1\":{\"126\":1}}],[\"期间\",{\"1\":{\"126\":1}}],[\"迁移完成rehashidx设为\",{\"1\":{\"126\":1}}],[\"迁移完成后\",{\"1\":{\"126\":1}}],[\"放到ht\",{\"1\":{\"126\":1}}],[\"放宽对时间的要求\",{\"1\":{\"69\":1}}],[\"哈希对象\",{\"0\":{\"130\":1}}],[\"哈希值\",{\"1\":{\"126\":1}}],[\"哈希表大小掩码\",{\"1\":{\"126\":1}}],[\"哈希表大小\",{\"1\":{\"126\":1}}],[\"哈希表数组\",{\"1\":{\"126\":1}}],[\"哈希表\",{\"0\":{\"104\":1,\"115\":1},\"1\":{\"126\":1}}],[\"关注空闲连接\",{\"1\":{\"194\":1}}],[\"关注的对象从对象各自本身的行为转移到它们之间的交互来\",{\"1\":{\"186\":1}}],[\"关闭原则\",{\"0\":{\"161\":1}}],[\"关联数组associative\",{\"1\":{\"126\":1}}],[\"关于p的理解\",{\"0\":{\"68\":1}}],[\"关于这些扩展\",{\"1\":{\"17\":1}}],[\"值\",{\"1\":{\"126\":1}}],[\"值为0xff\",{\"1\":{\"124\":1}}],[\"值合法\",{\"1\":{\"76\":1}}],[\"个元素\",{\"1\":{\"149\":1}}],[\"个数\",{\"1\":{\"124\":1}}],[\"个节点同时认为自己是唯一处于活动状态的服务器从而出现争用资源的情况\",{\"1\":{\"76\":1}}],[\"连锁更新\",{\"1\":{\"124\":1}}],[\"平均情况和最糟情况\",{\"1\":{\"149\":1}}],[\"平均时间复杂度o\",{\"1\":{\"124\":1}}],[\"平衡调整成本更高\",{\"1\":{\"103\":1}}],[\"平衡二叉树\",{\"1\":{\"103\":1}}],[\"减少它们之间的耦合\",{\"1\":{\"183\":1}}],[\"减少它们之间的依赖\",{\"1\":{\"173\":1}}],[\"减少各种算法类与使用算法类之间的耦合\",{\"1\":{\"167\":1}}],[\"减少磁盘随机读次数\",{\"1\":{\"134\":1}}],[\"减少磁盘随机读取次数\",{\"1\":{\"134\":1}}],[\"减少内存碎片\",{\"1\":{\"124\":1}}],[\"减少hash冲突\",{\"1\":{\"109\":1}}],[\"容易地改变和扩展文法\",{\"1\":{\"188\":1}}],[\"容易将命令记录日志\",{\"1\":{\"184\":1}}],[\"容易加载到cpu缓存\",{\"1\":{\"124\":1}}],[\"容易导致出现双主\",{\"1\":{\"87\":1}}],[\"杜绝缓冲区溢出\",{\"1\":{\"123\":1}}],[\"整体\",{\"1\":{\"180\":1}}],[\"整个commit过程叫做一个flush操作\",{\"1\":{\"137\":1}}],[\"整个系统处于数据不一致的状态\",{\"1\":{\"61\":1}}],[\"整数集合\",{\"0\":{\"128\":1},\"1\":{\"122\":1}}],[\"字段内容是一个term\",{\"1\":{\"135\":1}}],[\"字节\",{\"1\":{\"124\":1}}],[\"字符串保存小于等于32字节字符串\",{\"1\":{\"123\":1}}],[\"字符串保存大于32字节字符串\",{\"1\":{\"123\":1}}],[\"字符串对象\",{\"1\":{\"123\":1}}],[\"字典查询分值复杂度o\",{\"1\":{\"132\":1}}],[\"字典键保存元素成员\",{\"1\":{\"132\":1}}],[\"字典每个键值对保存集合元素\",{\"1\":{\"132\":1}}],[\"字典每个键都是字符串对象\",{\"1\":{\"131\":1}}],[\"字典值保存分值\",{\"1\":{\"132\":1}}],[\"字典值保存value\",{\"1\":{\"130\":1}}],[\"字典值都是null\",{\"1\":{\"131\":1}}],[\"字典的键保存key\",{\"1\":{\"130\":1}}],[\"字典的键值都是字符串对象\",{\"1\":{\"130\":1}}],[\"字典实现\",{\"1\":{\"130\":1}}],[\"字典内部hashtable\",{\"1\":{\"126\":1}}],[\"字典\",{\"0\":{\"126\":1},\"1\":{\"122\":1,\"126\":1}}],[\"字母b表示一轮决议\",{\"1\":{\"80\":1}}],[\"编码方式\",{\"1\":{\"128\":1}}],[\"编码\",{\"1\":{\"122\":1}}],[\"编辑此页链接\",{\"1\":{\"4\":1}}],[\"准备插入该记录\",{\"1\":{\"120\":1}}],[\"准隔离性\",{\"1\":{\"63\":1}}],[\"行为型模式\",{\"0\":{\"192\":1}}],[\"行删除版本未定义或大于当前事务版本号\",{\"1\":{\"120\":1}}],[\"行锁实现方式\",{\"1\":{\"119\":1}}],[\"幻读\",{\"1\":{\"120\":1}}],[\"未提交事务的数据也会被读取到\",{\"1\":{\"120\":1}}],[\"过期时间\",{\"1\":{\"120\":1}}],[\"过程同理\",{\"1\":{\"78\":1}}],[\"造成多次读取结果不一样\",{\"1\":{\"120\":1}}],[\"造成不可重复读\",{\"1\":{\"120\":1}}],[\"造成脏读\",{\"1\":{\"120\":1}}],[\"造成锁等待\",{\"1\":{\"119\":1}}],[\"造成负载不均衡\",{\"1\":{\"75\":1}}],[\"范围内不存在的记录也会加锁\",{\"1\":{\"119\":1}}],[\"范围检索数据时\",{\"1\":{\"119\":1}}],[\"间隙锁\",{\"1\":{\"119\":1}}],[\"意向排他锁\",{\"1\":{\"119\":1}}],[\"意向共享锁\",{\"1\":{\"119\":1}}],[\"意向锁\",{\"1\":{\"119\":1}}],[\"影响并发效率\",{\"1\":{\"119\":1}}],[\"影响因素\",{\"1\":{\"104\":1}}],[\"阻塞队列\",{\"1\":{\"197\":1}}],[\"阻塞范围键值并发插入\",{\"1\":{\"119\":1}}],[\"阻塞锁即没有获取到锁\",{\"1\":{\"88\":1}}],[\"阻塞锁和非阻塞锁\",{\"1\":{\"88\":1}}],[\"阻塞锁通常使用互斥量来实现\",{\"1\":{\"73\":1}}],[\"阻止其他事务取得相同数据集的读写锁\",{\"1\":{\"119\":1}}],[\"阻止其他事务获得相同数据集的排他锁\",{\"1\":{\"119\":1}}],[\"允许接收请求一方决定是否要否决要求\",{\"1\":{\"184\":1}}],[\"允许客户访问它的唯一实例\",{\"1\":{\"182\":1}}],[\"允许它访问返回到先前状态所需的所有数据\",{\"1\":{\"179\":1}}],[\"允许获得排他锁的事务更新数据\",{\"1\":{\"119\":1}}],[\"允许事务读一行\",{\"1\":{\"119\":1}}],[\"允许系统中的数据存在中间状态\",{\"1\":{\"70\":1}}],[\"共享锁\",{\"1\":{\"119\":1}}],[\"共进退\",{\"1\":{\"76\":1}}],[\"缓冲池\",{\"1\":{\"117\":1}}],[\"缓存同步是以数据页为单位\",{\"1\":{\"117\":1}}],[\"缓存同步随机操作\",{\"1\":{\"117\":1}}],[\"缓存数组\",{\"1\":{\"107\":1}}],[\"缓存锁\",{\"0\":{\"93\":1},\"1\":{\"97\":1}}],[\"缓存等\",{\"1\":{\"59\":1}}],[\"保持了封装对象创建过程的优点\",{\"1\":{\"170\":1}}],[\"保存一个引用使得代理可以访问实体\",{\"1\":{\"169\":1}}],[\"保存索引字段的矢量信息\",{\"1\":{\"136\":1}}],[\"保存了term在doc中的一些高级特性\",{\"1\":{\"136\":1}}],[\"保存了term在doc中的位置\",{\"1\":{\"136\":1}}],[\"保存了每个term的doc\",{\"1\":{\"136\":1}}],[\"保存了fields的相关信息\",{\"1\":{\"136\":1}}],[\"保存集合元素\",{\"1\":{\"131\":1}}],[\"保存元素的数组\",{\"1\":{\"128\":1}}],[\"保存整数值\",{\"1\":{\"123\":1}}],[\"保存行的创建时间\",{\"1\":{\"120\":1}}],[\"保障未提交事务的原子性\",{\"1\":{\"118\":1}}],[\"保障mysql宕机时已提交事务的持久化\",{\"1\":{\"117\":1}}],[\"保证一个类仅有一个实例\",{\"1\":{\"182\":1}}],[\"保证时序\",{\"1\":{\"82\":1}}],[\"保证同一ip客户端都会被hash到同一台服务器上\",{\"1\":{\"75\":1}}],[\"保证在发生单点故障时仍然可用\",{\"1\":{\"73\":1}}],[\"保证ca\",{\"1\":{\"67\":1}}],[\"正则表达式就是记录文本规则的代码\",{\"1\":{\"158\":1}}],[\"正则表达式就是用于描述这些规则的工具\",{\"1\":{\"158\":1}}],[\"正则表达式\",{\"0\":{\"158\":1}}],[\"正排存储文件的元数据信息\",{\"1\":{\"136\":1}}],[\"正排数据\",{\"1\":{\"135\":1}}],[\"正在执行的dml及ddl语句\",{\"1\":{\"115\":1}}],[\"正常情况下zab处在broadcast阶段\",{\"1\":{\"83\":1}}],[\"正常情况下leader\",{\"1\":{\"82\":1}}],[\"新创建店铺\",{\"1\":{\"194\":1}}],[\"新创建表的数和索引将存储在单独的\",{\"1\":{\"115\":1}}],[\"新增的角色叫协调者备份\",{\"1\":{\"77\":1}}],[\"列存\",{\"1\":{\"136\":1}}],[\"列式存储的名称\",{\"1\":{\"135\":1}}],[\"列表对象\",{\"0\":{\"129\":1}}],[\"列\",{\"1\":{\"115\":1}}],[\"表示一个作用于某对象结构中的各元素的操作\",{\"1\":{\"189\":1}}],[\"表中层数最大的节点的层数\",{\"1\":{\"127\":1}}],[\"表中节点的数量\",{\"1\":{\"127\":1}}],[\"表尾节点\",{\"1\":{\"125\":1}}],[\"表头节点和表尾节点\",{\"1\":{\"127\":1}}],[\"表头节点\",{\"1\":{\"125\":1}}],[\"表锁\",{\"1\":{\"119\":1}}],[\"表\",{\"1\":{\"115\":1}}],[\"占用空间较大\",{\"1\":{\"114\":1}}],[\"占用业务系统硬件资源\",{\"1\":{\"62\":1}}],[\"支持前缀匹配\",{\"1\":{\"114\":1}}],[\"支持排序\",{\"1\":{\"114\":1}}],[\"支持范围查找\",{\"1\":{\"114\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"27\":1}}],[\"普通索引\",{\"1\":{\"114\":1}}],[\"隐式生成一个主键\",{\"1\":{\"114\":1}}],[\"索引最小单位\",{\"1\":{\"135\":1}}],[\"索引结构\",{\"0\":{\"134\":1}}],[\"索引列\",{\"1\":{\"115\":1}}],[\"索引\",{\"1\":{\"115\":1,\"136\":1}}],[\"索引和行数据在一起存储\",{\"1\":{\"114\":1}}],[\"索引实现\",{\"0\":{\"113\":1}}],[\"开发阶段\",{\"1\":{\"173\":1}}],[\"开发成本高\",{\"1\":{\"63\":1}}],[\"开放\",{\"0\":{\"161\":1}}],[\"开销\",{\"1\":{\"152\":1}}],[\"开销大\",{\"1\":{\"111\":1}}],[\"采用双缓存的策略\",{\"1\":{\"139\":1}}],[\"采用bit\",{\"1\":{\"134\":1}}],[\"采用两种结构但是集合元素成员和分值是共享的\",{\"1\":{\"132\":1}}],[\"采用空间预分配和惰性释放空间\",{\"1\":{\"123\":1}}],[\"采用顺序循环写入\",{\"1\":{\"115\":1}}],[\"采用版本号解决\",{\"1\":{\"111\":1}}],[\"采用乐观锁增加版本号\",{\"0\":{\"92\":1}}],[\"禁止该指令与前后读写指令重排序\",{\"1\":{\"111\":1}}],[\"禁用\",{\"2\":{\"6\":1}}],[\"禁用了如下功能\",{\"1\":{\"4\":1}}],[\"改\",{\"1\":{\"111\":1}}],[\"jcrontab\",{\"1\":{\"198\":1}}],[\"juejin\",{\"1\":{\"193\":1}}],[\"just\",{\"1\":{\"111\":1}}],[\"js\",{\"1\":{\"139\":1,\"140\":2}}],[\"jvm会根据处理器类型\",{\"1\":{\"111\":1}}],[\"java\",{\"0\":{\"106\":1}}],[\"yield\",{\"1\":{\"111\":1}}],[\"your\",{\"1\":{\"71\":1}}],[\"初始化table\",{\"1\":{\"111\":1}}],[\"||\",{\"1\":{\"111\":4}}],[\"|=\",{\"1\":{\"109\":5}}],[\"koala\",{\"1\":{\"198\":1}}],[\"knn\",{\"0\":{\"156\":1}}],[\"k最近邻算法\",{\"0\":{\"156\":1}}],[\"kafka服务程序协议版本号\",{\"1\":{\"143\":1}}],[\"kafka节点\",{\"1\":{\"143\":1}}],[\"kafka\",{\"0\":{\"143\":1},\"1\":{\"198\":1}}],[\"k\",{\"0\":{\"156\":1},\"1\":{\"111\":2,\"143\":2}}],[\"key字段不填\",{\"1\":{\"143\":1}}],[\"key为\",{\"1\":{\"143\":1}}],[\"key的长度\",{\"1\":{\"143\":1}}],[\"key查看\",{\"1\":{\"122\":1}}],[\"key\",{\"1\":{\"109\":4,\"111\":4,\"125\":1,\"126\":2,\"130\":1,\"143\":3}}],[\"写入数据底层原理\",{\"1\":{\"137\":1}}],[\"写入数据\",{\"1\":{\"137\":1}}],[\"写入的原文存储在这\",{\"1\":{\"136\":1}}],[\"写入的数据先写在内存中\",{\"1\":{\"135\":1}}],[\"写锁\",{\"1\":{\"120\":2}}],[\"写数据会先写入缓冲池\",{\"1\":{\"117\":1}}],[\"写操作原子执行\",{\"1\":{\"111\":1}}],[\"写时复制\",{\"1\":{\"110\":1}}],[\"写作日期为\",{\"1\":{\"33\":1}}],[\"graph\",{\"1\":{\"152\":2}}],[\"group\",{\"1\":{\"143\":1}}],[\"group控制\",{\"1\":{\"115\":1}}],[\"grow\",{\"1\":{\"107\":1}}],[\"global\",{\"1\":{\"115\":2}}],[\"getdelay方法返回该元素距离失效剩余时间\",{\"1\":{\"197\":1}}],[\"getdeclaredfield\",{\"1\":{\"111\":1}}],[\"getinstance是一个静态方法\",{\"1\":{\"182\":1}}],[\"getobjectvolatile\",{\"1\":{\"111\":1}}],[\"getarray\",{\"1\":{\"110\":1}}],[\"^aeiou\",{\"1\":{\"158\":1}}],[\"^x\",{\"1\":{\"158\":1}}],[\"^\",{\"1\":{\"109\":1,\"158\":1}}],[\"转为链表\",{\"1\":{\"109\":1}}],[\"转为树\",{\"1\":{\"109\":2}}],[\"ui跨级移动操作非常少\",{\"1\":{\"139\":1}}],[\"uint32\",{\"1\":{\"128\":2}}],[\"uint64\",{\"1\":{\"126\":1}}],[\"u64\",{\"1\":{\"126\":1}}],[\"update\",{\"1\":{\"119\":1,\"120\":1}}],[\"u\",{\"1\":{\"111\":7}}],[\"union\",{\"1\":{\"126\":1}}],[\"unsharedconcreteflyweight\",{\"1\":{\"187\":1}}],[\"unsigned\",{\"1\":{\"122\":2,\"125\":1,\"126\":3,\"127\":2}}],[\"unsafe\",{\"1\":{\"111\":1}}],[\"uncommitted\",{\"1\":{\"120\":1}}],[\"unchecked\",{\"1\":{\"111\":1}}],[\"undo\",{\"0\":{\"116\":1,\"118\":1},\"1\":{\"115\":1,\"120\":1}}],[\"unlock\",{\"1\":{\"110\":1}}],[\"untreeify\",{\"1\":{\"109\":1}}],[\"user\",{\"1\":{\"136\":1}}],[\"used\",{\"1\":{\"126\":1}}],[\"using\",{\"1\":{\"109\":1}}],[\"usually\",{\"1\":{\"107\":1}}],[\"8\",{\"1\":{\"109\":2,\"120\":1,\"143\":1}}],[\"数字\",{\"1\":{\"158\":1}}],[\"数字最大为64位long\",{\"1\":{\"143\":1}}],[\"数\",{\"1\":{\"151\":1}}],[\"数组初始化或扩容\",{\"1\":{\"111\":1}}],[\"数组最小容量\",{\"1\":{\"109\":1}}],[\"数组长度是2的n次幂\",{\"1\":{\"109\":1}}],[\"数组+链表+红黑树\",{\"0\":{\"109\":1}}],[\"数据量过大时会消耗太多的io资源\",{\"1\":{\"196\":1}}],[\"数据继续写入才会参与load\",{\"1\":{\"143\":1}}],[\"数据持久化在hdfs\",{\"1\":{\"141\":1}}],[\"数据变化后生成的vnode与前一次缓存的vnode比较\",{\"1\":{\"140\":1}}],[\"数据变更操作都生成一条undo\",{\"1\":{\"118\":1}}],[\"数据发生变化视图就要随之更新\",{\"1\":{\"138\":1}}],[\"数据驱动视图\",{\"1\":{\"138\":1}}],[\"数据就可以被搜索到\",{\"1\":{\"137\":1}}],[\"数据空间\",{\"1\":{\"123\":1}}],[\"数据结构与算法\",{\"0\":{\"241\":1}}],[\"数据结构\",{\"0\":{\"98\":1}}],[\"数据模型\",{\"1\":{\"96\":1}}],[\"数据复制方案设计等因素\",{\"1\":{\"70\":1}}],[\"数据在时间\",{\"1\":{\"69\":1}}],[\"数据在多个副本之间能够保持一致的特性\",{\"1\":{\"66\":1}}],[\"数据库等\",{\"0\":{\"196\":1}}],[\"数据库锁\",{\"0\":{\"90\":1},\"1\":{\"97\":1}}],[\"数据库唯一索引\",{\"1\":{\"73\":1}}],[\"数据库即为分布式事务中的资源管理器\",{\"1\":{\"59\":1}}],[\"数据库\",{\"1\":{\"59\":1}}],[\"结果是职责链可简化对象的相互连接\",{\"1\":{\"185\":1}}],[\"结果由term组成\",{\"1\":{\"135\":1}}],[\"结果都不能获取到锁\",{\"1\":{\"95\":1}}],[\"结合fst\",{\"1\":{\"134\":1}}],[\"结构型模式\",{\"0\":{\"191\":1}}],[\"结构紧凑\",{\"1\":{\"124\":1}}],[\"结构\",{\"0\":{\"122\":1}}],[\"结点保存前驱和后继的引用\",{\"1\":{\"108\":1}}],[\"循环反复\",{\"1\":{\"151\":1}}],[\"循环时间长\",{\"1\":{\"111\":1}}],[\"循环双向链表\",{\"0\":{\"108\":1}}],[\"循环顺序队列\",{\"1\":{\"102\":1}}],[\">=\",{\"1\":{\"109\":3}}],[\">\",{\"1\":{\"107\":1,\"109\":3,\"111\":2}}],[\">>>\",{\"1\":{\"109\":6,\"111\":1}}],[\">>\",{\"1\":{\"107\":1}}],[\"00000006\",{\"1\":{\"109\":1}}],[\"0000000001\",{\"1\":{\"73\":1}}],[\"0000000000\",{\"1\":{\"73\":1}}],[\"0\",{\"1\":{\"107\":2,\"109\":7,\"111\":7,\"120\":1,\"123\":1,\"126\":4}}],[\"<k\",{\"1\":{\"111\":2}}],[\"<<\",{\"1\":{\"109\":3,\"111\":2}}],[\"<\",{\"1\":{\"107\":1,\"109\":2,\"111\":1}}],[\"类之间的耦合越弱\",{\"1\":{\"164\":1}}],[\"类\",{\"1\":{\"161\":1}}],[\"类似哈希对象\",{\"1\":{\"132\":1}}],[\"类似raft的term\",{\"1\":{\"83\":1}}],[\"类型为long型数字\",{\"1\":{\"143\":1}}],[\"类型特定函数\",{\"1\":{\"126\":1}}],[\"类型\",{\"1\":{\"122\":1,\"136\":1}}],[\"类内部使用默认缺省时对象数组的容量大小\",{\"1\":{\"107\":1}}],[\"底层基于数组\",{\"0\":{\"107\":1}}],[\"底层基于链表实现\",{\"1\":{\"105\":1}}],[\"含有多层\",{\"1\":{\"105\":1}}],[\"跳跃表有序\",{\"1\":{\"132\":1}}],[\"跳跃表节点保存集合元素\",{\"1\":{\"132\":1}}],[\"跳跃表和字典\",{\"1\":{\"122\":1}}],[\"跳跃表\",{\"0\":{\"105\":1,\"127\":1},\"1\":{\"134\":1}}],[\"处理超时未响应的请求\",{\"1\":{\"194\":1}}],[\"处理它所负责的请求\",{\"1\":{\"185\":1}}],[\"处理facade对象指派的任务\",{\"1\":{\"173\":1}}],[\"处理冲突的方法\",{\"1\":{\"104\":1}}],[\"处理时间过长导致锁超时\",{\"1\":{\"97\":1}}],[\"散列函数\",{\"1\":{\"109\":1}}],[\"散列函数是否均匀\",{\"1\":{\"104\":1}}],[\"散列分布均匀\",{\"1\":{\"109\":1}}],[\"散列表的装填因子\",{\"1\":{\"104\":1}}],[\"散列表\",{\"0\":{\"104\":1,\"150\":1}}],[\"任何类都可能作为一个接收者\",{\"1\":{\"184\":1}}],[\"任一节点到叶子节点所有路径上黑色节点数量相同\",{\"1\":{\"103\":1}}],[\"任务超时处理\",{\"1\":{\"194\":1}}],[\"任务处理完成后向消息中间件返回应答\",{\"1\":{\"61\":1}}],[\"任务b执行完成后\",{\"1\":{\"61\":1}}],[\"任务a处理完成后\",{\"1\":{\"61\":1}}],[\"任务列表\",{\"0\":{\"26\":1}}],[\"根结点为黑色\",{\"1\":{\"103\":1}}],[\"根据客户端的选择条件动态实例化相关类\",{\"1\":{\"170\":1}}],[\"根据需要创建开销很大的对象\",{\"1\":{\"169\":1}}],[\"根据序列对应的地址\",{\"1\":{\"143\":1}}],[\"根据offset二分查找文件列表\",{\"1\":{\"143\":1}}],[\"根据borker设置\",{\"1\":{\"143\":1}}],[\"根据该指针从表文件查询数据\",{\"1\":{\"114\":1}}],[\"根据版本号来判断更新之前有没有其他线程更新过\",{\"1\":{\"92\":1}}],[\"根据业务实际读写比例调整写副本数vw\",{\"1\":{\"86\":1}}],[\"根据follower的反馈pl产生newepoch\",{\"1\":{\"83\":1}}],[\"根据服务器的性能为每台服务器分配权重\",{\"1\":{\"75\":1}}],[\"根据服务器的性能差异\",{\"1\":{\"75\":1}}],[\"降低客户程序与产品对象的耦合\",{\"1\":{\"170\":1}}],[\"降低碰撞几率\",{\"1\":{\"109\":1}}],[\"降低磁盘io\",{\"1\":{\"103\":1}}],[\"降低冲突时间\",{\"1\":{\"95\":1}}],[\"查询请求可被主分片或副分片处理\",{\"1\":{\"137\":1}}],[\"查询时会遍历每个segment\",{\"1\":{\"135\":1}}],[\"查询速度快o\",{\"1\":{\"134\":1}}],[\"查询记录是否存在\",{\"1\":{\"120\":1}}],[\"查询原理类似二分查找\",{\"1\":{\"105\":1}}],[\"查找message步骤\",{\"1\":{\"143\":1}}],[\"查找先找ht\",{\"1\":{\"126\":1}}],[\"查找速度最快o\",{\"1\":{\"115\":1}}],[\"查找性能o\",{\"1\":{\"109\":1}}],[\"查找时间复杂度o\",{\"1\":{\"104\":1}}],[\"查找效率\",{\"1\":{\"103\":1}}],[\"查找\",{\"1\":{\"103\":1,\"105\":1}}],[\"查看详情\",{\"1\":{\"19\":1,\"20\":1,\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1}}],[\"左右子树高度差至多等于1\",{\"1\":{\"103\":1}}],[\"事先申请空间\",{\"1\":{\"102\":1}}],[\"事务中会读取到其他事务新提交的数据\",{\"1\":{\"120\":1}}],[\"事务打算给数据行加共享\",{\"1\":{\"119\":1}}],[\"事务回滚就是根据回滚日志做逆向操作\",{\"1\":{\"118\":1}}],[\"事务实现\",{\"0\":{\"116\":1}}],[\"事务日志\",{\"1\":{\"115\":1}}],[\"事务\",{\"1\":{\"77\":1}}],[\"事务消息中间件\",{\"0\":{\"61\":1}}],[\"事务管理器作为全局的调度者\",{\"1\":{\"60\":1}}],[\"事务管理器还管理着所有的资源管理器\",{\"1\":{\"59\":1}}],[\"队列\",{\"0\":{\"102\":1}}],[\"时间轮\",{\"1\":{\"198\":1}}],[\"时间复杂度o\",{\"1\":{\"101\":2,\"102\":2,\"151\":1}}],[\"时序上都有要求\",{\"1\":{\"69\":1}}],[\"限定仅在表尾进行插入和删除操作的线性结构\",{\"0\":{\"101\":1}}],[\"栈长为o\",{\"1\":{\"149\":1}}],[\"栈包含未完成的函数调用\",{\"1\":{\"148\":1}}],[\"栈\",{\"0\":{\"101\":1}}],[\"栈与队列\",{\"0\":{\"100\":1}}],[\"存放实例化需要很长时间的真实对象\",{\"1\":{\"169\":1}}],[\"存储父节点\",{\"1\":{\"152\":1}}],[\"存储了所有的倒排索引数据\",{\"1\":{\"136\":1}}],[\"存储了正排存储数据\",{\"1\":{\"136\":1}}],[\"存取数据时间复杂度o\",{\"1\":{\"99\":2}}],[\"存在aba问题\",{\"1\":{\"111\":1}}],[\"存在内存空间浪费\",{\"1\":{\"101\":1}}],[\"存在以下问题\",{\"1\":{\"91\":1}}],[\"存在消息延时\",{\"1\":{\"76\":1}}],[\"存在问题\",{\"1\":{\"73\":1}}],[\"存在特有的\",{\"1\":{\"65\":1}}],[\"硬件机器执行指令的速度\",{\"1\":{\"98\":1}}],[\"软件实体\",{\"1\":{\"161\":1}}],[\"软件编译产生的代码质量\",{\"1\":{\"98\":1}}],[\"软状态指的是\",{\"1\":{\"70\":1}}],[\"软状态\",{\"1\":{\"70\":2}}],[\"依赖倒转原则\",{\"0\":{\"162\":1}}],[\"依赖于算法好坏和问题输入规模\",{\"1\":{\"98\":1}}],[\"依次递增\",{\"1\":{\"83\":1}}],[\"链表所包含的节点数量\",{\"1\":{\"125\":1}}],[\"链表\",{\"0\":{\"125\":1}}],[\"链表或红黑树添加节点\",{\"1\":{\"111\":1}}],[\"链表与红黑树转换\",{\"1\":{\"109\":1}}],[\"链队列\",{\"1\":{\"102\":1}}],[\"链栈\",{\"1\":{\"101\":1}}],[\"链式存储\",{\"1\":{\"99\":1}}],[\"链式存储结构\",{\"1\":{\"98\":1}}],[\"链接\",{\"1\":{\"4\":1,\"19\":1}}],[\"顺序分发\",{\"1\":{\"143\":1}}],[\"顺序栈\",{\"1\":{\"101\":1}}],[\"顺序存储\",{\"1\":{\"99\":1}}],[\"顺序存储结构\",{\"1\":{\"98\":1}}],[\"顺序节点\",{\"1\":{\"96\":1}}],[\"物理结构\",{\"1\":{\"98\":1}}],[\"图形结构\",{\"1\":{\"98\":1}}],[\"图片引入\",{\"1\":{\"34\":1}}],[\"图片增强\",{\"0\":{\"27\":1}}],[\"线性规划\",{\"1\":{\"157\":1}}],[\"线性结构\",{\"0\":{\"99\":1},\"1\":{\"98\":1}}],[\"线程安全\",{\"0\":{\"110\":1,\"111\":1}}],[\"线程b监听到变更时间\",{\"1\":{\"96\":1}}],[\"线程b获取所有节点\",{\"1\":{\"96\":1}}],[\"线程a处理完\",{\"1\":{\"96\":1}}],[\"逻辑结构\",{\"1\":{\"98\":1}}],[\"研究非数值计算的程序设计问题中的操作对象\",{\"1\":{\"98\":1}}],[\"性能低\",{\"1\":{\"120\":1}}],[\"性能比不上缓存锁\",{\"1\":{\"97\":1}}],[\"性能高\",{\"1\":{\"97\":1,\"120\":1}}],[\"性能不理想\",{\"1\":{\"60\":1}}],[\"删除操作\",{\"1\":{\"137\":1}}],[\"删除自己的节点\",{\"1\":{\"96\":1}}],[\"删除所有实例的锁\",{\"1\":{\"95\":1}}],[\"比较容易实现文法\",{\"1\":{\"188\":1}}],[\"比较并交换操作数\",{\"1\":{\"111\":1}}],[\"比线程控制得更精密的并发处理机制\",{\"1\":{\"139\":1}}],[\"比自己次小的节点\",{\"1\":{\"96\":1}}],[\"比如正则表达式\",{\"1\":{\"188\":1}}],[\"比如增加add和删除remove\",{\"1\":{\"180\":1}}],[\"比如一个线程在执行一个带锁的方法\",{\"1\":{\"88\":1}}],[\"比如oracle\",{\"1\":{\"60\":1}}],[\"比如\",{\"1\":{\"59\":1}}],[\"希望用户可以忽略组合对象与单个对象的不同\",{\"1\":{\"180\":1}}],[\"希望获得锁的线程a在lock目录下\",{\"1\":{\"96\":1}}],[\"希腊字母β表示多轮决议的集合\",{\"1\":{\"80\":1}}],[\"监视器\",{\"1\":{\"96\":1}}],[\"监听器\",{\"1\":{\"73\":1}}],[\"内存空间占用低\",{\"1\":{\"136\":1}}],[\"内存占用少\",{\"1\":{\"124\":1}}],[\"内存占用大\",{\"1\":{\"110\":1}}],[\"内存分配只需一次\",{\"1\":{\"123\":1}}],[\"内存分配次数两次\",{\"1\":{\"123\":1}}],[\"内部是一个分层的文件系统目录树结构\",{\"1\":{\"96\":1}}],[\"内容\",{\"1\":{\"16\":1}}],[\"难度加大了\",{\"1\":{\"95\":1}}],[\"特别是第一次获取锁时\",{\"1\":{\"95\":1}}],[\"特别是在交易下单链路\",{\"1\":{\"60\":1}}],[\"能枚举它的元素\",{\"1\":{\"189\":1}}],[\"能较容易设计一个命令队列\",{\"1\":{\"184\":1}}],[\"能缩短响应时间\",{\"1\":{\"95\":1}}],[\"能够提供数据服务的对象都可以是资源管理器\",{\"1\":{\"59\":1}}],[\"必须考虑各种可能的情况\",{\"1\":{\"154\":1}}],[\"必须全值精确匹配\",{\"1\":{\"115\":1}}],[\"必须事先确定存储空间大小\",{\"1\":{\"101\":1}}],[\"必须部署5个节点才能让redlock的可靠性更强\",{\"1\":{\"95\":1}}],[\"必须有个时间期限\",{\"1\":{\"70\":1}}],[\"认为获得锁\",{\"1\":{\"95\":1}}],[\"二叉排序树\",{\"1\":{\"103\":1}}],[\"二叉树\",{\"0\":{\"103\":1}}],[\"二\",{\"0\":{\"93\":1}}],[\"完全依靠数据库唯一索引实现\",{\"1\":{\"91\":1}}],[\"完成一次视图更新\",{\"1\":{\"140\":1}}],[\"完成后rehashidx增加1\",{\"1\":{\"126\":1}}],[\"完成后删除对应的子节点\",{\"1\":{\"73\":1}}],[\"完成所有业务检查\",{\"1\":{\"63\":1}}],[\"执行调用的方法\",{\"1\":{\"88\":1}}],[\"执行业务代码\",{\"1\":{\"73\":1}}],[\"避免导致无限循环\",{\"1\":{\"151\":1}}],[\"避免冲突\",{\"1\":{\"150\":1}}],[\"避免形成无限循环\",{\"1\":{\"148\":1}}],[\"避免死锁\",{\"1\":{\"88\":1}}],[\"避免只使用心跳机制产生双主的问题\",{\"1\":{\"87\":1}}],[\"避免多leader的产生\",{\"1\":{\"86\":1}}],[\"后续为上一个最后一条消息的offset\",{\"1\":{\"143\":1}}],[\"后退指针\",{\"1\":{\"127\":1}}],[\"后置节点\",{\"1\":{\"125\":1}}],[\"后才重新发起选举\",{\"1\":{\"87\":1}}],[\"后台服务器数量变更都会影响hash结果\",{\"1\":{\"75\":1}}],[\"颁发租约给节点\",{\"1\":{\"87\":1}}],[\"例如先到先得\",{\"1\":{\"87\":1}}],[\"例如网络故障时只读不写\",{\"1\":{\"67\":1}}],[\"到期不管消息是否消费\",{\"1\":{\"143\":1}}],[\"到期后必须重新颁发租约\",{\"1\":{\"87\":1}}],[\"到任务b执行完成之间\",{\"1\":{\"61\":1}}],[\"原型\",{\"1\":{\"190\":1}}],[\"原型类\",{\"1\":{\"171\":1}}],[\"原型模式\",{\"0\":{\"171\":1}}],[\"原始数据\",{\"1\":{\"135\":1}}],[\"原来保存的是小类型\",{\"1\":{\"128\":1}}],[\"原有效时间减去获取锁消耗的时间\",{\"1\":{\"95\":1}}],[\"原理\",{\"1\":{\"87\":1}}],[\"原地址哈洗发\",{\"1\":{\"75\":1}}],[\"判断是否到结尾\",{\"1\":{\"181\":1}}],[\"判断是否获得锁必须是原子性的\",{\"1\":{\"88\":1}}],[\"判断是不是np完全问题\",{\"1\":{\"154\":1}}],[\"判断标准\",{\"1\":{\"153\":1}}],[\"判断自己是最小节点\",{\"1\":{\"96\":1}}],[\"判断自己不是最小节点\",{\"1\":{\"96\":1}}],[\"判断自己创建的子节点是否为当前子节点列表中序号最小的子节点\",{\"1\":{\"73\":1}}],[\"判别leader状态是否正常\",{\"1\":{\"87\":1}}],[\"管理者\",{\"1\":{\"179\":1}}],[\"管理\",{\"1\":{\"86\":1}}],[\"被提炼的抽象\",{\"1\":{\"183\":1}}],[\"被用于大海捞针式的查找\",{\"1\":{\"150\":1}}],[\"被分隔的节点都认为自己具有最大的序号\",{\"1\":{\"86\":1}}],[\"被调端允许部分节点不可用\",{\"1\":{\"69\":1}}],[\"被调端最终一致\",{\"1\":{\"69\":1}}],[\"被调多个节点的数据最终达成一致\",{\"1\":{\"69\":1}}],[\"序列\",{\"1\":{\"143\":1}}],[\"序列一致性\",{\"1\":{\"69\":1}}],[\"序号\",{\"1\":{\"143\":1}}],[\"序号最高的节点为leader\",{\"1\":{\"85\":1}}],[\"租约机制确保了一个时刻最多只有一个leader\",{\"1\":{\"87\":1}}],[\"租约过程\",{\"1\":{\"87\":1}}],[\"租约\",{\"0\":{\"87\":1},\"1\":{\"84\":1}}],[\"选择排序\",{\"0\":{\"147\":1}}],[\"选得的leader\",{\"1\":{\"84\":1}}],[\"选举\",{\"0\":{\"84\":1,\"85\":1},\"1\":{\"84\":1}}],[\"选举产生pl\",{\"1\":{\"83\":1}}],[\"适配器\",{\"1\":{\"191\":1}}],[\"适配器模式主要应用于希望复用一些现存的类\",{\"1\":{\"178\":1}}],[\"适配器模式\",{\"0\":{\"178\":1}}],[\"适用于数据结构比较稳定\",{\"1\":{\"189\":1}}],[\"适用于有强一致性需求的场景\",{\"1\":{\"83\":1}}],[\"适合写多读少的并发场景\",{\"1\":{\"110\":1}}],[\"适合频繁查找\",{\"1\":{\"103\":1}}],[\"适合频繁插入删除\",{\"1\":{\"99\":1,\"103\":1}}],[\"适合范围查找\",{\"1\":{\"103\":1}}],[\"适合数据存取\",{\"1\":{\"99\":1}}],[\"适合每个服务器的性能差不多的场景\",{\"1\":{\"75\":1}}],[\"quartz\",{\"1\":{\"198\":1}}],[\"quorum\",{\"0\":{\"86\":1},\"1\":{\"69\":1,\"80\":1,\"82\":1,\"84\":1,\"86\":1}}],[\"q\",{\"1\":{\"83\":2}}],[\"q广播\",{\"1\":{\"83\":2}}],[\"定时任务调度\",{\"1\":{\"194\":1}}],[\"定期轮询数据库\",{\"1\":{\"196\":1}}],[\"定期轮询\",{\"0\":{\"196\":1}}],[\"定期检查退款状态\",{\"1\":{\"194\":1}}],[\"定期校对\",{\"0\":{\"62\":1},\"1\":{\"62\":1}}],[\"定义它的文法的一种表示\",{\"1\":{\"188\":1}}],[\"定义同事对象到中介者对象的接口\",{\"1\":{\"186\":1}}],[\"定义有枝节点行为\",{\"1\":{\"180\":1}}],[\"定义了一种一对多的依赖关系\",{\"1\":{\"175\":1}}],[\"定义了算法家族\",{\"1\":{\"167\":1}}],[\"定义算法骨架\",{\"1\":{\"172\":1}}],[\"定义工厂方法所创建对象的接口\",{\"1\":{\"170\":1}}],[\"定义proxy所代表的真实实体\",{\"1\":{\"169\":1}}],[\"定义realsubject和proxy的共用接口\",{\"1\":{\"169\":1}}],[\"定义一个accept操作\",{\"1\":{\"189\":1}}],[\"定义一个处理请示的接口\",{\"1\":{\"185\":1}}],[\"定义一个getinstance操作\",{\"1\":{\"182\":1}}],[\"定义一个接口以封装与context的一个特定状态相关的行为\",{\"1\":{\"177\":1}}],[\"定义一个操作中的算法骨架\",{\"1\":{\"172\":1}}],[\"定义一个用于创建对象的接口\",{\"1\":{\"170\":1}}],[\"定义一个具体对象\",{\"1\":{\"168\":1}}],[\"定义一个对象接口\",{\"1\":{\"168\":1}}],[\"定义所有支持的算法的公共接口\",{\"1\":{\"167\":1}}],[\"定义z先于z\",{\"1\":{\"83\":1}}],[\"定位文件\",{\"1\":{\"143\":1}}],[\"出现leader宕机\",{\"1\":{\"83\":1}}],[\"之后各follower再补齐相比pl缺失的状态\",{\"1\":{\"83\":1}}],[\"zskiplistlevel\",{\"1\":{\"127\":1}}],[\"zskiplistnode\",{\"1\":{\"127\":4}}],[\"zskiplist\",{\"1\":{\"127\":2}}],[\"zset\",{\"1\":{\"122\":1,\"198\":1}}],[\"zlend\",{\"1\":{\"124\":1}}],[\"zllen\",{\"1\":{\"124\":1}}],[\"zltail\",{\"1\":{\"124\":1}}],[\"zlbytes\",{\"1\":{\"124\":1}}],[\"ziplist编码\",{\"1\":{\"129\":1,\"130\":1,\"132\":1}}],[\"ziplist的节点\",{\"1\":{\"124\":1}}],[\"ziplist的长度\",{\"1\":{\"124\":1}}],[\"ziplist最后一个节点的偏移量\",{\"1\":{\"124\":1}}],[\"ziplist\",{\"0\":{\"124\":1},\"1\":{\"122\":1}}],[\"zero\",{\"1\":{\"109\":1}}],[\"z根据一定的规则\",{\"1\":{\"87\":1}}],[\"z才能广播z\",{\"1\":{\"83\":1}}],[\"z由leader\",{\"1\":{\"83\":2}}],[\"z对应的事务\",{\"1\":{\"83\":2}}],[\"z<z\",{\"1\":{\"83\":1}}],[\"z\",{\"1\":{\"83\":5}}],[\"zookeeper保存consumer和producer信息\",{\"1\":{\"143\":1}}],[\"zookeeper锁\",{\"1\":{\"97\":1}}],[\"zookeeper将会向客户端发送且仅发送一条通知\",{\"1\":{\"96\":1}}],[\"zookeeper为分布式应用提供一致性服务\",{\"1\":{\"96\":1}}],[\"zookeeper分布式锁\",{\"0\":{\"96\":1}}],[\"zookeeper内部用到的一致性协议\",{\"1\":{\"83\":1}}],[\"zookeeper\",{\"0\":{\"83\":1},\"1\":{\"87\":1}}],[\"zookeeper的有序节点\",{\"1\":{\"73\":1}}],[\"zab约束了事务顺序\",{\"1\":{\"83\":1}}],[\"zab对follower\",{\"1\":{\"83\":1}}],[\"zab中每个事务对应一个zxid\",{\"1\":{\"83\":1}}],[\"zab称为primary\",{\"1\":{\"83\":1}}],[\"zab通过约束事务先后顺序达到强一致性\",{\"1\":{\"83\":1}}],[\"zab可以分解成discovery\",{\"1\":{\"83\":1}}],[\"zab要求唯一leader参与决议\",{\"1\":{\"83\":1}}],[\"zab最大特点是保证强一致性\",{\"1\":{\"83\":1}}],[\"zab\",{\"0\":{\"83\":1}}],[\"更适合处理不同用户评分方式的差异\",{\"1\":{\"156\":1}}],[\"更新其开销\",{\"1\":{\"152\":1}}],[\"更新视图时需要操作dom\",{\"1\":{\"138\":1}}],[\"更新操作\",{\"1\":{\"137\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"10\":1}}],[\"更新时间\",{\"1\":{\"4\":1}}],[\"更容易实现的目标\",{\"1\":{\"82\":1}}],[\"得到下一个对象\",{\"1\":{\"181\":1}}],[\"得到的结果与正确结果接近\",{\"1\":{\"153\":1}}],[\"得到的结果就是最后的交集\",{\"1\":{\"134\":1}}],[\"得到一致结果\",{\"1\":{\"82\":1}}],[\"得出相同结果\",{\"1\":{\"82\":1}}],[\"紧接着对follower发起appendentries请求\",{\"1\":{\"82\":1}}],[\"至操作日志\",{\"1\":{\"82\":1}}],[\"追加\",{\"1\":{\"82\":1}}],[\"具体元素\",{\"1\":{\"189\":1}}],[\"具体访问者\",{\"1\":{\"189\":1}}],[\"具体同事类\",{\"1\":{\"186\":1}}],[\"具体中介者对象\",{\"1\":{\"186\":1}}],[\"具体处理者类\",{\"1\":{\"185\":1}}],[\"具体实现\",{\"1\":{\"183\":1}}],[\"具体聚集类\",{\"1\":{\"181\":1}}],[\"具体迭代器类\",{\"1\":{\"181\":1}}],[\"具体状态\",{\"1\":{\"177\":1}}],[\"具体工厂\",{\"1\":{\"176\":1}}],[\"具体观察者\",{\"1\":{\"175\":1}}],[\"具体主题\",{\"1\":{\"175\":1}}],[\"具体建造者\",{\"1\":{\"174\":1}}],[\"具体子类将重定义primitiveoperation以实现一个算法步骤\",{\"1\":{\"172\":1}}],[\"具体原型类\",{\"1\":{\"171\":1}}],[\"具体的产品\",{\"1\":{\"170\":1}}],[\"具体的装饰对象\",{\"1\":{\"168\":1}}],[\"具体按实际所需bits大小存储\",{\"1\":{\"134\":1}}],[\"具体过程如下\",{\"1\":{\"82\":1}}],[\"具有良好的可扩展性\",{\"1\":{\"61\":1}}],[\"重定义工厂方法以返回一个concreteproduct实例\",{\"1\":{\"170\":1}}],[\"重复n到m次\",{\"1\":{\"158\":1}}],[\"重复n次或更多次\",{\"1\":{\"158\":1}}],[\"重复n次\",{\"1\":{\"158\":1}}],[\"重复零次或一次\",{\"1\":{\"158\":1}}],[\"重复零次或更多次\",{\"1\":{\"158\":1}}],[\"重复一次或更多次\",{\"1\":{\"158\":1}}],[\"重复直到对图中每个节点都进行计算\",{\"1\":{\"152\":1}}],[\"重启会读取translog日志文件数据恢复\",{\"1\":{\"137\":1}}],[\"重新写入\",{\"1\":{\"137\":1}}],[\"重新启动一个translog\",{\"1\":{\"137\":1}}],[\"重新计算ht\",{\"1\":{\"126\":1}}],[\"重新计算有效期时间\",{\"1\":{\"95\":1}}],[\"重新选主\",{\"1\":{\"81\":1}}],[\"重要的内容\",{\"1\":{\"25\":1}}],[\"常用反义词\",{\"1\":{\"158\":1}}],[\"常用限定符\",{\"1\":{\"158\":1}}],[\"常用元字符\",{\"1\":{\"158\":1}}],[\"常态下统一由leader发起提议\",{\"1\":{\"81\":1}}],[\"常见如数据库轮询的联机日志出错\",{\"1\":{\"76\":1}}],[\"进行全局排序\",{\"1\":{\"137\":1}}],[\"进行引用\",{\"1\":{\"34\":1}}],[\"进而能应用在数据库副本存储等很多场景\",{\"1\":{\"81\":1}}],[\"originator可以根据保存的memento信息还原到前一状态\",{\"1\":{\"179\":1}}],[\"originator可根据需要决定memento存储originator的哪些内部状态\",{\"1\":{\"179\":1}}],[\"originator能够看到一个宽接口\",{\"1\":{\"179\":1}}],[\"originator\",{\"1\":{\"179\":1}}],[\"order\",{\"1\":{\"81\":1,\"83\":1}}],[\"observer\",{\"0\":{\"175\":1},\"1\":{\"175\":1}}],[\"obj\",{\"1\":{\"127\":1}}],[\"objectstructure\",{\"1\":{\"189\":1}}],[\"objectfieldoffset\",{\"1\":{\"111\":1}}],[\"object\",{\"1\":{\"107\":1,\"109\":1,\"110\":2}}],[\"optional\",{\"1\":{\"156\":1}}],[\"open\",{\"0\":{\"161\":1},\"1\":{\"59\":1,\"161\":1}}],[\"open组织提出的一种分布式事务模型\",{\"1\":{\"59\":1}}],[\"ocp\",{\"0\":{\"161\":1}}],[\"ocr\",{\"1\":{\"156\":1}}],[\"occurs\",{\"1\":{\"136\":1}}],[\"onlyifabsent\",{\"1\":{\"111\":1}}],[\"offset递增1\",{\"1\":{\"143\":1}}],[\"offset\",{\"1\":{\"136\":1,\"143\":2}}],[\"offsets\",{\"1\":{\"136\":1}}],[\"of\",{\"0\":{\"185\":1},\"1\":{\"111\":1,\"126\":1,\"134\":1}}],[\"o\",{\"1\":{\"109\":1}}],[\"oldval\",{\"1\":{\"111\":1}}],[\"oldthr\",{\"1\":{\"109\":4}}],[\"oldtab\",{\"1\":{\"109\":4}}],[\"oldcap\",{\"1\":{\"109\":5}}],[\"oldcapacity\",{\"1\":{\"107\":3}}],[\"overflow\",{\"1\":{\"107\":1}}],[\"再检查二度关系\",{\"1\":{\"151\":1}}],[\"再主动pull数据\",{\"1\":{\"143\":1}}],[\"再将数据push到broker保存\",{\"1\":{\"143\":1}}],[\"再返回给客户端\",{\"1\":{\"137\":1}}],[\"再在磁盘上找term\",{\"1\":{\"134\":1}}],[\"再找ht\",{\"1\":{\"126\":1}}],[\"再一起获得响应结果\",{\"1\":{\"95\":1}}],[\"再为每个过程编上序号\",{\"1\":{\"81\":1}}],[\"再根据反馈决定提交\",{\"1\":{\"77\":1}}],[\"再根据权重计算出每台服务器能处理的连接数\",{\"1\":{\"75\":1}}],[\"宕机\",{\"1\":{\"82\":1}}],[\"宕机恢复后可经本机learner采用pull方式从其他acceptor习得\",{\"1\":{\"80\":1}}],[\"宕机的participant恢复后发现收到commit或者precommit\",{\"1\":{\"78\":1}}],[\"宕机的participant恢复后发现收到precommit或已经发出赞成vote\",{\"1\":{\"78\":1}}],[\"宕机的participant恢复后\",{\"1\":{\"78\":1}}],[\"虽然不影响一致性\",{\"1\":{\"80\":1}}],[\"记录当前组消费数据下标\",{\"1\":{\"143\":1}}],[\"记录当前页面状态\",{\"1\":{\"139\":1}}],[\"记录了segment中删除的doc\",{\"1\":{\"136\":1}}],[\"记录segment文档数量\",{\"1\":{\"136\":1}}],[\"记录中的字段概念\",{\"1\":{\"135\":1}}],[\"记录上一个节点的长度\",{\"1\":{\"124\":1}}],[\"记录事务修改之前版本的数据信息\",{\"1\":{\"118\":1}}],[\"记录所有innodb表数据变化\",{\"1\":{\"115\":1}}],[\"记录曾接受的id最大的提议\",{\"1\":{\"80\":1}}],[\"记录在失败消息表中\",{\"1\":{\"62\":1}}],[\"注\",{\"1\":{\"80\":1}}],[\"注释之前的内容被视为文章摘要\",{\"1\":{\"31\":1}}],[\"β中每一轮决议中都有唯一的id标识\",{\"1\":{\"80\":1}}],[\"β\",{\"1\":{\"80\":3}}],[\"否则就将该请求转发给它的后继者\",{\"1\":{\"185\":1}}],[\"否则用2个字节的数组\",{\"1\":{\"134\":1}}],[\"否则将使用表锁\",{\"1\":{\"119\":1}}],[\"否则可能导致多个请求都获取到锁\",{\"1\":{\"88\":1}}],[\"否则v可为任意值\",{\"1\":{\"80\":2}}],[\"否则监听自己的前一个子节点\",{\"1\":{\"73\":1}}],[\"接收者和发送者都没有对方的明确信息\",{\"1\":{\"185\":1}}],[\"接受请求的node\",{\"1\":{\"137\":1}}],[\"接受的提议值为v\",{\"1\":{\"80\":1}}],[\"接受的提议的值v\",{\"1\":{\"80\":1}}],[\"接地那宕机一段时间后恢复\",{\"1\":{\"76\":1}}],[\"约定后面发起的提议的id比前面提议的id大\",{\"1\":{\"80\":1}}],[\"假如节点总数为2f+1\",{\"1\":{\"86\":1}}],[\"假如proposer\",{\"1\":{\"80\":1}}],[\"假如coordinator提议后自身宕机\",{\"1\":{\"78\":1}}],[\"假设总是将第一个元素用作基准值\",{\"1\":{\"149\":1}}],[\"假设节点0获得租约\",{\"1\":{\"87\":1}}],[\"假设有租约颁发节点z\",{\"1\":{\"87\":1}}],[\"假设有两个事务的zxid分别是z\",{\"1\":{\"83\":1}}],[\"假设acceptor\",{\"1\":{\"80\":1}}],[\"假设多个proposer可以同时发起提议\",{\"1\":{\"80\":1}}],[\"参与决议的一方为acceptor\",{\"1\":{\"80\":1}}],[\"发起人\",{\"1\":{\"179\":1}}],[\"发起提议\",{\"1\":{\"80\":1}}],[\"发布\",{\"0\":{\"175\":1}}],[\"发生\",{\"1\":{\"83\":1}}],[\"发完则认为回滚已经完成\",{\"1\":{\"61\":1}}],[\"作为集合键的底层实现\",{\"1\":{\"128\":1}}],[\"作为结束标识符\",{\"1\":{\"123\":1}}],[\"作为解决一致性问题的协议\",{\"1\":{\"80\":1}}],[\"作者设置为\",{\"1\":{\"33\":1}}],[\"也可以是接口\",{\"1\":{\"178\":1}}],[\"也可以给对象添加一些职责\",{\"1\":{\"168\":1}}],[\"也可以用于实现leader选举\",{\"1\":{\"84\":1}}],[\"也自行commit该事务\",{\"1\":{\"78\":1}}],[\"也结束该事务\",{\"1\":{\"78\":1}}],[\"也叫本地消息表\",{\"0\":{\"62\":1}}],[\"阶段3\",{\"1\":{\"78\":1}}],[\"阶段2\",{\"1\":{\"78\":1}}],[\"阶段1\",{\"1\":{\"78\":1}}],[\"读数据\",{\"1\":{\"137\":1}}],[\"读数据会先从缓冲池读取\",{\"1\":{\"117\":1}}],[\"读不加锁采用mvcc\",{\"1\":{\"120\":1}}],[\"读不加锁\",{\"1\":{\"120\":1}}],[\"读写数据原理\",{\"0\":{\"137\":1}}],[\"读写串行\",{\"1\":{\"120\":1}}],[\"读写并行\",{\"1\":{\"120\":2}}],[\"读写锁\",{\"0\":{\"119\":1}}],[\"读副本数vr\",{\"1\":{\"86\":1}}],[\"读取logging发现未发出赞成vote\",{\"1\":{\"78\":1}}],[\"读已之所写\",{\"1\":{\"71\":1}}],[\"读已之缩写\",{\"1\":{\"71\":1}}],[\"决定阶段2是提交还是中止\",{\"1\":{\"77\":1}}],[\"决议过程在一定时间内结束\",{\"1\":{\"76\":1}}],[\"状态模式\",{\"0\":{\"177\":1}}],[\"状态一致\",{\"1\":{\"82\":1}}],[\"状态机处理完成后将结果返回给client\",{\"1\":{\"82\":1}}],[\"状态\",{\"1\":{\"77\":1,\"192\":1}}],[\"先判断实例是否存在\",{\"1\":{\"182\":1}}],[\"先写入buffer\",{\"1\":{\"137\":1}}],[\"先并发向5个节点请求\",{\"1\":{\"95\":1}}],[\"先广播的事务先commit\",{\"1\":{\"83\":1}}],[\"先由一方进行提议\",{\"1\":{\"77\":1}}],[\"先向消息中间件发送一条消息\",{\"1\":{\"61\":1}}],[\"异步环境并只存在节点宕机\",{\"1\":{\"76\":1}}],[\"异步能提升系统性能\",{\"1\":{\"61\":1}}],[\"甚至不按套路出牌抛出干扰决议的信息\",{\"1\":{\"76\":1}}],[\"拜占庭将军问题\",{\"1\":{\"76\":1}}],[\"问题可分解为离散子问题时\",{\"1\":{\"155\":1}}],[\"问题\",{\"1\":{\"76\":1}}],[\"全文索引的字段\",{\"1\":{\"136\":2}}],[\"全认同\",{\"1\":{\"76\":1}}],[\"全局事务\",{\"0\":{\"59\":1}}],[\"两个都应该依赖抽象\",{\"1\":{\"162\":1}}],[\"两个紧密相连的压缩列表节点\",{\"1\":{\"132\":1}}],[\"两边服务都起不来\",{\"1\":{\"76\":1}}],[\"两阶段型\",{\"0\":{\"63\":1}}],[\"应该考虑用迭代器模式\",{\"1\":{\"181\":1}}],[\"应该考虑用适配器\",{\"1\":{\"178\":1}}],[\"应该有意识的将不同的两个层分离\",{\"1\":{\"173\":1}}],[\"应该可以扩展\",{\"1\":{\"161\":1}}],[\"应该仅有一个引起它变化的原因\",{\"1\":{\"160\":1}}],[\"应用场景\",{\"1\":{\"155\":1,\"169\":1,\"173\":1,\"174\":1,\"175\":1,\"187\":1,\"189\":1}}],[\"应用服务\",{\"1\":{\"76\":1}}],[\"应当保证所有副本保持数据一致性\",{\"1\":{\"70\":1}}],[\"争抢共享资源\",{\"1\":{\"76\":1}}],[\"都可以考虑用反射技术\",{\"1\":{\"176\":1}}],[\"都清除\",{\"1\":{\"143\":1}}],[\"都是黑色\",{\"1\":{\"103\":1}}],[\"都以为对方出了故障\",{\"1\":{\"76\":1}}],[\"都有可能发生任何形式的故障\",{\"1\":{\"64\":1}}],[\"区间集群\",{\"1\":{\"76\":1}}],[\"多线程时的单例\",{\"1\":{\"182\":1}}],[\"多个broker组成kafka集群\",{\"1\":{\"143\":1}}],[\"多版本并发控制\",{\"0\":{\"120\":1}}],[\"多处理器加上lock前缀\",{\"1\":{\"111\":1}}],[\"多路查找树\",{\"1\":{\"103\":1}}],[\"多数派的思路还被应用于副本\",{\"1\":{\"86\":1}}],[\"多数派的思路在分布式系统很常见\",{\"1\":{\"86\":1}}],[\"多数派原理\",{\"1\":{\"86\":1}}],[\"多数派\",{\"0\":{\"86\":1},\"1\":{\"84\":1}}],[\"多数派和租约\",{\"0\":{\"84\":1}}],[\"多\",{\"1\":{\"76\":1}}],[\"获得锁\",{\"1\":{\"96\":2}}],[\"获得子节点的变更通知后重复此步骤直至获得锁\",{\"1\":{\"73\":1}}],[\"获取字符串长度复杂度o\",{\"1\":{\"123\":1}}],[\"获取锁目录下所有子节点\",{\"1\":{\"96\":1}}],[\"获取锁和释放锁的性能要好\",{\"1\":{\"88\":1}}],[\"获取当前时间\",{\"1\":{\"95\":1}}],[\"获取目标服务器的序号\",{\"1\":{\"75\":1}}],[\"源地址哈希通过对客户端ip哈希计算得到的一个数值\",{\"1\":{\"75\":1}}],[\"把数据结构和作用于结构上的操作之间的耦合解脱开\",{\"1\":{\"189\":1}}],[\"把数据库层的二阶段提交提到应用层实现\",{\"1\":{\"63\":1}}],[\"把交互复杂性变为中介者的复杂性\",{\"1\":{\"186\":1}}],[\"把原来的代码重构为命令模式才有意义\",{\"1\":{\"184\":1}}],[\"把源接口转换成目标接口\",{\"1\":{\"178\":1}}],[\"把状态的判断逻辑转移到表示不同状态的一系列类当中\",{\"1\":{\"177\":1}}],[\"把所有对观察者对象的引用保存在一个聚集里\",{\"1\":{\"175\":1}}],[\"把要装饰的功能放在单独的类中\",{\"1\":{\"168\":1}}],[\"把写缓冲区中的所有数据刷新到内存\",{\"1\":{\"111\":1}}],[\"把指令交由状态机处理\",{\"1\":{\"82\":1}}],[\"把单次\",{\"1\":{\"81\":1}}],[\"把请求随机发送到服务器上\",{\"1\":{\"75\":1}}],[\"随机算法\",{\"1\":{\"75\":1}}],[\"由很多segment文件组成\",{\"1\":{\"136\":1}}],[\"由leader\",{\"1\":{\"83\":2}}],[\"由leader操作日志覆盖follower\",{\"1\":{\"82\":1}}],[\"由两部分组成<e\",{\"1\":{\"83\":1}}],[\"由proposer\",{\"1\":{\"81\":1}}],[\"由于concretemediator控制了集中化\",{\"1\":{\"186\":1}}],[\"由于把对象如何协作进行抽象\",{\"1\":{\"186\":1}}],[\"由于加进新的具体命令类不影响其他的类\",{\"1\":{\"184\":1}}],[\"由于具体工厂类\",{\"1\":{\"176\":1}}],[\"由于在内存中完成写入效率高\",{\"1\":{\"135\":1}}],[\"由于必须获取到5个节点中3个以上\",{\"1\":{\"95\":1}}],[\"由于条件p1\",{\"1\":{\"80\":1}}],[\"由于一项提议被确定前必须先被多数派acceptor接受\",{\"1\":{\"80\":1}}],[\"由于相互联系\",{\"1\":{\"76\":1}}],[\"由于每个请求的连接时间不一样\",{\"1\":{\"75\":1}}],[\"由消息中间件的超时询问机制弥补\",{\"1\":{\"61\":1}}],[\"加锁读\",{\"1\":{\"120\":1}}],[\"加锁\",{\"1\":{\"111\":1,\"182\":1}}],[\"加权最少连接\",{\"1\":{\"75\":1}}],[\"加权轮询是在轮询的基础上\",{\"1\":{\"75\":1}}],[\"加权轮询\",{\"1\":{\"75\":1}}],[\"加密\",{\"2\":{\"9\":1}}],[\"轮询算法把每个请求轮流发送到每个服务器上\",{\"1\":{\"75\":1}}],[\"轮询\",{\"1\":{\"75\":1,\"143\":1}}],[\"负责保存好备忘录memento\",{\"1\":{\"179\":1}}],[\"负责存储originator对象的内部状态\",{\"1\":{\"179\":1}}],[\"负责创建一个备忘录memento\",{\"1\":{\"179\":1}}],[\"负责持久化和备份具体kafka消息\",{\"1\":{\"143\":1}}],[\"负责各个本地资源的提交和回滚\",{\"1\":{\"60\":1}}],[\"负载均衡\",{\"0\":{\"75\":1},\"1\":{\"157\":1}}],[\"用一个中介对象来封装一系列的对象交互\",{\"1\":{\"186\":1}}],[\"用一个单独的类来做创造一个接口各子类实例\",{\"1\":{\"166\":1}}],[\"用来创建并管理flyweight对象\",{\"1\":{\"187\":1}}],[\"用来声明执行操作的接口\",{\"1\":{\"184\":1}}],[\"用来存储子部件\",{\"1\":{\"180\":1}}],[\"用以记录当前时刻它的内部状态\",{\"1\":{\"179\":1}}],[\"用以在可靠性和性能方面取得平衡\",{\"1\":{\"86\":1}}],[\"用原型实例指定创建对象的种类\",{\"1\":{\"171\":1}}],[\"用concretestrategy配置\",{\"1\":{\"167\":1}}],[\"用crc32校验message\",{\"1\":{\"143\":1}}],[\"用在对term进行高亮\",{\"1\":{\"136\":1}}],[\"用作聚合和排序\",{\"1\":{\"136\":1}}],[\"用作分析和排序\",{\"1\":{\"135\":1}}],[\"用户查询在index上完成\",{\"1\":{\"134\":1}}],[\"用户可以访问任何一个服务器节点\",{\"1\":{\"74\":1}}],[\"用于定义得到开始对象\",{\"1\":{\"181\":1}}],[\"用于检查两项内容的相似程度\",{\"1\":{\"157\":1}}],[\"用于记录处理过的节点\",{\"1\":{\"152\":1}}],[\"用于存储要检查的对象\",{\"1\":{\"151\":1}}],[\"用于计算索引值\",{\"1\":{\"126\":1}}],[\"用于标记ziplist的结尾\",{\"1\":{\"124\":1}}],[\"用于和查询到的每行记录版本号比较\",{\"1\":{\"120\":1}}],[\"用于回滚数据\",{\"1\":{\"118\":1}}],[\"用于恢复数据\",{\"1\":{\"117\":1}}],[\"用于习得已确定的决议\",{\"1\":{\"80\":1}}],[\"用于向事务管理器提供该资源管理器的提交\",{\"1\":{\"59\":1}}],[\"用该数值对服务器数量进行取模运算\",{\"1\":{\"75\":1}}],[\"羊群效应\",{\"1\":{\"73\":2,\"96\":1}}],[\"所以最糟情况是o\",{\"1\":{\"149\":1}}],[\"所以快速查找速度将更快\",{\"1\":{\"149\":1}}],[\"所以获取锁的时间成本增加\",{\"1\":{\"95\":1}}],[\"所以会话对应的临时节点会被删除\",{\"1\":{\"73\":1}}],[\"所有具体享元类的超类或接口\",{\"1\":{\"187\":1}}],[\"所有用简单工厂的地方\",{\"1\":{\"176\":1}}],[\"所有组合\",{\"1\":{\"154\":1}}],[\"所有数据都在buffer或os\",{\"1\":{\"137\":1}}],[\"所有元素都保存在整数集合\",{\"1\":{\"131\":1}}],[\"所有叶子节点\",{\"1\":{\"103\":1}}],[\"所有叶子结点包含全部关键字及其指针\",{\"1\":{\"103\":1}}],[\"所有节点都是黑色或红色\",{\"1\":{\"103\":1}}],[\"所有n个节点都认同一个结果\",{\"1\":{\"76\":1}}],[\"所有计算机节点都是对等的\",{\"1\":{\"64\":1}}],[\"第二个保存元素的分值\",{\"1\":{\"132\":1}}],[\"第二个为\",{\"1\":{\"73\":1}}],[\"第一个segment文件名从0开始\",{\"1\":{\"143\":1}}],[\"第一个保存元素的成员\",{\"1\":{\"132\":1}}],[\"第一个客户端对应子节点为\",{\"1\":{\"73\":1}}],[\"第3点保证leader上具备所有已commit的事务\",{\"1\":{\"83\":1}}],[\"第1\",{\"1\":{\"83\":1}}],[\"创建型模式\",{\"0\":{\"190\":1}}],[\"创建具有特定实现的产品对象\",{\"1\":{\"176\":1}}],[\"创建一些复杂对象\",{\"1\":{\"174\":1}}],[\"创建一个队列\",{\"1\":{\"151\":1}}],[\"创建一个锁目录lock\",{\"1\":{\"96\":1}}],[\"创建一个锁目录\",{\"1\":{\"73\":1}}],[\"创建workinprogress\",{\"1\":{\"139\":1}}],[\"创建临时顺序节点\",{\"1\":{\"96\":1}}],[\"创建临时且有序的子节点\",{\"1\":{\"73\":1}}],[\"lsp\",{\"0\":{\"163\":1}}],[\"lucene的docvalues文件\",{\"1\":{\"136\":1}}],[\"lucene文件内容\",{\"0\":{\"136\":1}}],[\"lucene中一条记录\",{\"1\":{\"135\":1}}],[\"lucene内部数据由segment组成\",{\"1\":{\"135\":1}}],[\"lucene内部结构\",{\"0\":{\"135\":1}}],[\"level\",{\"1\":{\"127\":2}}],[\"len\",{\"1\":{\"110\":3,\"123\":1,\"125\":1,\"134\":1}}],[\"length\",{\"1\":{\"107\":1,\"109\":1,\"110\":1,\"111\":3,\"127\":1,\"128\":1,\"143\":1}}],[\"leaf\",{\"1\":{\"180\":1}}],[\"lease\",{\"0\":{\"87\":1},\"1\":{\"84\":1}}],[\"least\",{\"1\":{\"75\":2}}],[\"leader宕机时\",{\"1\":{\"87\":1}}],[\"leader选举中\",{\"1\":{\"86\":1}}],[\"leader有以下约束\",{\"1\":{\"83\":1}}],[\"leader和follower之间通过心跳判别健康状态\",{\"1\":{\"83\":1}}],[\"leader处理client的写操作\",{\"1\":{\"83\":1}}],[\"leader的有无和数目并不影响决议一致性\",{\"1\":{\"82\":1}}],[\"leader\",{\"1\":{\"82\":1,\"83\":4}}],[\"leader进行commit操作\",{\"1\":{\"82\":1}}],[\"leader将操作指令\",{\"1\":{\"82\":1}}],[\"leader统一处理变更操作请求\",{\"1\":{\"82\":1}}],[\"leader不用问询acceptor曾接受过的id最大的提议\",{\"1\":{\"81\":1}}],[\"leader在multi\",{\"1\":{\"81\":1}}],[\"learner组成\",{\"1\":{\"81\":1}}],[\"learner依附于acceptor\",{\"1\":{\"80\":1}}],[\"learner\",{\"1\":{\"80\":1}}],[\"liv\",{\"1\":{\"136\":1}}],[\"live\",{\"1\":{\"136\":1}}],[\"livelock\",{\"1\":{\"80\":1}}],[\"liveness\",{\"1\":{\"76\":1}}],[\"list的映射\",{\"1\":{\"135\":1}}],[\"list的每个id\",{\"1\":{\"134\":1}}],[\"list中查找是否存在\",{\"1\":{\"134\":1}}],[\"list按照65535\",{\"1\":{\"134\":1}}],[\"list压缩\",{\"1\":{\"134\":1}}],[\"listnode\",{\"1\":{\"125\":6}}],[\"list\",{\"1\":{\"122\":1,\"125\":2,\"134\":1,\"135\":1}}],[\"like\",{\"1\":{\"115\":2}}],[\"linkedlist编码\",{\"1\":{\"129\":1}}],[\"linkedlist\",{\"0\":{\"108\":1},\"1\":{\"122\":1}}],[\"linearizable\",{\"1\":{\"83\":1}}],[\"lnextindex不等于fnextindex时代表leader操作日志和follower操作日志存在不一致\",{\"1\":{\"82\":1}}],[\"lod\",{\"0\":{\"164\":1}}],[\"lost\",{\"1\":{\"111\":1}}],[\"long类型整数\",{\"1\":{\"122\":1}}],[\"long\",{\"1\":{\"111\":4,\"125\":1,\"126\":3,\"127\":1}}],[\"load\",{\"1\":{\"109\":2}}],[\"loadfactor\",{\"1\":{\"109\":1}}],[\"logn\",{\"1\":{\"132\":1,\"149\":1}}],[\"log记录某行数据多个版本数据\",{\"1\":{\"120\":1}}],[\"log顺序存储\",{\"1\":{\"117\":1}}],[\"logfile\",{\"1\":{\"115\":1}}],[\"logical\",{\"1\":{\"82\":1}}],[\"log\",{\"0\":{\"116\":1,\"117\":1,\"118\":1},\"1\":{\"82\":1,\"103\":1,\"105\":1,\"109\":1,\"115\":3,\"117\":3,\"118\":1,\"143\":1}}],[\"locking\",{\"1\":{\"182\":1}}],[\"locks\",{\"1\":{\"119\":1}}],[\"lock下的子节点列表\",{\"1\":{\"73\":1}}],[\"lock\",{\"0\":{\"119\":2},\"1\":{\"73\":5,\"110\":5,\"111\":1,\"119\":1}}],[\"last\",{\"1\":{\"108\":1}}],[\"latency\",{\"1\":{\"69\":1}}],[\"layout\",{\"1\":{\"0\":1}}],[\"有赞延迟队列\",{\"1\":{\"198\":1}}],[\"有效地把类的核心职责和装饰功能区分开\",{\"1\":{\"168\":1}}],[\"有差异的vnode对应的真实dom节点重新渲染插入视图\",{\"1\":{\"140\":1}}],[\"有穷状态转换器\",{\"1\":{\"134\":1}}],[\"有序集合对象\",{\"0\":{\"132\":1}}],[\"有序节点\",{\"1\":{\"73\":1}}],[\"有助于实现事务原子性\",{\"1\":{\"84\":1}}],[\"有事务z和z\",{\"1\":{\"83\":3}}],[\"有可能需要去实现存取session代码\",{\"1\":{\"74\":1}}],[\"有一定概率宕机的设备\",{\"1\":{\"68\":1}}],[\"有一个专门的消息发送者发送本地消息表的消息\",{\"1\":{\"62\":1}}],[\"临时节点\",{\"1\":{\"73\":1,\"96\":1}}],[\"永久节点\",{\"1\":{\"73\":1,\"96\":1}}],[\"n天内没有上传商品\",{\"1\":{\"194\":1}}],[\"naive\",{\"1\":{\"156\":1}}],[\"name\",{\"1\":{\"119\":2,\"136\":1}}],[\"np完全问题\",{\"0\":{\"154\":1}}],[\"nlogn\",{\"1\":{\"149\":1}}],[\"n^2\",{\"1\":{\"149\":1}}],[\"n^3\",{\"1\":{\"138\":1}}],[\"nvm\",{\"1\":{\"136\":1}}],[\"nvd\",{\"1\":{\"136\":1}}],[\"nt\",{\"1\":{\"111\":2}}],[\"nonterminalexpression\",{\"1\":{\"188\":1}}],[\"node将搜索请求转发给所有的shard对应的primary\",{\"1\":{\"137\":1}}],[\"node对document路由转发\",{\"1\":{\"137\":1}}],[\"node处理完成后返回后请求到客户端\",{\"1\":{\"137\":1}}],[\"node和所有replica\",{\"1\":{\"137\":1}}],[\"node\",{\"1\":{\"137\":3,\"139\":1}}],[\"node<\",{\"1\":{\"111\":1}}],[\"node<k\",{\"1\":{\"109\":2,\"111\":14}}],[\"node<e>\",{\"1\":{\"108\":5}}],[\"norms\",{\"1\":{\"136\":1}}],[\"no\",{\"1\":{\"111\":1}}],[\"not\",{\"1\":{\"111\":1,\"126\":1}}],[\"n表示长度\",{\"1\":{\"109\":1}}],[\"neighbours\",{\"0\":{\"156\":1}}],[\"nearest\",{\"0\":{\"156\":1}}],[\"new\",{\"1\":{\"111\":4}}],[\"newelements\",{\"1\":{\"110\":3}}],[\"newthr\",{\"1\":{\"109\":3}}],[\"newcap\",{\"1\":{\"109\":4}}],[\"newcapacity\",{\"1\":{\"107\":6}}],[\"next\",{\"1\":{\"108\":1,\"125\":1,\"126\":1}}],[\"network\",{\"1\":{\"76\":1}}],[\"number\",{\"1\":{\"126\":1}}],[\"numberofleadingzeros\",{\"1\":{\"111\":1}}],[\"number保证时序\",{\"1\":{\"82\":1}}],[\"nullpointerexception\",{\"1\":{\"111\":1}}],[\"null\",{\"1\":{\"103\":1,\"109\":2,\"111\":10}}],[\"nx\",{\"0\":{\"94\":1},\"1\":{\"94\":1}}],[\"n\",{\"1\":{\"73\":1,\"80\":2,\"99\":2,\"103\":1,\"105\":1,\"109\":17,\"111\":7,\"124\":1,\"139\":1,\"149\":2}}],[\"nrw\",{\"1\":{\"69\":1}}],[\"计算最终路径\",{\"1\":{\"152\":1}}],[\"计算文本相关性中使用\",{\"1\":{\"136\":1}}],[\"计算获取所有锁消耗的时间\",{\"1\":{\"95\":1}}],[\"计算获取锁消耗时间\",{\"1\":{\"73\":1}}],[\"计划\",{\"1\":{\"26\":2}}],[\"尝试从5个相互独立redis客户端获取锁\",{\"1\":{\"95\":1}}],[\"尝试从n个独立redis实例获取锁\",{\"1\":{\"73\":1}}],[\"尝试让操作日志副本在follower落地\",{\"1\":{\"82\":1}}],[\"尝试下一个\",{\"1\":{\"73\":1}}],[\"尝试执行业务\",{\"1\":{\"63\":1}}],[\"插入一行新记录保存当前系统版本号作为行版本号\",{\"1\":{\"120\":1}}],[\"插入删除时间复杂度o\",{\"1\":{\"99\":2,\"103\":1,\"105\":1}}],[\"插入失败直接报错\",{\"1\":{\"73\":1}}],[\"插件来实现\",{\"1\":{\"16\":1}}],[\"解释器\",{\"1\":{\"192\":1}}],[\"解释器模式\",{\"0\":{\"188\":1}}],[\"解释操作以递归方法调用r1\",{\"1\":{\"188\":1}}],[\"解除分支判断带来的耦合\",{\"1\":{\"176\":1}}],[\"解锁失败会导致死锁\",{\"1\":{\"73\":1,\"91\":1}}],[\"解决最短路径问题\",{\"1\":{\"151\":1}}],[\"解决方法是从proposer中选出一个leader\",{\"1\":{\"80\":1}}],[\"解决跨应用业务操作的原子性\",{\"1\":{\"63\":1}}],[\"解决应用拆分带来的跨应用业务操作原子性问题\",{\"1\":{\"63\":1}}],[\"锁\",{\"0\":{\"116\":1}}],[\"锁必须被清除\",{\"1\":{\"88\":1}}],[\"锁没有失效时间\",{\"1\":{\"73\":1,\"91\":1}}],[\"锁可以有阻塞锁和乐观锁两种实现方式\",{\"1\":{\"73\":1}}],[\"释放ht\",{\"1\":{\"126\":1}}],[\"释放锁时就删除该记录\",{\"1\":{\"91\":1}}],[\"释放锁时删除记录\",{\"1\":{\"73\":1}}],[\"释放try阶段预留的业务资源\",{\"1\":{\"63\":1}}],[\"互斥量为1表示有其它进程在使用锁\",{\"1\":{\"73\":1}}],[\"单例\",{\"1\":{\"190\":1}}],[\"单例模式\",{\"0\":{\"182\":1}}],[\"单一职责原则\",{\"0\":{\"160\":1}}],[\"单位\",{\"1\":{\"124\":1}}],[\"单位毫秒\",{\"1\":{\"94\":1}}],[\"单处理器则忽略\",{\"1\":{\"111\":1}}],[\"单调写一致性\",{\"1\":{\"71\":1}}],[\"单调读一致性\",{\"1\":{\"71\":1}}],[\"单词\",{\"1\":{\"23\":1}}],[\"自动扩容\",{\"1\":{\"107\":1}}],[\"自行中止该事务\",{\"1\":{\"78\":1}}],[\"自身总是能访问自身更新过的最新值\",{\"1\":{\"71\":1}}],[\"自定义对齐\",{\"0\":{\"22\":1}}],[\"自定义标题\",{\"1\":{\"19\":5}}],[\"w\",{\"1\":{\"158\":2}}],[\"web\",{\"1\":{\"139\":1}}],[\"weighted\",{\"1\":{\"75\":2}}],[\"where\",{\"1\":{\"119\":2,\"136\":1}}],[\"when\",{\"1\":{\"111\":1}}],[\"while\",{\"1\":{\"111\":1}}],[\"was\",{\"1\":{\"109\":1}}],[\"watch被触发时\",{\"1\":{\"96\":1}}],[\"watcher\",{\"1\":{\"96\":2}}],[\"watchdog通过问询其他participant获得这些信息\",{\"1\":{\"78\":1}}],[\"watchdog\",{\"1\":{\"77\":1}}],[\"write\",{\"1\":{\"71\":1}}],[\"writes\",{\"1\":{\"71\":1}}],[\"win\",{\"1\":{\"107\":1}}],[\"without\",{\"1\":{\"67\":3}}],[\"will\",{\"1\":{\"32\":1}}],[\"那么可能就值得将该问题的各个实例表述为一个简单语言中的句子\",{\"1\":{\"188\":1}}],[\"那么可以用相对较少的共享对象取代很多组对象\",{\"1\":{\"187\":1}}],[\"那么就把这种多角度分离出来让它们独立变化\",{\"1\":{\"183\":1}}],[\"那么这两个类就不应当发生直接的相互作用\",{\"1\":{\"164\":1}}],[\"那么这个类就具有多于一个的职责\",{\"1\":{\"160\":1}}],[\"那么在少数节点宕机\",{\"1\":{\"80\":1}}],[\"那么要求v=v\",{\"1\":{\"80\":2}}],[\"那么proposer后续只发起值为v的提议\",{\"1\":{\"80\":1}}],[\"那么participant将进入阻塞\",{\"1\":{\"77\":1}}],[\"那么acceptor后续只接受值为v的提议\",{\"1\":{\"80\":1}}],[\"那么acceptor做到以下这点可以确定一个值\",{\"1\":{\"80\":1}}],[\"那么后续只确定值为v的提议\",{\"1\":{\"80\":1}}],[\"那么任意一个子节点状态改变\",{\"1\":{\"73\":1}}],[\"那么系统对于该节点后续的任何数据访问都不应该返回更旧的值\",{\"1\":{\"71\":1}}],[\"那么节点b之后对该数据的访问和修改都是基于a更新后的值\",{\"1\":{\"71\":1}}],[\"那么消息中间件在等待确认应答超时之后会重新投递\",{\"1\":{\"61\":1}}],[\"功能上的损失\",{\"1\":{\"70\":1}}],[\"响应时间上的损失\",{\"1\":{\"70\":1}}],[\"srp\",{\"0\":{\"160\":1}}],[\"src\",{\"1\":{\"139\":1,\"140\":2}}],[\"s\",{\"1\":{\"141\":1,\"158\":2}}],[\"s64\",{\"1\":{\"126\":1}}],[\"sdshdr\",{\"1\":{\"123\":1}}],[\"sds\",{\"0\":{\"123\":1},\"1\":{\"123\":1}}],[\"skiplist编码\",{\"1\":{\"132\":1}}],[\"skiplistnode\",{\"1\":{\"127\":1}}],[\"skiplist\",{\"1\":{\"122\":1}}],[\"sha\",{\"1\":{\"157\":1}}],[\"shard\",{\"1\":{\"137\":1}}],[\"shard或replica\",{\"1\":{\"137\":1}}],[\"shard及所有replica中随机选择一个\",{\"1\":{\"137\":1}}],[\"shard是数据存储的最小单元\",{\"1\":{\"134\":1}}],[\"share\",{\"1\":{\"119\":1}}],[\"shared\",{\"0\":{\"119\":1}}],[\"shortest\",{\"1\":{\"151\":1}}],[\"short存储单位\",{\"1\":{\"134\":1}}],[\"show\",{\"1\":{\"115\":2}}],[\"subject\",{\"1\":{\"175\":1}}],[\"subject类\",{\"1\":{\"169\":1}}],[\"subscribe模式\",{\"0\":{\"175\":1}}],[\"subsystem\",{\"1\":{\"173\":1}}],[\"such\",{\"1\":{\"136\":1}}],[\"suppresswarnings\",{\"1\":{\"111\":1}}],[\"sun\",{\"1\":{\"111\":1}}],[\"schedulerx\",{\"1\":{\"198\":1}}],[\"scheduledexecutorservice\",{\"1\":{\"198\":1}}],[\"score属性保存分值\",{\"1\":{\"132\":1}}],[\"score\",{\"1\":{\"127\":1}}],[\"sc\",{\"1\":{\"111\":7}}],[\"scale\",{\"1\":{\"111\":5}}],[\"span\",{\"1\":{\"127\":1}}],[\"spin\",{\"1\":{\"111\":1}}],[\"spread\",{\"1\":{\"111\":1}}],[\"split\",{\"1\":{\"76\":1}}],[\"singleton类\",{\"1\":{\"182\":1}}],[\"singleton\",{\"0\":{\"182\":1}}],[\"simhash\",{\"1\":{\"157\":1}}],[\"similarity\",{\"1\":{\"156\":1}}],[\"simplex算法\",{\"1\":{\"157\":1}}],[\"simple\",{\"0\":{\"123\":1},\"1\":{\"123\":1}}],[\"si\",{\"1\":{\"136\":1}}],[\"signifies\",{\"1\":{\"109\":1}}],[\"sizemask\",{\"1\":{\"126\":1}}],[\"sizectl\",{\"1\":{\"111\":7}}],[\"size\",{\"1\":{\"107\":2,\"126\":2,\"143\":1}}],[\"so\",{\"1\":{\"107\":1}}],[\"soft\",{\"1\":{\"70\":1}}],[\"synchronized\",{\"0\":{\"111\":1},\"1\":{\"111\":1}}],[\"synchronous\",{\"1\":{\"76\":1}}],[\"sync\",{\"1\":{\"83\":2}}],[\"safety\",{\"1\":{\"76\":1}}],[\"stores\",{\"1\":{\"136\":3}}],[\"stop\",{\"1\":{\"76\":1}}],[\"strategy类\",{\"1\":{\"167\":1}}],[\"strategy\",{\"0\":{\"167\":1}}],[\"str\",{\"1\":{\"134\":1}}],[\"string\",{\"0\":{\"123\":1},\"1\":{\"122\":1,\"123\":1}}],[\"structz\",{\"1\":{\"127\":1}}],[\"struct\",{\"1\":{\"122\":1,\"123\":1,\"125\":4,\"126\":4,\"127\":5,\"128\":1}}],[\"strong\",{\"1\":{\"83\":1}}],[\"static\",{\"1\":{\"107\":1,\"108\":1,\"109\":7,\"111\":6}}],[\"state类\",{\"1\":{\"177\":1}}],[\"state\",{\"0\":{\"177\":1},\"1\":{\"70\":1,\"82\":1,\"134\":1}}],[\"sticky\",{\"1\":{\"74\":1}}],[\"secure\",{\"1\":{\"157\":1}}],[\"search\",{\"0\":{\"151\":1}}],[\"segment的所有文件内容都保存在cfs文件中\",{\"1\":{\"136\":1}}],[\"segment的元数据文件\",{\"1\":{\"136\":1}}],[\"segment\",{\"1\":{\"136\":1,\"143\":2}}],[\"set\",{\"1\":{\"122\":1,\"134\":1}}],[\"setarray\",{\"1\":{\"110\":1}}],[\"serializable\",{\"1\":{\"120\":1}}],[\"select\",{\"1\":{\"119\":2,\"120\":1}}],[\"sex\",{\"0\":{\"94\":1}}],[\"sessions\",{\"1\":{\"74\":1}}],[\"session\",{\"1\":{\"71\":1,\"74\":1}}],[\"sequential\",{\"1\":{\"69\":1}}],[\"基线条件\",{\"1\":{\"148\":1}}],[\"基本可用\",{\"1\":{\"70\":2}}],[\"基于假设\",{\"1\":{\"152\":1}}],[\"基于时间存储或基于大小\",{\"1\":{\"143\":1}}],[\"基于列存储\",{\"1\":{\"141\":1}}],[\"基于\",{\"0\":{\"94\":1}}],[\"基于mysql锁表\",{\"0\":{\"91\":1}}],[\"基于可靠消息服务的分布式事务\",{\"0\":{\"61\":1}}],[\"基于xa协议的两阶段提交\",{\"0\":{\"60\":1}}],[\"衡量系统可用性\",{\"1\":{\"69\":1}}],[\"实例上获取锁\",{\"1\":{\"73\":1}}],[\"实现简单\",{\"1\":{\"196\":1}}],[\"实现方式\",{\"0\":{\"195\":1}}],[\"实现方便\",{\"1\":{\"97\":1}}],[\"实现accept操作\",{\"1\":{\"189\":1}}],[\"实现每个由visitor声明的操作\",{\"1\":{\"189\":1}}],[\"实现与文法中的终结符相关联的解释操作\",{\"1\":{\"188\":1}}],[\"实现抽象表达式中所要求的的接口\",{\"1\":{\"188\":1}}],[\"实现抽象类的方法\",{\"1\":{\"186\":1}}],[\"实现抽象观察者角色所要求的更新接口\",{\"1\":{\"175\":1}}],[\"实现系统可能有多角度分类\",{\"1\":{\"183\":1}}],[\"实现开始\",{\"1\":{\"181\":1}}],[\"实现所有类共有接口的默认行为\",{\"1\":{\"180\":1}}],[\"实现builder接口\",{\"1\":{\"174\":1}}],[\"实现子系统的功能\",{\"1\":{\"173\":1}}],[\"实现一个模板方法\",{\"1\":{\"172\":1}}],[\"实现一个克隆自身的操作\",{\"1\":{\"171\":1}}],[\"实现primitiveoperation以完成算法中与特定子类相关的步骤\",{\"1\":{\"172\":1}}],[\"实现product接口\",{\"1\":{\"170\":1}}],[\"实现po的核心是zxid\",{\"1\":{\"83\":1}}],[\"实现term到doc\",{\"1\":{\"135\":1}}],[\"实现依赖\",{\"1\":{\"120\":1}}],[\"实现分布式锁\",{\"1\":{\"96\":1}}],[\"实现条件较为苛刻\",{\"1\":{\"95\":1}}],[\"实现\",{\"1\":{\"73\":1,\"183\":1}}],[\"实现在调用端看来数据强一致\",{\"1\":{\"69\":1}}],[\"实际不需要的功能\",{\"1\":{\"184\":1}}],[\"实际消息数据\",{\"1\":{\"143\":1}}],[\"实际存储系统版本号\",{\"1\":{\"120\":1}}],[\"实际方案\",{\"0\":{\"60\":1}}],[\"实际的文章内容\",{\"1\":{\"7\":1}}],[\"e为边数\",{\"1\":{\"151\":1}}],[\"extension\",{\"1\":{\"136\":1,\"161\":1}}],[\"exclusive\",{\"0\":{\"119\":1}}],[\"embstr编码\",{\"1\":{\"123\":1}}],[\"embstr编码的简单动态字符串\",{\"1\":{\"122\":1}}],[\"embstr\",{\"1\":{\"122\":1}}],[\"empty\",{\"1\":{\"111\":1}}],[\"error\",{\"1\":{\"111\":1}}],[\"elasticsearch实现了translog\",{\"1\":{\"135\":1}}],[\"elasticsearch为每个field建立倒排索引term\",{\"1\":{\"134\":1}}],[\"elasticsearch\",{\"0\":{\"133\":1}}],[\"else\",{\"1\":{\"109\":3,\"111\":4}}],[\"element\",{\"1\":{\"139\":1,\"189\":1}}],[\"elements\",{\"1\":{\"110\":3}}],[\"elementdata\",{\"1\":{\"107\":4}}],[\"election\",{\"0\":{\"85\":1},\"1\":{\"84\":1}}],[\"ectd可用于租约颁发\",{\"1\":{\"87\":1}}],[\"e\",{\"1\":{\"83\":1,\"108\":1,\"110\":3}}],[\"e=z\",{\"1\":{\"83\":1}}],[\"e或者z\",{\"1\":{\"83\":1}}],[\"e<z\",{\"1\":{\"83\":1}}],[\"e即leader选举时生成的epoch\",{\"1\":{\"83\":1}}],[\"established\",{\"1\":{\"83\":1}}],[\"epoch\",{\"1\":{\"83\":1}}],[\"encoding\",{\"1\":{\"122\":2,\"124\":1,\"128\":1}}],[\"en\",{\"1\":{\"120\":1}}],[\"entry\",{\"1\":{\"82\":1,\"124\":2}}],[\"enhance\",{\"1\":{\"18\":1}}],[\"eventually\",{\"1\":{\"70\":1}}],[\"eventual\",{\"1\":{\"69\":1}}],[\"满足所有元素小于64字节\",{\"1\":{\"132\":1}}],[\"满足所有元素都是整数值\",{\"1\":{\"131\":1}}],[\"满足所有键值字符串长度都小于64字节\",{\"1\":{\"130\":1}}],[\"满足所有字符串长度都小于64字节\",{\"1\":{\"129\":1}}],[\"满足序列一致性\",{\"1\":{\"69\":1}}],[\"满足base理论\",{\"1\":{\"61\":1}}],[\"操作具备原子性\",{\"1\":{\"69\":1}}],[\"没有前往该节点的更短路径\",{\"1\":{\"152\":1}}],[\"没有比不支付任何费用更便宜的方式\",{\"1\":{\"152\":1}}],[\"没有数字用0填充\",{\"1\":{\"143\":1}}],[\"没有算法能同时满足数据一致性和服务可用性\",{\"1\":{\"68\":1}}],[\"没有记录prepare节点日志\",{\"1\":{\"60\":1}}],[\"现实网络不是一个可靠的信道\",{\"1\":{\"76\":1}}],[\"现实情况下我们面对的是一个不可靠的网络\",{\"1\":{\"68\":1}}],[\"现在众多nosql都属于此类\",{\"1\":{\"67\":1}}],[\"退而求其次保证最终一致性\",{\"1\":{\"67\":1}}],[\"舍弃a\",{\"1\":{\"67\":1}}],[\"舍弃p\",{\"1\":{\"67\":1}}],[\"很多传统数据库分布式事务都属于属于这种模式\",{\"1\":{\"67\":1}}],[\"相比paxos\",{\"1\":{\"83\":2}}],[\"相互独立的节点间如何达成决议的问题\",{\"1\":{\"80\":1}}],[\"相对于原子性而言\",{\"1\":{\"70\":1}}],[\"相当于每个请求都需要在server之间强一致\",{\"1\":{\"67\":1}}],[\"相关信息\",{\"1\":{\"15\":1}}],[\"相关配置文档请见\",{\"1\":{\"0\":1}}],[\"除非整个网络环境都发生了故障\",{\"1\":{\"66\":1}}],[\"除非需求指标允许\",{\"1\":{\"64\":1}}],[\"仍然能够对外提供满足一致性和可用性的服务\",{\"1\":{\"66\":1}}],[\"每一种分类都有可能变化\",{\"1\":{\"183\":1}}],[\"每一个子类实现一个与context的一个状态相关的行为\",{\"1\":{\"177\":1}}],[\"每一个类都应当尽量降低成员的访问权限\",{\"1\":{\"164\":1}}],[\"每一条请求包含操作指令\",{\"1\":{\"82\":1}}],[\"每步都选择局部最优解\",{\"1\":{\"153\":1}}],[\"每条消息在partition中位置称为offset偏移量\",{\"1\":{\"143\":1}}],[\"每隔5秒将translog中的数据持久化到磁盘\",{\"1\":{\"137\":1}}],[\"每秒将os\",{\"1\":{\"137\":1}}],[\"每开启一个新事务\",{\"1\":{\"120\":1}}],[\"每开启一个事务\",{\"1\":{\"115\":1}}],[\"每次传输数据大小大于redo\",{\"1\":{\"117\":1}}],[\"每次租约时长内只有一个节点获得租约\",{\"1\":{\"87\":1}}],[\"每次选举产生新leader的同时产生新epoch\",{\"1\":{\"83\":1}}],[\"每次选举产生新leader的同时\",{\"1\":{\"82\":1}}],[\"每次请求都能获取到非错的响应\",{\"1\":{\"66\":1}}],[\"每个操作实现算法的一部分\",{\"1\":{\"189\":1}}],[\"每个具体同事只知道自己的行为\",{\"1\":{\"186\":1}}],[\"每个主题都可以有任何数量的观察者\",{\"1\":{\"175\":1}}],[\"每个装饰对象只关心自己的功能\",{\"1\":{\"168\":1}}],[\"每个子问题都是离散的\",{\"1\":{\"155\":1}}],[\"每个递归函数都有两部分\",{\"1\":{\"148\":1}}],[\"每个message由key\",{\"1\":{\"143\":1}}],[\"每个partition是一个有序的队列\",{\"1\":{\"143\":1}}],[\"每个kafka实例称为broker\",{\"1\":{\"143\":1}}],[\"每个element对应一个fiber\",{\"1\":{\"139\":1}}],[\"每个分片将在本地构建优先级队列\",{\"1\":{\"137\":1}}],[\"每个segment存储多个message信息\",{\"1\":{\"143\":1}}],[\"每个segment包含如下文件\",{\"1\":{\"136\":1}}],[\"每个shard将搜索结果\",{\"1\":{\"137\":1}}],[\"每个字符串对象保存一个列表元素\",{\"1\":{\"129\":1}}],[\"每个节点都会产生from+size的结果集\",{\"1\":{\"137\":1}}],[\"每个节点都保存一个字符串对象\",{\"1\":{\"129\":1}}],[\"每个节点保存一个列表元素\",{\"1\":{\"129\":1}}],[\"每个节点有多个指向其他节点的指针\",{\"1\":{\"127\":1}}],[\"每个节点的每层都有指向表尾方向最近一个节点的指针\",{\"1\":{\"105\":1}}],[\"每个节点只能用本地数据提供服务\",{\"1\":{\"67\":1}}],[\"每个结点可存储多个元素\",{\"1\":{\"103\":1}}],[\"每个元素都有指针域\",{\"1\":{\"101\":1}}],[\"每个\",{\"1\":{\"35\":1}}],[\"严格的一致性\",{\"1\":{\"66\":1}}],[\"网络中断或宕机无法释放锁时\",{\"1\":{\"88\":1}}],[\"网络隔离等异常情况时zab重新回到discovery阶段\",{\"1\":{\"83\":1}}],[\"网络链路出现问题\",{\"1\":{\"76\":1}}],[\"网络分化场景下只有具备多数派节点的部分才可能选出leader\",{\"1\":{\"86\":1}}],[\"网络分化等情况可引起leader重新选举\",{\"1\":{\"82\":1}}],[\"网络分化隔离的情况下\",{\"1\":{\"80\":1}}],[\"网络分化的场景下能保证决议的一致性\",{\"1\":{\"79\":1}}],[\"网络分化\",{\"1\":{\"76\":1}}],[\"网络分区的情况下为达成c\",{\"1\":{\"66\":1}}],[\"网络分区\",{\"1\":{\"65\":1}}],[\"网络发生故障宁可停止服务\",{\"1\":{\"67\":1}}],[\"网络通信的发起方时无法确定当前请求是否被成功处理\",{\"1\":{\"65\":1}}],[\"失败与超时\",{\"1\":{\"65\":1}}],[\"概念\",{\"1\":{\"65\":1}}],[\"三态\",{\"1\":{\"65\":2}}],[\"脑裂\",{\"0\":{\"76\":1},\"1\":{\"65\":1,\"76\":1}}],[\"俗称\",{\"1\":{\"65\":1}}],[\"只需初始化时出现一次\",{\"1\":{\"176\":1}}],[\"只适用于有向无环图\",{\"1\":{\"152\":1}}],[\"只进行同层级比较\",{\"1\":{\"140\":1}}],[\"只要\",{\"1\":{\"167\":1}}],[\"只要每次都随机选择一个数组元素作为基准值\",{\"1\":{\"149\":1}}],[\"只要数据输入到os\",{\"1\":{\"137\":1}}],[\"只要buffer中数据被refresh到os\",{\"1\":{\"137\":1}}],[\"只查找版本小于等于当前事务版本的数据行\",{\"1\":{\"120\":1}}],[\"只能保证一个共享变量\",{\"1\":{\"111\":1}}],[\"只能保证数据最终一致性\",{\"1\":{\"110\":1}}],[\"只能是非阻塞锁\",{\"1\":{\"73\":1,\"91\":1}}],[\"只允许在一端进行插入操作\",{\"0\":{\"102\":1}}],[\"只关注比自己次小的节点是为了防止发生\",{\"1\":{\"96\":1}}],[\"只有在真正需要如撤销\",{\"1\":{\"184\":1}}],[\"只有通过索引条件检索数据\",{\"1\":{\"119\":1}}],[\"只有键key不存在时才会设置key的值\",{\"1\":{\"94\":1}}],[\"只有租约到期\",{\"1\":{\"87\":1}}],[\"只有leader提议也不需要acceptor进行promise\",{\"1\":{\"81\":1}}],[\"只有当这个时间小于锁的过期时间\",{\"1\":{\"73\":1}}],[\"只有舍弃c\",{\"1\":{\"67\":1}}],[\"只有部分节点之间能够进行正常通信\",{\"1\":{\"65\":1}}],[\"只使用try阶段预留的业务资源\",{\"1\":{\"63\":1}}],[\"最佳情况也是平均情况\",{\"1\":{\"149\":1}}],[\"最佳情况是o\",{\"1\":{\"149\":1}}],[\"最佳情况下\",{\"1\":{\"149\":1}}],[\"最佳block大小为100mb\",{\"1\":{\"141\":1}}],[\"最后返回给客户端\",{\"1\":{\"137\":1}}],[\"最后返回数据\",{\"1\":{\"114\":1}}],[\"最后得到交集的结果\",{\"1\":{\"134\":1}}],[\"最后按字节存储\",{\"1\":{\"134\":1}}],[\"最后再引入一个新角色\",{\"1\":{\"80\":1}}],[\"最少连接是将请求发送给当前最少连接数的服务器上\",{\"1\":{\"75\":1}}],[\"最少连接\",{\"1\":{\"75\":1}}],[\"最终得到的就是全局最优解\",{\"1\":{\"153\":1}}],[\"最终一致性分为5种\",{\"0\":{\"71\":1}}],[\"最终一致性\",{\"1\":{\"69\":1,\"70\":2}}],[\"最终导致组成分布式系统的所有节点中\",{\"1\":{\"65\":1}}],[\"最多只能同时满足其中2个\",{\"1\":{\"66\":1}}],[\"最大努力通知\",{\"0\":{\"62\":1}}],[\"最大限度降低系统复杂度\",{\"1\":{\"61\":1}}],[\"导致栈长为o\",{\"1\":{\"149\":1}}],[\"导致处理数据时较慢\",{\"1\":{\"141\":1}}],[\"导致数据损坏\",{\"1\":{\"76\":1}}],[\"导致分布式系统中部分节点之间的网络延时不断增大\",{\"1\":{\"65\":1}}],[\"导航栏\",{\"1\":{\"4\":1,\"10\":1}}],[\"当<=0时元素失效\",{\"1\":{\"197\":1}}],[\"当订单一直处于未支付状态\",{\"1\":{\"194\":1}}],[\"当有一个语言需要解释执行\",{\"1\":{\"188\":1}}],[\"当用户请求一个flyweight时\",{\"1\":{\"187\":1}}],[\"当需要访问一个聚集对象\",{\"1\":{\"181\":1}}],[\"当一个对象的内在状态改变时允许改变其行为\",{\"1\":{\"177\":1}}],[\"当一个对象的改变需要同时改变其他对象\",{\"1\":{\"175\":1}}],[\"当要完成在某一细节层次一致的一个过程或一系列步骤\",{\"1\":{\"172\":1}}],[\"当调用真实对象时\",{\"1\":{\"169\":1}}],[\"当只需找到能够大致解决问题的算法\",{\"1\":{\"153\":1}}],[\"当前对象等方法\",{\"1\":{\"181\":1}}],[\"当前对象等抽象方法\",{\"1\":{\"181\":1}}],[\"当前文件的起始偏移量\",{\"1\":{\"143\":1}}],[\"当前节点的值\",{\"1\":{\"124\":1}}],[\"当前节点的编码规则\",{\"1\":{\"124\":1}}],[\"当寻址时间为传输时间的1\",{\"1\":{\"141\":1}}],[\"当数据发生变化时\",{\"1\":{\"138\":1}}],[\"当translog文件变大到一定程度\",{\"1\":{\"137\":1}}],[\"当插入比其类型大\",{\"1\":{\"128\":1}}],[\"当集合只包含整数元素\",{\"1\":{\"128\":1}}],[\"当线程获得锁后\",{\"1\":{\"97\":1}}],[\"当节点状态发生改变时\",{\"1\":{\"96\":1}}],[\"当创建一个节点时\",{\"1\":{\"96\":1}}],[\"当且仅当客户端从多数节点获取锁\",{\"1\":{\"95\":1}}],[\"当满足z\",{\"1\":{\"83\":1}}],[\"当多数\",{\"1\":{\"80\":1}}],[\"当两\",{\"1\":{\"76\":1}}],[\"当服务器节点宕机时\",{\"1\":{\"74\":1}}],[\"当想要获得锁时\",{\"1\":{\"73\":1,\"91\":1}}],[\"当出现超时现象时\",{\"1\":{\"65\":1}}],[\"当网络分区出现时\",{\"1\":{\"65\":1}}],[\"当网络由于发生异常情况\",{\"1\":{\"65\":1}}],[\"当消息中间件收到一条事务型消息后开始计时\",{\"1\":{\"61\":1}}],[\"另外使得系统更加复杂\",{\"1\":{\"187\":1}}],[\"另外多处使用就要多次声明具体工厂类\",{\"1\":{\"176\":1}}],[\"另外只有3个节点\",{\"1\":{\"95\":1}}],[\"另外\",{\"1\":{\"65\":1}}],[\"通常可以让一个全局变量使得一个对象被访问\",{\"1\":{\"182\":1}}],[\"通常考虑用模板方法模式处理\",{\"1\":{\"172\":1}}],[\"通常会预留容量\",{\"1\":{\"107\":1}}],[\"通信异常\",{\"1\":{\"65\":1}}],[\"通过实现抽象表达式的interpret\",{\"1\":{\"188\":1}}],[\"通过这个接口\",{\"1\":{\"187\":1}}],[\"通过在内部包装一个adaptee对象\",{\"1\":{\"178\":1}}],[\"通过zookeeper找到broker\",{\"1\":{\"143\":1}}],[\"通过分配唯一id进行区分\",{\"1\":{\"139\":1}}],[\"通过dom\",{\"1\":{\"138\":1}}],[\"通过coordinating\",{\"1\":{\"137\":3}}],[\"通过term的前缀与term\",{\"1\":{\"134\":1}}],[\"通过指针指向同一地址\",{\"1\":{\"132\":1}}],[\"通过object\",{\"1\":{\"122\":1}}],[\"通过数据多版本实现不加锁读进而做到读写并行\",{\"1\":{\"120\":1}}],[\"通过每行记录后面保存两个隐藏列实现\",{\"1\":{\"120\":1}}],[\"通过给索引上的索引项加锁实现\",{\"1\":{\"119\":1}}],[\"通过主键实现\",{\"1\":{\"114\":1}}],[\"通过锁超时机制不是十分可靠\",{\"1\":{\"97\":1}}],[\"通过future方式\",{\"1\":{\"95\":1}}],[\"通过心跳\",{\"1\":{\"87\":1}}],[\"通过打破节点间的对等关系\",{\"1\":{\"84\":1}}],[\"通过问询各participant的状态\",{\"1\":{\"77\":1}}],[\"通过用这个记录是否存在判断是否锁定\",{\"1\":{\"73\":1}}],[\"通过xa接口\",{\"1\":{\"59\":1}}],[\"通过提供的xa接口来统一调度资源管理器\",{\"1\":{\"59\":1}}],[\"通过\",{\"1\":{\"15\":1,\"18\":1}}],[\"组合\",{\"1\":{\"191\":1}}],[\"组合中的对象声明接口\",{\"1\":{\"180\":1}}],[\"组合模式使得用户对单个对象和组合对象的使用具有一致性\",{\"1\":{\"180\":1}}],[\"组合模式\",{\"0\":{\"180\":1}}],[\"组成分布式系统的所有计算机\",{\"1\":{\"64\":1}}],[\"组件\",{\"0\":{\"28\":1,\"35\":1},\"1\":{\"35\":1}}],[\"故障总是会发生\",{\"1\":{\"64\":1}}],[\"缺乏全局时钟\",{\"1\":{\"64\":1}}],[\"缺点是每加一个产品\",{\"1\":{\"170\":1}}],[\"缺点\",{\"1\":{\"60\":1,\"63\":1,\"74\":3,\"75\":1,\"97\":3,\"176\":1,\"186\":1,\"189\":1,\"196\":1}}],[\"指挥者\",{\"1\":{\"174\":1}}],[\"指向下个哈希表节点\",{\"1\":{\"126\":1}}],[\"指向底层实现数据结构的指针\",{\"1\":{\"122\":1}}],[\"指令id\",{\"1\":{\"82\":1}}],[\"指令通过log\",{\"1\":{\"82\":1}}],[\"指的是组成分布式系统的服务器节点出现的宕机或僵死现象\",{\"1\":{\"65\":1}}],[\"指的是分布式系统对数据和服务提供的一种冗余方式\",{\"1\":{\"64\":1}}],[\"指南\",{\"2\":{\"11\":1}}],[\"副本\",{\"1\":{\"64\":1}}],[\"机器分布情况也会随时变动\",{\"1\":{\"64\":1}}],[\"规定一个目录下只能有一个唯一文件名\",{\"1\":{\"96\":1}}],[\"规定要实现分布式事务\",{\"1\":{\"59\":1}}],[\"规避数据库层2pc性能低下问题\",{\"1\":{\"63\":1}}],[\"并发送激活短信\",{\"1\":{\"194\":1}}],[\"并发性比vector好\",{\"1\":{\"110\":1}}],[\"并发性\",{\"1\":{\"64\":1}}],[\"并退还库存\",{\"1\":{\"194\":1}}],[\"并定义一个解释器\",{\"1\":{\"188\":1}}],[\"并为内部状态增加存储空间\",{\"1\":{\"187\":1}}],[\"并从具体同事接收消息\",{\"1\":{\"186\":1}}],[\"并沿着这条链传递该请求\",{\"1\":{\"185\":1}}],[\"并提供一个访问它的全局访问点\",{\"1\":{\"182\":1}}],[\"并可防止originator以外的其他对象访问备忘录memento\",{\"1\":{\"179\":1}}],[\"并可使用备忘录恢复内部状态\",{\"1\":{\"179\":1}}],[\"并在该对象之外保存这个状态\",{\"1\":{\"179\":1}}],[\"并在业务活动提交时确认所有的tcc型操作的confirm操作\",{\"1\":{\"63\":1}}],[\"并让这个类包装所要修饰的对象\",{\"1\":{\"168\":1}}],[\"并被集中在单个任务上\",{\"1\":{\"165\":1}}],[\"并行性管理开销\",{\"1\":{\"157\":1}}],[\"并行算法\",{\"1\":{\"157\":1}}],[\"并创建空白ht\",{\"1\":{\"126\":1}}],[\"并将状态变更广播至follower\",{\"1\":{\"83\":1}}],[\"并把一致性问题具体化为保持日志副本的一致性\",{\"1\":{\"82\":1}}],[\"并假设可以有多项提议被确定\",{\"1\":{\"80\":1}}],[\"并收集其他节点的反馈\",{\"1\":{\"77\":1}}],[\"并且可将语言中的句子表示为一个抽象语法树时\",{\"1\":{\"188\":1}}],[\"并且它可以提供一个访问该实例的方法\",{\"1\":{\"182\":1}}],[\"并且通过拷贝这些原型对象创建新的对象\",{\"1\":{\"171\":1}}],[\"并且不太可能增长为不可控制的庞然大物\",{\"1\":{\"165\":1}}],[\"并且元素个数不多时\",{\"1\":{\"128\":1}}],[\"并且回滚日志必须先于数据持久化到磁盘\",{\"1\":{\"118\":1}}],[\"并且有序\",{\"1\":{\"96\":1}}],[\"并且获取锁的时间小于锁的有效时间\",{\"1\":{\"95\":1}}],[\"并且节点不宕机\",{\"1\":{\"80\":1}}],[\"并且是有序的\",{\"1\":{\"73\":1}}],[\"并且从大多数\",{\"1\":{\"73\":1}}],[\"并认为该状态不影响系统的整体可用性\",{\"1\":{\"70\":1}}],[\"并触发下游系统的任务执行\",{\"1\":{\"62\":1}}],[\"包括index\",{\"1\":{\"143\":1}}],[\"包括field数量\",{\"1\":{\"136\":1}}],[\"包括记录维护tcc全局事务的事务状态和每个从业务服务的子事务状态\",{\"1\":{\"63\":1}}],[\"包含解释器之外的一些全局信息\",{\"1\":{\"188\":1}}],[\"包含所有产品创建的抽象方法\",{\"1\":{\"176\":1}}],[\"包含负权边的图\",{\"1\":{\"152\":1}}],[\"包含多个consumer\",{\"1\":{\"143\":1}}],[\"包含磁盘数据页的映射\",{\"1\":{\"117\":1}}],[\"包含\",{\"1\":{\"19\":1}}],[\"业务活动管理器管理控制整个业务活动\",{\"1\":{\"63\":1}}],[\"业务系统的复杂度也将提高\",{\"1\":{\"61\":1}}],[\"要在是\",{\"1\":{\"165\":1}}],[\"要求该命令执行这个请求\",{\"1\":{\"184\":1}}],[\"要求有序\",{\"1\":{\"134\":1}}],[\"要求每个节点左右子树高度差不超过1\",{\"1\":{\"103\":1}}],[\"要求coordinator\",{\"1\":{\"77\":1}}],[\"要求confirm和cancel接口必须幂等\",{\"1\":{\"63\":1}}],[\"要求分布式系统24\",{\"1\":{\"76\":1}}],[\"要求所有节点状态一致\",{\"1\":{\"76\":1}}],[\"要求多个节点的数据副本都是一致的\",{\"1\":{\"70\":1}}],[\"要求不能出现网络分区\",{\"1\":{\"66\":1}}],[\"要使用此布局\",{\"1\":{\"0\":1}}],[\"供主业务服务调用\",{\"1\":{\"63\":1}}],[\"供消息中间件调用\",{\"1\":{\"61\":1}}],[\"从外类扩展component类的功能\",{\"1\":{\"168\":1}}],[\"从队列弹出一个对象\",{\"1\":{\"151\":1}}],[\"从磁盘传输数据时间会明显大于寻址时间\",{\"1\":{\"141\":1}}],[\"从依赖于内置堆栈的同步递归模型\",{\"1\":{\"139\":1}}],[\"从term\",{\"1\":{\"134\":1}}],[\"从业务服务必须实现try\",{\"1\":{\"63\":1}}],[\"从业务服务负责提供tcc业务操作\",{\"1\":{\"63\":1}}],[\"从而使其耦合松散\",{\"1\":{\"186\":1}}],[\"从而使你可用不同的请求对客户进行参数化\",{\"1\":{\"184\":1}}],[\"从而避免请求的发送者和接收者之间的耦合关系\",{\"1\":{\"185\":1}}],[\"从而创建一个新的对象\",{\"1\":{\"171\":1}}],[\"从而快速访问节点\",{\"1\":{\"127\":1}}],[\"从而达到数据的最终一致性\",{\"1\":{\"70\":1}}],[\"从而影响性能\",{\"1\":{\"62\":1}}],[\"从而事务完成\",{\"1\":{\"62\":1}}],[\"从而降低系统的运维成本\",{\"1\":{\"61\":1}}],[\"从而不会触发系统b的任务b\",{\"1\":{\"61\":1}}],[\"从而触发任务b的执行\",{\"1\":{\"61\":1}}],[\"从而系统出现不一致\",{\"1\":{\"61\":1}}],[\"从而消息中间件并不会向系统b投递这条消息\",{\"1\":{\"61\":1}}],[\"取消执行业务\",{\"1\":{\"63\":1}}],[\"取消执行业务操作\",{\"1\":{\"63\":1}}],[\"不足\",{\"1\":{\"188\":1}}],[\"不如用一种通用的搜索算法来解释执行一个正则表达式\",{\"1\":{\"188\":1}}],[\"不需要共享的flyweight子类\",{\"1\":{\"187\":1}}],[\"不需关心如何被添加到对象链中\",{\"1\":{\"168\":1}}],[\"不利于修改\",{\"1\":{\"176\":1}}],[\"不利于集群扩展\",{\"1\":{\"75\":1}}],[\"不便维护\",{\"1\":{\"176\":1}}],[\"不要为代码添加基于猜测的\",{\"1\":{\"184\":1}}],[\"不要做大的改动就可实现\",{\"1\":{\"170\":1}}],[\"不要求时序一致\",{\"1\":{\"69\":1}}],[\"不计算两个矢量的距离\",{\"1\":{\"156\":1}}],[\"不能对备忘录的内容进行操作或检查\",{\"1\":{\"179\":1}}],[\"不能将问题分成小问题\",{\"1\":{\"154\":1}}],[\"不能同时满足safety和liveness\",{\"1\":{\"76\":1}}],[\"不同组consumer可以消费同一topic同一分区的数据\",{\"1\":{\"143\":1}}],[\"不同于数组\",{\"1\":{\"124\":1}}],[\"不分词\",{\"1\":{\"135\":1}}],[\"不存在再加锁处理\",{\"1\":{\"182\":1}}],[\"不存在\",{\"1\":{\"120\":1}}],[\"不支持范围查找\",{\"1\":{\"115\":1}}],[\"不保证实时一致性\",{\"1\":{\"110\":1}}],[\"不保证获取的数据为最新数据\",{\"1\":{\"66\":1}}],[\"不依靠超时时间释放锁\",{\"1\":{\"97\":1}}],[\"不影响系统正常使用\",{\"1\":{\"97\":1}}],[\"不过还是比单节点redis锁耗费更多时间\",{\"1\":{\"95\":1}}],[\"不继续等待\",{\"1\":{\"88\":1}}],[\"不然会发生死锁\",{\"1\":{\"88\":1}}],[\"不断进行\",{\"1\":{\"81\":1}}],[\"不再接受id小于n的提议\",{\"1\":{\"80\":1}}],[\"不止一项提议\",{\"1\":{\"80\":1}}],[\"不会影响到使用算法的客户\",{\"1\":{\"167\":1}}],[\"不会对有关系的类造成波及\",{\"1\":{\"164\":1}}],[\"不会立即删除\",{\"1\":{\"143\":1}}],[\"不会出现重复元素\",{\"1\":{\"128\":1}}],[\"不会因为会话失效而消失\",{\"1\":{\"96\":1}}],[\"不会因为会话结束或者超时消失\",{\"1\":{\"73\":1}}],[\"不会恢复\",{\"1\":{\"76\":1}}],[\"不会无休止地进行下去\",{\"1\":{\"76\":1}}],[\"不可重入\",{\"1\":{\"73\":1,\"91\":1}}],[\"不可能一直是软状态\",{\"1\":{\"70\":1}}],[\"不允许分区\",{\"1\":{\"67\":1}}],[\"不做任何业务检查\",{\"1\":{\"63\":1}}],[\"不和用户产生直接的关联\",{\"1\":{\"61\":1}}],[\"不和任何业务系统产生直接的耦合\",{\"1\":{\"61\":1}}],[\"creator\",{\"1\":{\"170\":1}}],[\"crc32\",{\"1\":{\"143\":1}}],[\"customer通过zookeeper找到broker\",{\"1\":{\"143\":1}}],[\"currently\",{\"1\":{\"126\":1}}],[\"cfe文件保存了lucene各文件在cfs文件的位置信息\",{\"1\":{\"136\":1}}],[\"cfe\",{\"1\":{\"136\":1}}],[\"cfs\",{\"1\":{\"136\":1}}],[\"check\",{\"1\":{\"182\":1}}],[\"chain\",{\"0\":{\"185\":1}}],[\"character\",{\"1\":{\"136\":1,\"156\":1}}],[\"char\",{\"1\":{\"123\":1}}],[\"change\",{\"1\":{\"115\":1}}],[\"chosen\",{\"1\":{\"80\":1}}],[\"c时\",{\"1\":{\"83\":1}}],[\"c<z\",{\"1\":{\"83\":1}}],[\"c表示当次epoch内事务的编号\",{\"1\":{\"83\":1}}],[\"c>\",{\"1\":{\"83\":1}}],[\"cepoch\",{\"1\":{\"83\":1}}],[\"client\",{\"1\":{\"171\":1}}],[\"client发起请求\",{\"1\":{\"82\":1}}],[\"classes\",{\"1\":{\"173\":1}}],[\"classifier\",{\"1\":{\"156\":1}}],[\"class\",{\"1\":{\"108\":1}}],[\"closed\",{\"0\":{\"161\":1},\"1\":{\"161\":1}}],[\"close\",{\"1\":{\"107\":1}}],[\"clock\",{\"1\":{\"82\":1}}],[\"cluster\",{\"1\":{\"76\":1}}],[\"c又发起id为n+2的提议\",{\"1\":{\"80\":1}}],[\"c会接受该提议\",{\"1\":{\"80\":1}}],[\"c恢复后如果有proposer马上发起一项值不是v的提议\",{\"1\":{\"80\":1}}],[\"c宕机期间其他acceptor已经确定了一项值为v的决议但c因为宕机并不知晓\",{\"1\":{\"80\":1}}],[\"c宕机一段时间后恢复\",{\"1\":{\"80\":1}}],[\"colleague类\",{\"1\":{\"186\":1}}],[\"costs\",{\"1\":{\"152\":1}}],[\"core\",{\"1\":{\"140\":2}}],[\"command类\",{\"1\":{\"184\":1}}],[\"command\",{\"0\":{\"184\":1}}],[\"commit时会产生\",{\"1\":{\"137\":1}}],[\"committed\",{\"1\":{\"120\":1}}],[\"commit\",{\"0\":{\"77\":1,\"78\":1},\"1\":{\"77\":1,\"83\":1}}],[\"composite\",{\"0\":{\"180\":1},\"1\":{\"180\":1}}],[\"composition\",{\"1\":{\"165\":1}}],[\"component\",{\"1\":{\"139\":1,\"168\":1,\"180\":1}}],[\"compound\",{\"1\":{\"136\":1}}],[\"compareandswapint\",{\"1\":{\"111\":1}}],[\"compareandswapobject\",{\"1\":{\"111\":1}}],[\"com\",{\"1\":{\"120\":1}}],[\"copyonwritearraylist\",{\"0\":{\"110\":1}}],[\"copyof\",{\"1\":{\"107\":1,\"110\":1}}],[\"code\",{\"1\":{\"107\":1}}],[\"coordinator进行commit\",{\"1\":{\"78\":1}}],[\"coordinator未收到宕机participant的precommit\",{\"1\":{\"78\":1}}],[\"coordinator或watchdog未收到宕机participant的vote\",{\"1\":{\"78\":1}}],[\"coordinator如果在发起提议后宕机\",{\"1\":{\"77\":1}}],[\"coordinator\",{\"1\":{\"77\":2,\"84\":1}}],[\"concreteelement\",{\"1\":{\"189\":1}}],[\"concretevistior\",{\"1\":{\"189\":1}}],[\"concreteflyweight\",{\"1\":{\"187\":1}}],[\"concretefactory\",{\"1\":{\"176\":1}}],[\"concretemediator\",{\"1\":{\"186\":1}}],[\"concretehandler\",{\"1\":{\"185\":1}}],[\"concreteimplementora和concreteimplementorb等派生类\",{\"1\":{\"183\":1}}],[\"concreteiterator\",{\"1\":{\"181\":1}}],[\"concreteaggregate\",{\"1\":{\"181\":1}}],[\"concreteobserver\",{\"1\":{\"175\":1}}],[\"concretestate类\",{\"1\":{\"177\":1}}],[\"concretestrategy\",{\"1\":{\"167\":1}}],[\"concretesubject\",{\"1\":{\"175\":1}}],[\"concretebuilder\",{\"1\":{\"174\":1}}],[\"concreteprototype\",{\"1\":{\"171\":1}}],[\"concreteproduct\",{\"1\":{\"170\":1}}],[\"concretecolleague\",{\"1\":{\"186\":1}}],[\"concretecommand类\",{\"1\":{\"184\":1}}],[\"concretecomponent\",{\"1\":{\"168\":1}}],[\"concreteclass\",{\"1\":{\"172\":1}}],[\"concretecreator\",{\"1\":{\"170\":1}}],[\"concretedecorator\",{\"1\":{\"168\":1}}],[\"concurrency\",{\"0\":{\"120\":1}}],[\"concurrenthashmap\",{\"0\":{\"111\":1}}],[\"conquer\",{\"1\":{\"149\":1}}],[\"context\",{\"1\":{\"188\":1}}],[\"context类\",{\"1\":{\"177\":1}}],[\"context定义了\",{\"1\":{\"167\":1}}],[\"context上下文\",{\"1\":{\"167\":1}}],[\"contents\",{\"1\":{\"128\":1}}],[\"control\",{\"0\":{\"120\":1}}],[\"connection\",{\"1\":{\"75\":1}}],[\"connections\",{\"1\":{\"75\":1}}],[\"consine\",{\"1\":{\"156\":1}}],[\"consistent\",{\"1\":{\"70\":1}}],[\"consistency\",{\"1\":{\"66\":2,\"69\":2,\"71\":4,\"83\":2,\"85\":1}}],[\"consumer作为一个线程消费\",{\"1\":{\"143\":1}}],[\"consumer\",{\"1\":{\"143\":2}}],[\"conscious\",{\"1\":{\"107\":1}}],[\"const\",{\"1\":{\"19\":1}}],[\"confirm和cancel操作功能需业务提供\",{\"1\":{\"63\":1}}],[\"confirm和cancel接口\",{\"1\":{\"63\":1}}],[\"confirm\",{\"1\":{\"63\":2}}],[\"c\",{\"1\":{\"67\":1,\"111\":2,\"149\":1}}],[\"cp可以保证\",{\"1\":{\"67\":1}}],[\"cp\",{\"1\":{\"67\":1}}],[\"c必须保证\",{\"1\":{\"67\":1}}],[\"caretaker\",{\"1\":{\"179\":1}}],[\"caretaker只能看到备忘录的窄接口\",{\"1\":{\"179\":1}}],[\"carp\",{\"0\":{\"165\":1}}],[\"cache数据写入segment\",{\"1\":{\"137\":1}}],[\"cache中数据fsync到磁盘\",{\"1\":{\"137\":1}}],[\"cache中\",{\"1\":{\"137\":4}}],[\"case\",{\"1\":{\"148\":2}}],[\"cas缺点\",{\"1\":{\"111\":1}}],[\"castabat\",{\"1\":{\"111\":2}}],[\"cas\",{\"0\":{\"111\":1}}],[\"ca非0\",{\"0\":{\"69\":1}}],[\"ca\",{\"1\":{\"67\":1}}],[\"cap\",{\"1\":{\"109\":2}}],[\"capacity\",{\"1\":{\"107\":1,\"109\":10,\"111\":1}}],[\"cap理论并没有涵盖分布式工程实践中的所有重要因素\",{\"1\":{\"69\":1}}],[\"cap理论更合适的描述是\",{\"1\":{\"68\":1}}],[\"cap原则权衡\",{\"0\":{\"67\":1}}],[\"cap定理\",{\"0\":{\"66\":1}}],[\"cancel\",{\"1\":{\"63\":2}}],[\"确定实际需要的文档\",{\"1\":{\"137\":1}}],[\"确定一个值\",{\"1\":{\"81\":2}}],[\"确保事务读取到的行\",{\"1\":{\"120\":1}}],[\"确保在事务开始前已经存在或事务自身插入或修改\",{\"1\":{\"120\":1}}],[\"确保对内存读\",{\"1\":{\"111\":1}}],[\"确保消息中间件成功持久化\",{\"1\":{\"62\":1}}],[\"确认执行业务\",{\"1\":{\"63\":1}}],[\"确认执行业务操作\",{\"1\":{\"63\":1}}],[\"补偿型\",{\"0\":{\"63\":1}}],[\"如缓存对象超过空闲时间\",{\"1\":{\"194\":1}}],[\"如广播台集合\",{\"1\":{\"154\":1}}],[\"如旅行商问题中的城市序列\",{\"1\":{\"154\":1}}],[\"如旅行商问题和集合覆盖问题\",{\"1\":{\"154\":1}}],[\"如有\",{\"1\":{\"152\":1}}],[\"如队列为空\",{\"1\":{\"151\":1}}],[\"如找到\",{\"1\":{\"151\":1}}],[\"如将网址映射到ip地址\",{\"1\":{\"150\":1}}],[\"如何定期检查处于退款状态的订单是否已经退款成功\",{\"1\":{\"194\":1}}],[\"如何及时关闭订单\",{\"1\":{\"194\":1}}],[\"如何选择要看什么对你来说更重要\",{\"1\":{\"148\":1}}],[\"如何准确并高效地协调分布式并发操作也成为分布式系统架构与设计中最大的挑战之一\",{\"1\":{\"64\":1}}],[\"如int64\",{\"1\":{\"128\":1}}],[\"如int16\",{\"1\":{\"128\":1}}],[\"如使用聚簇索引\",{\"1\":{\"114\":1}}],[\"如此acceptor不能完成决议\",{\"1\":{\"80\":1}}],[\"如只有一个proposer发起提议\",{\"1\":{\"80\":1}}],[\"如延时\",{\"1\":{\"69\":1}}],[\"如多数大型互联网应用的场景\",{\"1\":{\"67\":1}}],[\"如保证cp\",{\"1\":{\"67\":1}}],[\"如涉及钱财的场景\",{\"1\":{\"67\":1}}],[\"如rocketmq\",{\"1\":{\"62\":1}}],[\"如果删除对象的外部状态\",{\"1\":{\"187\":1}}],[\"如果可处理该请求\",{\"1\":{\"185\":1}}],[\"如果可以用它封装几乎任何类型的规则\",{\"1\":{\"167\":1}}],[\"如果状态判断很简单\",{\"1\":{\"177\":1}}],[\"如果增加产品\",{\"1\":{\"176\":1}}],[\"如果其中一个类需要调用另一个类的某一个方法的话\",{\"1\":{\"164\":1}}],[\"如果两个类不必彼此直接通信\",{\"1\":{\"164\":1}}],[\"如果能够想到多于一个动机去改变一个类\",{\"1\":{\"160\":1}}],[\"如果问题可转换为集合覆盖问题或旅行商问题\",{\"1\":{\"154\":1}}],[\"如果问题涉及集合\",{\"1\":{\"154\":1}}],[\"如果问题涉及序列\",{\"1\":{\"154\":1}}],[\"如果有负权边\",{\"1\":{\"152\":1}}],[\"如果栈很高\",{\"1\":{\"148\":1}}],[\"如果使用递归\",{\"1\":{\"148\":1}}],[\"如果使用循环\",{\"1\":{\"148\":1}}],[\"如果使用非聚簇索引\",{\"1\":{\"114\":1}}],[\"如果过小\",{\"1\":{\"141\":1}}],[\"如果过大\",{\"1\":{\"141\":1}}],[\"如果每秒没有新数据到buffer\",{\"1\":{\"137\":1}}],[\"如果发现primary\",{\"1\":{\"137\":1}}],[\"如果发送失败会重试\",{\"1\":{\"62\":1}}],[\"如果field对应内容是全文检索类型\",{\"1\":{\"135\":1}}],[\"如果follower已经commit\",{\"1\":{\"83\":1}}],[\"如果follower多数派\",{\"1\":{\"82\":1}}],[\"如果块包含大于4096的值\",{\"1\":{\"134\":1}}],[\"如果事务中有其他新事务提交的新插入行\",{\"1\":{\"120\":1}}],[\"如果没有及时commit\",{\"1\":{\"119\":1}}],[\"如果没有主键会选择唯一非空索引\",{\"1\":{\"114\":1}}],[\"如果缓冲池没有\",{\"1\":{\"117\":1}}],[\"如果还是没有\",{\"1\":{\"114\":1}}],[\"如果不清楚一个系统是否需要命令模式\",{\"1\":{\"184\":1}}],[\"如果不符合\",{\"1\":{\"151\":1}}],[\"如果不存在\",{\"1\":{\"96\":1}}],[\"如果不要求a\",{\"1\":{\"67\":1}}],[\"如果不要求p\",{\"1\":{\"67\":1}}],[\"如果客户端连接失效\",{\"1\":{\"96\":1}}],[\"如果出现网络分区\",{\"1\":{\"95\":1}}],[\"如果5个节点有2个宕机\",{\"1\":{\"95\":1}}],[\"如果被更新过\",{\"1\":{\"92\":1}}],[\"如果leader先广播z\",{\"1\":{\"83\":1}}],[\"如果部分acceptor因宕机等原因未知晓已确定决议\",{\"1\":{\"80\":1}}],[\"如果决议β被acceptor多数派接受\",{\"1\":{\"80\":1}}],[\"如果proposer\",{\"1\":{\"80\":1}}],[\"如果存在acceptor最近一次\",{\"1\":{\"80\":1}}],[\"如果一种特定类型的问题发生的频率足够高\",{\"1\":{\"188\":1}}],[\"如果一项值为v的提议被确定\",{\"1\":{\"80\":3}}],[\"如果一个应用程序使用了大量的对象\",{\"1\":{\"187\":1}}],[\"如果一个已经获得锁的会话超时\",{\"1\":{\"73\":1}}],[\"如果一个实例不可用\",{\"1\":{\"73\":1}}],[\"如果一个节点从系统中读取出一个数据项的某个值后\",{\"1\":{\"71\":1}}],[\"如果是则认为获得锁\",{\"1\":{\"73\":1}}],[\"如果会话结束或者超时就会消失\",{\"1\":{\"73\":1}}],[\"如果获取失败\",{\"1\":{\"73\":1}}],[\"如果节点a在更新完某个数据后通知节点b\",{\"1\":{\"71\":1}}],[\"如果满足ca\",{\"1\":{\"66\":1}}],[\"如果满足cp\",{\"1\":{\"66\":1}}],[\"如果要实现分布式事务\",{\"1\":{\"62\":1}}],[\"如果多次重试失败\",{\"1\":{\"62\":1}}],[\"如果多次重试后仍然投递失败\",{\"1\":{\"61\":1}}],[\"如果处理速度无法满足要求\",{\"1\":{\"61\":1}}],[\"如果消息投递失败需要回滚\",{\"1\":{\"61\":1}}],[\"如果消息在投递过程中丢失\",{\"1\":{\"61\":1}}],[\"如果到了超时时间没收到系统a发来的commit或rollback指令\",{\"1\":{\"61\":1}}],[\"如果任务a处理失败\",{\"1\":{\"61\":1}}],[\"如果你不了解它\",{\"1\":{\"15\":1}}],[\"如果你是一个新手\",{\"1\":{\"14\":1}}],[\"使增加新的数据结构变得困难\",{\"1\":{\"189\":1}}],[\"使多个对象都有机会处理请求\",{\"1\":{\"185\":1}}],[\"使它们都可以独立地变化\",{\"1\":{\"183\":1}}],[\"使它们能够自动更新自己\",{\"1\":{\"175\":1}}],[\"使得操作集合可以相对自由地演化\",{\"1\":{\"189\":1}}],[\"使得程序逻辑复杂化\",{\"1\":{\"187\":1}}],[\"使得中介者会变得比任何一个concretecolleague都复杂\",{\"1\":{\"186\":1}}],[\"使得可以独立地改变和复用各个colleague类和mediator\",{\"1\":{\"186\":1}}],[\"使得原本由于接口不兼容而不能一起工作的那些类可以一起工作\",{\"1\":{\"178\":1}}],[\"使得同样的构建过程可以创建不同的表示\",{\"1\":{\"174\":1}}],[\"使得要更换对象时\",{\"1\":{\"170\":1}}],[\"使得一个用户的所有请求都路由到一个服务器节点上\",{\"1\":{\"74\":1}}],[\"使得业务系统不够纯粹\",{\"1\":{\"62\":1}}],[\"使用delayqueue保存当天将会执行的任务和执行时间\",{\"1\":{\"194\":1}}],[\"使用场景\",{\"0\":{\"194\":1}}],[\"使用其他技术如语法分析程序或编译生成器来处理\",{\"1\":{\"188\":1}}],[\"使用享元模式需要维护一个记录了系统已有的所有享元的列表\",{\"1\":{\"187\":1}}],[\"使用一个列表记录检查过的对象\",{\"1\":{\"151\":1}}],[\"使用zookeeper管理集群\",{\"1\":{\"141\":1}}],[\"使用了一些像payloads的高级特性会有该文件\",{\"1\":{\"136\":1}}],[\"使用期间不释放\",{\"1\":{\"102\":1}}],[\"使用数据库锁会增加数据库负担\",{\"1\":{\"97\":1}}],[\"使用简单\",{\"1\":{\"97\":1}}],[\"使用轮询或者加权轮询算法\",{\"1\":{\"75\":1}}],[\"使用多个redis实例实现分布式锁\",{\"1\":{\"73\":1}}],[\"使用分布式事务的成本比较低\",{\"1\":{\"60\":1}}],[\"使用指南\",{\"1\":{\"33\":2},\"2\":{\"3\":1,\"5\":1,\"8\":1,\"29\":1,\"36\":1,\"37\":1}}],[\"达到数据一致性的周期较长\",{\"1\":{\"62\":1}}],[\"就处理之\",{\"1\":{\"185\":1}}],[\"就应该考虑用组合模式\",{\"1\":{\"180\":1}}],[\"就应该考虑类的职责分离\",{\"1\":{\"160\":1}}],[\"就没必要用状态模式\",{\"1\":{\"177\":1}}],[\"就要加一个产品工厂的类\",{\"1\":{\"170\":1}}],[\"就增加功能而言\",{\"1\":{\"168\":1}}],[\"就可以从队列中取到\",{\"1\":{\"197\":1}}],[\"就可以在任何使用realsubject的地方使用proxy\",{\"1\":{\"169\":1}}],[\"就可以用策略模式处理这种变化的可能性\",{\"1\":{\"167\":1}}],[\"就可以采用这种方式\",{\"1\":{\"62\":1}}],[\"就一个类而言\",{\"1\":{\"160\":1}}],[\"就不能使用狄克斯特拉算法\",{\"1\":{\"152\":1}}],[\"就调整散列表的长度\",{\"1\":{\"150\":1}}],[\"就意味着计算机存储了大量函数调用的信息\",{\"1\":{\"148\":1}}],[\"就是用一个js对象描述一个dom节点\",{\"1\":{\"138\":1}}],[\"就失去锁的作用\",{\"1\":{\"97\":1}}],[\"就能得到具有全序关系\",{\"1\":{\"81\":1}}],[\"就需要让系统a事先提供回滚接口\",{\"1\":{\"61\":1}}],[\"即没有对facade对象的引用\",{\"1\":{\"173\":1}}],[\"即不依赖于其他子问题时\",{\"1\":{\"155\":1}}],[\"即不能满足a\",{\"1\":{\"66\":1}}],[\"即不能满足c\",{\"1\":{\"66\":1}}],[\"即先检查一度关系\",{\"1\":{\"151\":1}}],[\"即数据的列式存储\",{\"1\":{\"136\":1}}],[\"即都获得1\",{\"1\":{\"95\":1}}],[\"即向数据库中插入一条记录\",{\"1\":{\"91\":1}}],[\"即id值最大\",{\"1\":{\"80\":2}}],[\"即使coordinator或watchdog未收到宕机participant的commit\",{\"1\":{\"78\":1}}],[\"即使分布式系统各节点之间的网络通信能够正常进行\",{\"1\":{\"65\":1}}],[\"即允许系统在多个不同节点的数据副本存在数据延时\",{\"1\":{\"70\":1}}],[\"即保证p和a\",{\"1\":{\"67\":1}}],[\"即成功\",{\"1\":{\"65\":1}}],[\"即\",{\"1\":{\"62\":1,\"76\":1}}],[\"或编码类型\",{\"1\":{\"143\":1}}],[\"或标识压缩类型\",{\"1\":{\"143\":1}}],[\"或一段时间后\",{\"1\":{\"137\":1}}],[\"或称符号表symbol\",{\"1\":{\"126\":1}}],[\"或叫master\",{\"1\":{\"84\":1}}],[\"或叫线性一致性\",{\"1\":{\"83\":1}}],[\"或cohorts\",{\"1\":{\"77\":1}}],[\"或中止\",{\"1\":{\"77\":1}}],[\"或者需要保存的属性只是众多属性中的一小部分时\",{\"1\":{\"179\":1}}],[\"或者两边服务都起来\",{\"1\":{\"76\":1}}],[\"或者共享资源被瓜分\",{\"1\":{\"76\":1}}],[\"或\",{\"1\":{\"76\":1}}],[\"或被网络分隔\",{\"1\":{\"69\":1}}],[\"或服务器资源较为充裕的情况下\",{\"1\":{\"61\":1}}],[\"或消息的确认应答在返回途中丢失\",{\"1\":{\"61\":1}}],[\"同意appendentries请求\",{\"1\":{\"82\":1}}],[\"同一线程在没有释放锁之前无法再获取到锁\",{\"1\":{\"91\":1}}],[\"同一线程在没有释放锁之前无法再获得锁\",{\"1\":{\"73\":1}}],[\"同一个分布式系统中的多个节点\",{\"1\":{\"64\":1}}],[\"同时能够实现类似操作系统中对线程抢占式调度\",{\"1\":{\"139\":1}}],[\"同时将标记为delete文件删除\",{\"1\":{\"137\":1}}],[\"同时数据到shard后\",{\"1\":{\"137\":1}}],[\"同时写入translog日志文件\",{\"1\":{\"137\":1}}],[\"同时使用跳跃表和字典\",{\"1\":{\"132\":1}}],[\"同时保存为原来行作为行删除标识\",{\"1\":{\"120\":1}}],[\"同时\",{\"1\":{\"64\":1}}],[\"同时每个页面包含\",{\"1\":{\"10\":1}}],[\"同步虽然降低系统并发度\",{\"1\":{\"61\":1}}],[\"其中序列=查找message的偏移量\",{\"1\":{\"143\":1}}],[\"其中本地资源管理器往往由数据库实现\",{\"1\":{\"60\":1}}],[\"其确保网络分化情况下决议唯一\",{\"1\":{\"86\":1}}],[\"其要求每个节点对应一个序号\",{\"1\":{\"85\":1}}],[\"其表示leader紧接下来要处理的指令id以及将要发个follower的指令id\",{\"1\":{\"82\":1}}],[\"其他\",{\"0\":{\"157\":1}}],[\"其他consumer不能消费同一topic中同一分区的数据\",{\"1\":{\"143\":1}}],[\"其他线程无法再获取到锁\",{\"1\":{\"91\":1}}],[\"其他线程无法再获得锁\",{\"1\":{\"73\":1}}],[\"其他participant就进入既不能回滚\",{\"1\":{\"78\":1}}],[\"其他参与决议节点称为参与者\",{\"1\":{\"77\":1}}],[\"其他所有子节点都会收到通知\",{\"1\":{\"73\":1}}],[\"其他会话就可以获得锁\",{\"1\":{\"73\":1}}],[\"其延时也会远大于单机操作\",{\"1\":{\"65\":1}}],[\"其次\",{\"1\":{\"61\":1}}],[\"首先必须等待这两个宕机节点的结果超时才能返回\",{\"1\":{\"95\":1}}],[\"首先\",{\"1\":{\"61\":1}}],[\"首页\",{\"0\":{\"0\":1}}],[\"则说明没有符合条件的对象\",{\"1\":{\"151\":1}}],[\"则说明当前线程顺序号最小\",{\"1\":{\"96\":1}}],[\"则结束\",{\"1\":{\"151\":1}}],[\"则从磁盘读取再放入缓冲池\",{\"1\":{\"117\":1}}],[\"则根据叶子节点的主键查询聚簇索引\",{\"1\":{\"114\":1}}],[\"则叶子节点包含行数据\",{\"1\":{\"114\":1}}],[\"则立即删除节点\",{\"1\":{\"96\":1}}],[\"则获取锁失败\",{\"1\":{\"92\":1}}],[\"则继续等待获取锁\",{\"1\":{\"88\":1}}],[\"则该线程可以直接\",{\"1\":{\"88\":1}}],[\"则一项决议得到多于f节点赞成则获得通过\",{\"1\":{\"86\":1}}],[\"则q需保证已commit\",{\"1\":{\"83\":1}}],[\"则follower需保证先commit\",{\"1\":{\"83\":2}}],[\"则确定决议b\",{\"1\":{\"80\":1}}],[\"则自行commit事务\",{\"1\":{\"78\":1}}],[\"则认为锁获取成功\",{\"1\":{\"73\":1}}],[\"则需放弃一致性\",{\"1\":{\"67\":1}}],[\"则c\",{\"1\":{\"67\":1}}],[\"则不能满足p\",{\"1\":{\"66\":1}}],[\"则这条消息需要人工干预\",{\"1\":{\"61\":1}}],[\"则可以开始处理任务a\",{\"1\":{\"61\":1}}],[\"一系列可重用的算法或行为\",{\"1\":{\"167\":1}}],[\"一系列特殊编码的连续内存块组成的顺序存储结构\",{\"1\":{\"124\":1}}],[\"一类消息\",{\"1\":{\"143\":1}}],[\"一旦从delayqueue中获取到任务就开始执行\",{\"1\":{\"194\":1}}],[\"一旦填装因子大于0\",{\"1\":{\"150\":1}}],[\"一旦宕机则数据丢失\",{\"1\":{\"137\":1}}],[\"一旦分区发生\",{\"1\":{\"67\":1}}],[\"一种数据存储组织方式\",{\"1\":{\"114\":1}}],[\"一\",{\"0\":{\"90\":1}}],[\"一致\",{\"1\":{\"82\":1}}],[\"一致性问题\",{\"1\":{\"85\":1}}],[\"一致性问题是在节点宕机\",{\"1\":{\"80\":1}}],[\"一致性协议的作用具化为保证节点间操作日志副本\",{\"1\":{\"82\":1}}],[\"一致性还具备两个属性\",{\"1\":{\"76\":1}}],[\"一致性\",{\"1\":{\"63\":1,\"66\":1}}],[\"一直等待回应以完成该次决议\",{\"1\":{\"77\":1}}],[\"一个被数字\",{\"1\":{\"224\":1}}],[\"一个被星标了的苹果文章\",{\"1\":{\"204\":1}}],[\"一个最好的办法是\",{\"1\":{\"182\":1}}],[\"一个处在弱耦合的类被修改\",{\"1\":{\"164\":1}}],[\"一个数组\",{\"1\":{\"152\":1}}],[\"一个segment包含了如下表的各个文件\",{\"1\":{\"136\":1}}],[\"一个acceptor接受它收到的第一项提议\",{\"1\":{\"80\":1}}],[\"一个是可用\",{\"1\":{\"76\":1}}],[\"一个是强一致\",{\"1\":{\"76\":1}}],[\"一个节点未获得锁\",{\"1\":{\"73\":1}}],[\"一个系统要能够保证来自同一个节点的写操作顺序执行\",{\"1\":{\"71\":1}}],[\"一个分布式系统中\",{\"1\":{\"66\":1}}],[\"一个拥有\",{\"1\":{\"23\":1}}],[\"一般不要着急实现\",{\"1\":{\"184\":1}}],[\"一般要保证服务可用性达到n个9\",{\"1\":{\"67\":1}}],[\"一般部署在独立的服务器集群上\",{\"1\":{\"61\":1}}],[\"一般消息中间件可以设置消息重试的次数和时间间隔\",{\"1\":{\"61\":1}}],[\"直至发生leader宕机\",{\"1\":{\"81\":1}}],[\"直接按位与\",{\"1\":{\"134\":1}}],[\"直接返回\",{\"1\":{\"114\":1}}],[\"直接返回锁失败\",{\"1\":{\"88\":1}}],[\"直接使用数据库\",{\"1\":{\"97\":1}}],[\"直接中止事务\",{\"1\":{\"78\":1}}],[\"直接将消息丢弃\",{\"1\":{\"61\":1}}],[\"直到有一个对象处理它为止\",{\"1\":{\"185\":1}}],[\"直到lnextindex\",{\"1\":{\"82\":1}}],[\"直到participant宕机恢复\",{\"1\":{\"78\":1}}],[\"直到下游消费者返回消费成功响应为止\",{\"1\":{\"61\":1}}],[\"下单成功后60s后给用户发送短信通知\",{\"1\":{\"194\":1}}],[\"下单后三十分钟内没有付款自动取消订单\",{\"1\":{\"194\":1}}],[\"下一个\",{\"1\":{\"181\":1}}],[\"下一篇\",{\"1\":{\"4\":1}}],[\"下划线\",{\"1\":{\"158\":1}}],[\"下游系统定期查询失败消息\",{\"1\":{\"62\":1}}],[\"下游系统处理成功后\",{\"1\":{\"62\":1}}],[\"下游系统便立即进行任务处理\",{\"1\":{\"61\":1}}],[\"还有对象的大多数状态可以外部状态\",{\"1\":{\"187\":1}}],[\"还需要修改抽象工厂和具体工厂\",{\"1\":{\"176\":1}}],[\"还需提供一个事务询问的接口\",{\"1\":{\"61\":1}}],[\"还不会编写\",{\"1\":{\"14\":1}}],[\"而该算法片段是对应结构中对象的类\",{\"1\":{\"189\":1}}],[\"而大量的这些对象造成很大的存储开销时就应该考虑使用\",{\"1\":{\"187\":1}}],[\"而又不想生成太多子类的场合\",{\"1\":{\"186\":1}}],[\"而又不暴露该对象的内部表示\",{\"1\":{\"181\":1}}],[\"而无需指定它们具体的类\",{\"1\":{\"176\":1}}],[\"而无需重新获得锁\",{\"1\":{\"88\":1}}],[\"而将一些步骤延迟到子类中\",{\"1\":{\"172\":1}}],[\"而比较角度\",{\"1\":{\"156\":1}}],[\"而操作真实dom非常耗费性能\",{\"1\":{\"138\":1}}],[\"而在另一端进行删除操作的线性结构\",{\"0\":{\"102\":1}}],[\"而我们希望尽量所有acceptor的状态一致\",{\"1\":{\"80\":1}}],[\"而我们只希望它的后一个子节点收到通知\",{\"1\":{\"73\":1}}],[\"而另一台服务器连接过小\",{\"1\":{\"75\":1}}],[\"而另一些节点不能\",{\"1\":{\"65\":1}}],[\"而不了解其他同事类的情况\",{\"1\":{\"186\":1}}],[\"而不需保持它所有的候选接受者的引用\",{\"1\":{\"185\":1}}],[\"而不知道具体有多少对象要改变\",{\"1\":{\"175\":1}}],[\"而不会看到旧值\",{\"1\":{\"71\":1}}],[\"而不是可选项\",{\"1\":{\"68\":1}}],[\"而不投递给系统b\",{\"1\":{\"61\":1}}],[\"而这样会导致全局数据的不一致性\",{\"1\":{\"67\":1}}],[\"而p\",{\"1\":{\"67\":1}}],[\"而是不断尝试重新投递\",{\"1\":{\"61\":1}}],[\"而且可以独立地改变他们之间的交互\",{\"1\":{\"186\":1}}],[\"而且不管这些对象是什么都需要遍历时\",{\"1\":{\"181\":1}}],[\"而且消息中间件产生的时延导致事务短暂的不一致是可以接受的\",{\"1\":{\"61\":1}}],[\"而且能降低上游系统的阻塞时间\",{\"1\":{\"61\":1}}],[\"而且一旦商业数据库实现xa协议\",{\"1\":{\"60\":1}}],[\"因proposer需要问询该信息以决定提议值\",{\"1\":{\"80\":1}}],[\"因为新的操作意味着一个新的访问者\",{\"1\":{\"189\":1}}],[\"因为定义抽象语法树中各个节点的类实现大体类似\",{\"1\":{\"188\":1}}],[\"因为该模式使用类来表示文法规则\",{\"1\":{\"188\":1}}],[\"因为flyweight接口共享成为可能\",{\"1\":{\"187\":1}}],[\"因为实现容易\",{\"1\":{\"153\":1}}],[\"因为浏览器的标准把dom设计得非常复杂\",{\"1\":{\"138\":1}}],[\"因为要频繁创建删除节点\",{\"1\":{\"97\":1}}],[\"因为watch只能被触发一次\",{\"1\":{\"96\":1}}],[\"因为唯一索引insert都会返回失败\",{\"1\":{\"91\":1}}],[\"因为创建的是临时节点\",{\"1\":{\"73\":1}}],[\"因为经过短暂的时间后\",{\"1\":{\"61\":1}}],[\"因果一致性causal\",{\"1\":{\"71\":1}}],[\"因而分布式系统实现中p是一个必须项\",{\"1\":{\"68\":1}}],[\"因此包含许多规则的文法可能难以管理和维护\",{\"1\":{\"188\":1}}],[\"因此新增具体命令类很容易\",{\"1\":{\"184\":1}}],[\"因此需要执行特殊行为时\",{\"1\":{\"168\":1}}],[\"因此任何交互\",{\"1\":{\"139\":1}}],[\"因此ca系统更多的是允许分区后各子系统依然保持ca\",{\"1\":{\"67\":1}}],[\"因此消息丢失和消息延迟变得非常普遍\",{\"1\":{\"65\":1}}],[\"因此网络通信都会伴随着网络不可用的风险或是系统不可用都会导致最终分布式系统无法顺利完成一次网络通信\",{\"1\":{\"65\":1}}],[\"因此可以借助于\",{\"1\":{\"16\":1}}],[\"因此\",{\"1\":{\"13\":1,\"61\":1,\"62\":1}}],[\"告诉消息中间件该消息已成功消费\",{\"1\":{\"61\":1}}],[\"系统如何知道该信息\",{\"1\":{\"194\":1}}],[\"系统的数据和行为都正确\",{\"1\":{\"178\":1}}],[\"系统往往因为不断重构演化而变得越来越复杂\",{\"1\":{\"173\":1}}],[\"系统版本号会自动递增\",{\"1\":{\"120\":1}}],[\"系统崩溃数据恢复\",{\"1\":{\"115\":1}}],[\"系统要求高可靠性时\",{\"1\":{\"97\":1}}],[\"系统保证在同一个有效的会话中实现\",{\"1\":{\"71\":1}}],[\"系统负载\",{\"1\":{\"70\":1}}],[\"系统提供的服务必须一直处于可用状态\",{\"1\":{\"66\":1}}],[\"系统又可以保持数据一致性\",{\"1\":{\"61\":1}}],[\"系统a除了实现正常的业务流程外\",{\"1\":{\"61\":1}}],[\"系统a完成任务a后\",{\"1\":{\"61\":1}}],[\"系统a收到确认应答后\",{\"1\":{\"61\":1}}],[\"系统b向消息中间件返回一个确认应答\",{\"1\":{\"61\":1}}],[\"7天后删除\",{\"1\":{\"143\":1}}],[\"75f\",{\"1\":{\"109\":1}}],[\"7无间断对外服务\",{\"1\":{\"76\":1}}],[\"7\",{\"1\":{\"61\":1,\"150\":1}}],[\"6844903648397525006\",{\"1\":{\"193\":1}}],[\"64\",{\"1\":{\"109\":1}}],[\"6\",{\"1\":{\"61\":1,\"73\":1,\"75\":1,\"109\":1}}],[\"可访问它的后继者\",{\"1\":{\"185\":1}}],[\"可复用\",{\"1\":{\"161\":1}}],[\"可扩展\",{\"1\":{\"161\":1}}],[\"可维护\",{\"1\":{\"161\":1}}],[\"可使用继承来改变或扩展该文法\",{\"1\":{\"188\":1}}],[\"可使用解释器模式\",{\"1\":{\"188\":1}}],[\"可使用\",{\"1\":{\"153\":1}}],[\"可使用贪婪算法\",{\"1\":{\"153\":1}}],[\"可使用贝尔曼\",{\"1\":{\"152\":1}}],[\"可使用redis和memcached内存型数据库对session进行存储\",{\"1\":{\"74\":1}}],[\"可选\",{\"1\":{\"143\":1}}],[\"可忽略不计\",{\"1\":{\"139\":1}}],[\"可重入锁\",{\"0\":{\"110\":1}}],[\"可重入一个线程中可以多次获取同一把锁\",{\"1\":{\"88\":1}}],[\"可靠性高\",{\"1\":{\"97\":1}}],[\"可能有不同的实现\",{\"1\":{\"176\":1}}],[\"可能系统已经非常难以维护和扩展\",{\"1\":{\"173\":1}}],[\"可能是\",{\"1\":{\"154\":3}}],[\"可能出现客户端永远无法获取锁的情况\",{\"1\":{\"95\":1}}],[\"可能出现获取锁冲突\",{\"1\":{\"95\":1}}],[\"可能会造成其他事务长时间等待\",{\"1\":{\"119\":1}}],[\"可能会让一台服务器当前连接数过大\",{\"1\":{\"75\":1}}],[\"可能会并发地操作一些共享的资源\",{\"1\":{\"64\":1}}],[\"可节省prepare步骤\",{\"1\":{\"81\":1}}],[\"可结束\",{\"1\":{\"76\":1}}],[\"可用一致性hash改进\",{\"1\":{\"75\":1}}],[\"可用\",{\"1\":{\"67\":1}}],[\"可用性\",{\"1\":{\"66\":1,\"67\":1}}],[\"可通过重试机制+定期校对实现分布式事务\",{\"1\":{\"62\":1}}],[\"可由消息中间件的事务回查机制完成\",{\"1\":{\"61\":1}}],[\"可以提供一个高层接口以允许访问者访问它的元素\",{\"1\":{\"189\":1}}],[\"可以容易实现对请求的撤销和重做\",{\"1\":{\"184\":1}}],[\"可以把复杂的判断逻辑简化\",{\"1\":{\"177\":1}}],[\"可以把用户的session存放在该服务器节点中\",{\"1\":{\"74\":1}}],[\"可以增加和删除观察者对象\",{\"1\":{\"175\":1}}],[\"可以增加机器解决\",{\"1\":{\"61\":1}}],[\"可以为新系统开发一个外观facade类\",{\"1\":{\"173\":1}}],[\"可以隐藏一个对象存在不同地址空间的事实\",{\"1\":{\"169\":1}}],[\"可以给对象动态添加职责\",{\"1\":{\"168\":1}}],[\"可以去除相关类中重复的装饰逻辑\",{\"1\":{\"168\":1}}],[\"可以在运行时根据需要使用装饰功能包装对象\",{\"1\":{\"168\":1}}],[\"可以通过第三者转发这个调用\",{\"1\":{\"164\":1}}],[\"可以实例出不同类型的虚拟dom节点\",{\"1\":{\"140\":1}}],[\"可以用js模拟出一个dom节点\",{\"1\":{\"138\":1}}],[\"可以保存int16\",{\"1\":{\"128\":1}}],[\"可以保证\",{\"1\":{\"67\":1}}],[\"可以是数字或字符串\",{\"1\":{\"124\":1}}],[\"可以注册一个该节点的监视器\",{\"1\":{\"96\":1}}],[\"可以选择同步来降低系统复杂度\",{\"1\":{\"61\":1}}],[\"可以处理别的任务\",{\"1\":{\"61\":1}}],[\"可以使用资源管理器提供的事务接口来实现分布式事务\",{\"1\":{\"59\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"13\":1}}],[\"但并不强制共享\",{\"1\":{\"187\":1}}],[\"但并不投递\",{\"1\":{\"61\":1}}],[\"但它们却都认识中介者对象\",{\"1\":{\"186\":1}}],[\"但需要维护或记录属性历史的类\",{\"1\":{\"179\":1}}],[\"但接口不符时\",{\"1\":{\"178\":1}}],[\"但对象内部的构建通常面临着复杂的变化\",{\"1\":{\"174\":1}}],[\"但对于component来说\",{\"1\":{\"168\":1}}],[\"但其个别步骤在更详细的层次上的实现可能不同时\",{\"1\":{\"172\":1}}],[\"但b对象不是a对象的一部分\",{\"1\":{\"165\":1}}],[\"但随着元素数量的增加\",{\"1\":{\"154\":1}}],[\"但存在丢失数据的风险\",{\"1\":{\"135\":1}}],[\"但查询分值复杂度o\",{\"1\":{\"132\":1}}],[\"但不能防止实例化多个对象\",{\"1\":{\"182\":1}}],[\"但不能很好避免\",{\"1\":{\"95\":1}}],[\"但不可修改\",{\"1\":{\"161\":1}}],[\"但不支持降级操作\",{\"1\":{\"128\":1}}],[\"但是接口又与复用环境要求不一致的情况\",{\"1\":{\"178\":1}}],[\"但是存储详尽的信息可能占用大量的内存\",{\"1\":{\"148\":1}}],[\"但是无序\",{\"1\":{\"132\":1}}],[\"但是执行发现此记录已存在\",{\"1\":{\"120\":1}}],[\"但是相比方案2\",{\"1\":{\"62\":1}}],[\"但在网络拥塞或瞬断的情况下\",{\"1\":{\"87\":1}}],[\"但一般不想让这样情况发生\",{\"1\":{\"80\":1}}],[\"但因为之前已经收到宕机participant的赞成反馈\",{\"1\":{\"78\":1}}],[\"但同时读写共享存储\",{\"1\":{\"76\":1}}],[\"但分区始终会存在\",{\"1\":{\"67\":1}}],[\"但实现成本较低\",{\"1\":{\"61\":1}}],[\"但会增加系统复杂度\",{\"1\":{\"61\":1}}],[\"但异步通信可能引起commit\",{\"1\":{\"61\":1}}],[\"但短暂的不一致性是可以接受的\",{\"1\":{\"61\":1}}],[\"但commit消息可能会在传输途中丢失\",{\"1\":{\"61\":1}}],[\"该解释器通过解释这些句子来解决该问题\",{\"1\":{\"188\":1}}],[\"该方法中又调用了另一个需要相同锁的方法\",{\"1\":{\"88\":1}}],[\"该租约同时对应一个有效时长\",{\"1\":{\"87\":1}}],[\"该结果必须由n个节点中的节点提出\",{\"1\":{\"76\":1}}],[\"该分布式事务完成\",{\"1\":{\"61\":1}}],[\"该事务的处理过程结束\",{\"1\":{\"61\":1}}],[\"该请求发送完成后\",{\"1\":{\"61\":1}}],[\"向具体同事对象发出命令\",{\"1\":{\"186\":1}}],[\"向含有该文档的分片请求\",{\"1\":{\"137\":1}}],[\"向表中插入一条记录\",{\"1\":{\"73\":1}}],[\"向消息中间件反馈确认应答\",{\"1\":{\"62\":1}}],[\"向消息中间件同步发送一条消息\",{\"1\":{\"62\":1}}],[\"向消息中间件发送commit请求\",{\"1\":{\"61\":1}}],[\"向系统b投递该消息\",{\"1\":{\"61\":1}}],[\"向系统a返回一个确认应答\",{\"1\":{\"61\":1}}],[\"5\",{\"1\":{\"61\":1,\"73\":1,\"75\":1,\"95\":1,\"96\":1}}],[\"4\",{\"0\":{\"214\":1,\"234\":1},\"1\":{\"61\":1,\"73\":1,\"74\":1,\"75\":1,\"95\":1,\"96\":1,\"109\":2,\"122\":2,\"143\":3,\"169\":1}}],[\"此模式定义了一个高层接口\",{\"1\":{\"173\":1}}],[\"此模式让算法的变化\",{\"1\":{\"167\":1}}],[\"此单单词重复利用\",{\"1\":{\"134\":1}}],[\"此时锁的可用性会极大降低\",{\"1\":{\"95\":1}}],[\"此时\",{\"1\":{\"61\":1}}],[\"此时下游系统b仍然不知道该消息的存在\",{\"1\":{\"61\":1}}],[\"此文字有脚注^first\",{\"1\":{\"24\":1}}],[\"在网络协议滑动窗口请求应答式交互时\",{\"1\":{\"194\":1}}],[\"在网络分化的场景下bully算法会遇到一个问题\",{\"1\":{\"86\":1}}],[\"在需要的情况下\",{\"1\":{\"184\":1}}],[\"在第一次被引用时\",{\"1\":{\"182\":1}}],[\"在类加载时就实例化\",{\"1\":{\"182\":1}}],[\"在类的结构设计上\",{\"1\":{\"164\":1}}],[\"在component接口中实现与子部件有关的操作\",{\"1\":{\"180\":1}}],[\"在commit前\",{\"1\":{\"137\":1}}],[\"在组合中表示叶节点对象\",{\"1\":{\"180\":1}}],[\"在适当情况下\",{\"1\":{\"180\":1}}],[\"在不破坏封装性的前提下\",{\"1\":{\"179\":1}}],[\"在得到主题的通知时更新自己\",{\"1\":{\"175\":1}}],[\"在具体主题的内部状态改变时\",{\"1\":{\"175\":1}}],[\"在分析过程中需要在不同时间应用不同的业务规则\",{\"1\":{\"167\":1}}],[\"在分布式系统中最常见\",{\"1\":{\"76\":1}}],[\"在编写处理字符串的程序或网页时\",{\"1\":{\"158\":1}}],[\"在给定约束条件下最大限度改善指定的指标\",{\"1\":{\"157\":1}}],[\"在获得精确解需要时间太长\",{\"1\":{\"153\":1}}],[\"在\",{\"1\":{\"143\":1}}],[\"在primary\",{\"1\":{\"137\":1}}],[\"在segment小的时候\",{\"1\":{\"136\":1}}],[\"在另外的posting\",{\"1\":{\"134\":1}}],[\"在事务开始之前未被删除\",{\"1\":{\"120\":1}}],[\"在加锁前必须先取得该表的意向锁\",{\"1\":{\"119\":1}}],[\"在允许偶发的锁失效的情况\",{\"1\":{\"97\":1}}],[\"在实践应用中\",{\"1\":{\"87\":1}}],[\"在一定期限内给予节点特定权利\",{\"1\":{\"84\":1}}],[\"在一定时间内要达到节点状态一致\",{\"1\":{\"66\":1}}],[\"在leader选举的场景下帮助我们选出唯一leader\",{\"1\":{\"84\":1}}],[\"在n+1提议未完成前proposer\",{\"1\":{\"80\":1}}],[\"在提议未完成前proposer\",{\"1\":{\"80\":1}}],[\"在回应提议id为n的proposer自己曾接受过id最大的提议时\",{\"1\":{\"80\":1}}],[\"在确定并只确定一个值可以保证一致性\",{\"1\":{\"80\":1}}],[\"在watchdog启用前一个participant又宕机\",{\"1\":{\"78\":1}}],[\"在2pc中一个participant的状态只有它自己和coordinator知晓\",{\"1\":{\"78\":1}}],[\"在最少连接的基础上\",{\"1\":{\"75\":1}}],[\"在服务器节点上进行session同步操作\",{\"1\":{\"74\":1}}],[\"在节点状态发生改变时\",{\"1\":{\"73\":1}}],[\"在期限后\",{\"1\":{\"70\":1}}],[\"在调用端看来服务可用\",{\"1\":{\"69\":1}}],[\"在被调完成操作响应后的某个时间点\",{\"1\":{\"69\":1}}],[\"在b操作后如果所有调用端操作得到a操作的结果\",{\"1\":{\"69\":1}}],[\"在满足分区容错的前提下\",{\"1\":{\"68\":1}}],[\"在某时刻如果满足ap\",{\"1\":{\"66\":1}}],[\"在极端情况下\",{\"1\":{\"65\":1}}],[\"在系统设计时不能放过任何异常情况\",{\"1\":{\"64\":1}}],[\"在系统a处理任务a前\",{\"1\":{\"61\":1}}],[\"在业务活动取消时调用所有tcc型操作的cancel操作\",{\"1\":{\"63\":1}}],[\"在上游系统建立一张本地消息表\",{\"1\":{\"62\":1}}],[\"在对并发度要求不要的情况下\",{\"1\":{\"61\":1}}],[\"在保证性能的前提下\",{\"1\":{\"61\":1}}],[\"在这个时间差内\",{\"1\":{\"61\":1}}],[\"在页面禁用功能与布局\",{\"1\":{\"4\":1}}],[\"许多nosql也没有支持xa\",{\"1\":{\"60\":1}}],[\"往往并发量很高\",{\"1\":{\"60\":1}}],[\"回滚等能力\",{\"1\":{\"59\":1}}],[\"回滚等能力提供给事务管理器调用\",{\"1\":{\"59\":1}}],[\"将有关行为集中到一个访问者对象\",{\"1\":{\"189\":1}}],[\"将有关状态存入具体观察者对象\",{\"1\":{\"175\":1}}],[\"将中介作为一个独立的概念并封装在一个对象中\",{\"1\":{\"186\":1}}],[\"将这个对象连成一条链\",{\"1\":{\"185\":1}}],[\"将这个对象的所有邻居都加入队列\",{\"1\":{\"151\":1}}],[\"将抽象部分与它的实现部分分离\",{\"1\":{\"183\":1}}],[\"将对象组合成树形结构以表示\",{\"1\":{\"180\":1}}],[\"将对系统数据的访问过程框定在一个会话中\",{\"1\":{\"71\":1}}],[\"将程序由编译时转为运行时\",{\"1\":{\"176\":1}}],[\"将一个接收者对象绑定于一个动作\",{\"1\":{\"184\":1}}],[\"将一个请求封装为一个对象\",{\"1\":{\"184\":1}}],[\"将一个类的接口转换成客户希望的另一个接口\",{\"1\":{\"178\":1}}],[\"将一个复杂对象的构建与它的表示分离\",{\"1\":{\"174\":1}}],[\"将一个commit\",{\"1\":{\"137\":1}}],[\"将客户的请求代理给适当的子系统对象\",{\"1\":{\"173\":1}}],[\"将答案写下来\",{\"1\":{\"155\":1}}],[\"将问题写下来\",{\"1\":{\"155\":1}}],[\"将当前指针指向workinprogress\",{\"1\":{\"139\":1}}],[\"将任务分片\",{\"1\":{\"139\":1}}],[\"将任务处理过程和向本地消息表插入消息放在一个本地事务完成\",{\"1\":{\"62\":1}}],[\"将virtual\",{\"1\":{\"139\":1}}],[\"将广播请求到搜索的每一个节点的分片拷贝\",{\"1\":{\"137\":1}}],[\"将新segment\",{\"1\":{\"137\":1}}],[\"将多个segment\",{\"1\":{\"137\":1}}],[\"将定期执行merge操作\",{\"1\":{\"137\":1}}],[\"将原来的doc标识为delete状态\",{\"1\":{\"137\":1}}],[\"将doc标记为delete状态\",{\"1\":{\"137\":1}}],[\"将translog文件清空\",{\"1\":{\"137\":1}}],[\"将term\",{\"1\":{\"134\":1}}],[\"将os\",{\"1\":{\"137\":1}}],[\"将buffer数据refresh到新的os\",{\"1\":{\"137\":1}}],[\"将请求转发给对应的node处理\",{\"1\":{\"137\":1}}],[\"将posting\",{\"1\":{\"134\":1}}],[\"将大数变小数\",{\"1\":{\"134\":1}}],[\"将磁盘里的东西尽量搬进内存\",{\"1\":{\"134\":1}}],[\"将ht\",{\"1\":{\"126\":1}}],[\"将产生多个leader\",{\"1\":{\"86\":1}}],[\"将提议的节点称为协调者\",{\"1\":{\"77\":1}}],[\"将n个节点隔离成多个部分\",{\"1\":{\"76\":1}}],[\"将session信息持久化到一个数据库中\",{\"1\":{\"74\":1}}],[\"将丢失该服务器节点上的所有session\",{\"1\":{\"74\":1}}],[\"将导致状态不一致\",{\"1\":{\"66\":1}}],[\"将其消费\",{\"1\":{\"62\":1}}],[\"将本数据库的提交\",{\"1\":{\"59\":1}}],[\"将你的个人介绍和档案放置在此处\",{\"1\":{\"1\":1}}],[\"资源管理器能够提供单数据库的事务能力\",{\"1\":{\"59\":1}}],[\"rn中各个符号的实例变量\",{\"1\":{\"188\":1}}],[\"rn都需要一个具体的非终结符表达式类\",{\"1\":{\"188\":1}}],[\"r2\",{\"1\":{\"188\":2}}],[\"running\",{\"1\":{\"126\":1}}],[\"rabbitmq\",{\"0\":{\"144\":1},\"1\":{\"198\":1}}],[\"raw编码\",{\"1\":{\"123\":1}}],[\"raw\",{\"1\":{\"122\":1}}],[\"race\",{\"1\":{\"111\":1}}],[\"raft要求具备唯一leader\",{\"1\":{\"82\":1}}],[\"raft中leader为自己和所有follower各维护一个nextindex值\",{\"1\":{\"82\":1}}],[\"raft\",{\"0\":{\"82\":1}}],[\"random\",{\"1\":{\"75\":1}}],[\"rocketmq\",{\"0\":{\"145\":1}}],[\"roaring\",{\"1\":{\"134\":1}}],[\"robj\",{\"1\":{\"122\":1,\"127\":1}}],[\"robin\",{\"1\":{\"75\":2}}],[\"rollback\",{\"1\":{\"119\":1}}],[\"rollback指令丢失的问题\",{\"1\":{\"61\":1}}],[\"rollback指令而导致的系统不一致情况\",{\"1\":{\"61\":1}}],[\"roundrobin\",{\"1\":{\"143\":1}}],[\"round\",{\"1\":{\"75\":2}}],[\"rm具体的实现是由数据库厂商来完成\",{\"1\":{\"59\":1}}],[\"rm\",{\"1\":{\"59\":1}}],[\"receiver类\",{\"1\":{\"184\":1}}],[\"recursive\",{\"1\":{\"148\":1}}],[\"recognition\",{\"1\":{\"156\":1}}],[\"reconciler\",{\"1\":{\"139\":3}}],[\"reconciliation\",{\"1\":{\"139\":1}}],[\"recover\",{\"1\":{\"76\":1}}],[\"realsubject类\",{\"1\":{\"169\":1}}],[\"reactinternaltypes\",{\"1\":{\"139\":1}}],[\"react基于组件开发\",{\"1\":{\"139\":1}}],[\"react\",{\"0\":{\"138\":1,\"139\":1},\"1\":{\"139\":1}}],[\"read\",{\"1\":{\"71\":2,\"120\":4}}],[\"rehashing\",{\"1\":{\"126\":1}}],[\"rehashidx\",{\"1\":{\"126\":2}}],[\"rehash索引\",{\"1\":{\"126\":1}}],[\"rehash操作\",{\"1\":{\"126\":1}}],[\"repeatable\",{\"1\":{\"120\":1}}],[\"replication\",{\"1\":{\"69\":1,\"74\":1,\"82\":1}}],[\"replica\",{\"1\":{\"64\":1,\"86\":1}}],[\"refinedabstraction类\",{\"1\":{\"183\":1}}],[\"refresh\",{\"1\":{\"137\":1}}],[\"refman\",{\"1\":{\"120\":1}}],[\"reference\",{\"1\":{\"59\":1,\"134\":1}}],[\"reentrantlock\",{\"1\":{\"110\":1}}],[\"responsibility\",{\"0\":{\"185\":1}}],[\"resolution\",{\"1\":{\"150\":1}}],[\"resource\",{\"1\":{\"59\":1}}],[\"resize\",{\"1\":{\"109\":1}}],[\"return\",{\"1\":{\"109\":3,\"110\":1,\"111\":4}}],[\"reduce\",{\"1\":{\"157\":1}}],[\"redisobject\",{\"0\":{\"122\":1},\"1\":{\"122\":1}}],[\"redis\",{\"0\":{\"121\":1},\"1\":{\"198\":1}}],[\"redis的redlock算法\",{\"1\":{\"73\":1}}],[\"redis的setnx指令\",{\"1\":{\"73\":1}}],[\"redo\",{\"0\":{\"116\":1,\"117\":1},\"1\":{\"117\":3}}],[\"redo日志\",{\"1\":{\"115\":1}}],[\"redlock采用通过冲突后在随机时间开始\",{\"1\":{\"95\":1}}],[\"redlock算法相对于单节点redis锁可靠性更高\",{\"1\":{\"95\":1}}],[\"redlock算法\",{\"0\":{\"95\":1}}],[\"regarded\",{\"1\":{\"32\":1}}],[\"以一个访问者为参数\",{\"1\":{\"189\":1}}],[\"以实现execute\",{\"1\":{\"184\":1}}],[\"以实现分布式事务\",{\"1\":{\"59\":1}}],[\"以及想定制一个分布在多个类中的行为\",{\"1\":{\"186\":1}}],[\"以及支持可撤销的操作\",{\"1\":{\"184\":1}}],[\"以及它们之间的关系和操作等相关问题\",{\"1\":{\"98\":1}}],[\"以相同方式调用所有算法\",{\"1\":{\"167\":1}}],[\"以难解著称的问题\",{\"1\":{\"154\":1}}],[\"以<商\",{\"1\":{\"134\":1}}],[\"以\",{\"1\":{\"123\":1}}],[\"以此实现相较paxos而言更容易理解\",{\"1\":{\"82\":1}}],[\"以此类推\",{\"1\":{\"73\":1}}],[\"以term作为逻辑时钟\",{\"1\":{\"82\":1}}],[\"以上决议过程都只要求acceptor多数派参与\",{\"1\":{\"80\":1}}],[\"以确保消息成功发布给消息中间件\",{\"1\":{\"62\":1}}],[\"以帮助事务管理器实现分布式事务管理\",{\"1\":{\"59\":1}}],[\"以便使本身的状态与主题的状态相协调\",{\"1\":{\"175\":1}}],[\"以便\",{\"1\":{\"13\":1}}],[\"会面临多线程访问的安全性问题\",{\"1\":{\"182\":1}}],[\"会通知所有观察者对象\",{\"1\":{\"175\":1}}],[\"会写一个commit\",{\"1\":{\"137\":1}}],[\"会写入translog\",{\"1\":{\"137\":1}}],[\"会触发commit操作\",{\"1\":{\"137\":1}}],[\"会创建新的空segment\",{\"1\":{\"137\":1}}],[\"会有该文件\",{\"1\":{\"136\":1}}],[\"会进行分词\",{\"1\":{\"135\":1}}],[\"会进行数组扩容\",{\"1\":{\"109\":1}}],[\"会把集合里的元素数据类型转换成大的类型\",{\"1\":{\"128\":1}}],[\"会检查内存空间再进行字符串修改\",{\"1\":{\"123\":1}}],[\"会产生很多segment\",{\"1\":{\"137\":1}}],[\"会产生幻读\",{\"1\":{\"120\":1}}],[\"会产生空间开销\",{\"1\":{\"102\":1}}],[\"会给符合条件的已有数据记录索引项加锁\",{\"1\":{\"119\":1}}],[\"会给客户端发送消息\",{\"1\":{\"73\":1}}],[\"会记录对数据文件修改的物理位置或偏移量\",{\"1\":{\"115\":1}}],[\"会自动在节点名后加一个数字后缀\",{\"1\":{\"96\":1}}],[\"会发生严重后果\",{\"1\":{\"76\":1}}],[\"会话超时\",{\"1\":{\"73\":1}}],[\"会话一致性\",{\"1\":{\"71\":1}}],[\"会在节点名的后面加一个数字后缀\",{\"1\":{\"73\":1}}],[\"会到每个实例上释放锁\",{\"1\":{\"73\":1}}],[\"会导致同步时间无限延长\",{\"1\":{\"67\":1}}],[\"会影响消息的收发的过程\",{\"1\":{\"65\":1}}],[\"会主动调用系统a提供的事务询问接口询问系统目前的状态\",{\"1\":{\"61\":1}}],[\"会向消息中间件发送rollback请求\",{\"1\":{\"61\":1}}],[\"会存在一定的时间差\",{\"1\":{\"61\":1}}],[\"会提供分布式事务的操作接口供业务系统调用\",{\"1\":{\"59\":1}}],[\"会使用\",{\"1\":{\"16\":1}}],[\"dp\",{\"1\":{\"167\":1}}],[\"dpe\",{\"1\":{\"167\":2}}],[\"dag\",{\"1\":{\"152\":1}}],[\"data\",{\"1\":{\"111\":1,\"124\":1,\"136\":3,\"143\":1}}],[\"datastore\",{\"1\":{\"74\":2}}],[\"dns\",{\"1\":{\"150\":1}}],[\"d\",{\"1\":{\"149\":1,\"158\":2}}],[\"dvm\",{\"1\":{\"136\":1}}],[\"dvd\",{\"1\":{\"136\":1}}],[\"director\",{\"1\":{\"174\":1}}],[\"directed\",{\"1\":{\"152\":1}}],[\"divide\",{\"1\":{\"149\":1}}],[\"diffe\",{\"1\":{\"157\":1}}],[\"diff策略\",{\"1\":{\"140\":1}}],[\"diff策略建立在节点操作都在节点树同一层级中进行\",{\"1\":{\"139\":1}}],[\"diff\",{\"1\":{\"139\":3}}],[\"diff算法策略\",{\"1\":{\"139\":1}}],[\"diff算法计算出需要更新的地方\",{\"1\":{\"138\":1}}],[\"dictionary\",{\"1\":{\"136\":1}}],[\"dictionary的block位置\",{\"1\":{\"134\":1}}],[\"dictionary的block之间的映射关系\",{\"1\":{\"134\":1}}],[\"dictentry\",{\"1\":{\"126\":4}}],[\"dictht\",{\"1\":{\"126\":3}}],[\"dicttype\",{\"1\":{\"126\":1}}],[\"dict\",{\"1\":{\"126\":3}}],[\"distribution链表长度等于8的概率约为0\",{\"1\":{\"109\":1}}],[\"distributed\",{\"1\":{\"59\":1}}],[\"discovery\",{\"1\":{\"83\":1}}],[\"dup\",{\"1\":{\"125\":1}}],[\"dynamic\",{\"0\":{\"123\":1},\"1\":{\"123\":1}}],[\"dom树的最少操作过程称为协调\",{\"1\":{\"139\":1}}],[\"dom树转换成actual\",{\"1\":{\"139\":1}}],[\"documents\",{\"1\":{\"136\":1}}],[\"document\",{\"1\":{\"136\":2}}],[\"docvalues\",{\"1\":{\"135\":1}}],[\"doc\",{\"1\":{\"120\":1,\"135\":2,\"136\":1}}],[\"doublewrite\",{\"1\":{\"115\":1}}],[\"double\",{\"1\":{\"109\":1,\"127\":1,\"139\":1,\"182\":1}}],[\"decorator\",{\"0\":{\"168\":1},\"1\":{\"168\":1}}],[\"description\",{\"1\":{\"136\":1}}],[\"delayqueue中存放的对象需要实现compareto\",{\"1\":{\"197\":1}}],[\"delayqueue\",{\"0\":{\"197\":1}}],[\"del文件\",{\"1\":{\"137\":1}}],[\"delete\",{\"1\":{\"120\":1}}],[\"deliver\",{\"1\":{\"83\":1}}],[\"dev\",{\"1\":{\"120\":1}}],[\"defaults\",{\"1\":{\"109\":1}}],[\"default\",{\"1\":{\"107\":1,\"109\":6,\"111\":1}}],[\"db2都实现了xa接口\",{\"1\":{\"60\":1}}],[\"dtp只是一套实现分布式事务的规范\",{\"1\":{\"59\":1}}],[\"dtp是由x\",{\"1\":{\"59\":1}}],[\"dtp模型\",{\"0\":{\"59\":1}}],[\"分别封装起来\",{\"1\":{\"167\":1}}],[\"分别在内存和磁盘\",{\"1\":{\"117\":1}}],[\"分而治之\",{\"1\":{\"149\":1}}],[\"分为master和regionserver\",{\"1\":{\"141\":1}}],[\"分为事务管理器和本地资源管理器\",{\"1\":{\"60\":1}}],[\"分页等操作\",{\"1\":{\"137\":1}}],[\"分词\",{\"1\":{\"136\":1}}],[\"分值小的靠近表头\",{\"1\":{\"132\":1}}],[\"分值\",{\"1\":{\"127\":1}}],[\"分多次渐进式rehash\",{\"1\":{\"126\":1}}],[\"分配空间\",{\"1\":{\"126\":1}}],[\"分组\",{\"1\":{\"114\":1}}],[\"分区个数\",{\"1\":{\"143\":1}}],[\"分区\",{\"1\":{\"67\":1,\"143\":1}}],[\"分区容错性\",{\"1\":{\"66\":1}}],[\"分隔的节点同时对外服务但不能相互通信\",{\"1\":{\"66\":1}}],[\"分布性\",{\"1\":{\"64\":1}}],[\"分布式\",{\"0\":{\"240\":1}}],[\"分布式数据库\",{\"1\":{\"141\":1}}],[\"分布式可扩展\",{\"1\":{\"134\":1}}],[\"分布式session\",{\"0\":{\"74\":1}}],[\"分布式锁比较\",{\"0\":{\"97\":1}}],[\"分布式锁需要具备哪些条件\",{\"0\":{\"88\":1}}],[\"分布式锁实现方式\",{\"0\":{\"89\":1}}],[\"分布式锁实现\",{\"1\":{\"73\":1}}],[\"分布式锁\",{\"0\":{\"73\":1}}],[\"分布式理论\",{\"0\":{\"66\":1}}],[\"分布式系统大多数瓶颈都在数据库\",{\"1\":{\"97\":1}}],[\"分布式系统在遇到任何网络分区故障时\",{\"1\":{\"66\":1}}],[\"分布式系统的每一次请求与响应\",{\"1\":{\"65\":1}}],[\"分布式系统会出现局部小集群\",{\"1\":{\"65\":1}}],[\"分布式系统需要在各个节点之间进行网络通信\",{\"1\":{\"65\":1}}],[\"分布式系统面临的问题\",{\"0\":{\"65\":1}}],[\"分布式系统缺乏一个全局的时钟序列控制\",{\"1\":{\"64\":1}}],[\"分布式系统中的计算机没有主从之分\",{\"1\":{\"64\":1}}],[\"分布式系统中的多台计算机之间在空间位置上可以随意分布\",{\"1\":{\"64\":1}}],[\"分布式系统主要特征\",{\"1\":{\"64\":1}}],[\"分布式架构\",{\"0\":{\"64\":1}}],[\"分布式事务的实现由事务管理器来完成\",{\"1\":{\"59\":1}}],[\"分布式事务\",{\"0\":{\"58\":1,\"72\":1}}],[\"分类为\",{\"1\":{\"33\":1}}],[\"蔬菜\",{\"2\":{\"56\":1}}],[\"番茄\",{\"0\":{\"53\":1}}],[\"草莓\",{\"0\":{\"48\":1},\"2\":{\"51\":1}}],[\"大话设计模式\",{\"0\":{\"159\":1}}],[\"大量小文件会占用namenode大量内存存储元数据\",{\"1\":{\"141\":1}}],[\"大的靠近表尾\",{\"1\":{\"132\":1}}],[\"大部分场景下\",{\"1\":{\"59\":1}}],[\"大\",{\"2\":{\"47\":1,\"203\":1,\"208\":1,\"213\":1,\"218\":1}}],[\"水果\",{\"2\":{\"46\":1,\"51\":1,\"212\":1,\"217\":1,\"222\":1,\"227\":1}}],[\"火龙果\",{\"0\":{\"43\":1},\"2\":{\"46\":1}}],[\"圆\",{\"2\":{\"42\":1,\"57\":1,\"203\":1,\"208\":1,\"213\":1,\"218\":1}}],[\"小\",{\"2\":{\"42\":1,\"52\":1}}],[\"红色节点子节点一定是黑色\",{\"1\":{\"103\":1}}],[\"红黑树要求任何一条路径长度不超过其他路径长度2倍\",{\"1\":{\"103\":1}}],[\"红黑树\",{\"1\":{\"103\":1}}],[\"红\",{\"2\":{\"42\":1,\"47\":1,\"52\":1,\"57\":1,\"203\":1,\"208\":1,\"213\":1,\"218\":1}}],[\"31\",{\"1\":{\"111\":1}}],[\"3pc\",{\"0\":{\"78\":1}}],[\"3\",{\"0\":{\"40\":1,\"45\":1,\"50\":1,\"55\":1,\"201\":1,\"206\":1,\"209\":1,\"211\":1,\"216\":1,\"221\":1,\"226\":1,\"229\":1,\"231\":1,\"236\":1},\"1\":{\"61\":1,\"62\":1,\"63\":1,\"73\":1,\"74\":1,\"75\":1,\"83\":2,\"91\":1,\"95\":1,\"96\":1,\"169\":1}}],[\"樱桃\",{\"0\":{\"38\":1},\"2\":{\"41\":1}}],[\"+delayed\",{\"1\":{\"197\":1}}],[\"+\",{\"0\":{\"111\":1},\"1\":{\"35\":1,\"107\":1,\"109\":1,\"110\":1,\"111\":2,\"158\":1}}],[\"这样可以构建一个解释器\",{\"1\":{\"188\":1}}],[\"这样以后就可将该对象恢复到原先保存的状态\",{\"1\":{\"179\":1}}],[\"这样类和类继承层次会保持较小规模\",{\"1\":{\"165\":1}}],[\"这时将从follower操作日志中最初不一致的地方开始\",{\"1\":{\"82\":1}}],[\"这与p2a矛盾\",{\"1\":{\"80\":1}}],[\"这是因为如果监听所有子节点\",{\"1\":{\"73\":1}}],[\"这是一种硬状态\",{\"1\":{\"70\":1}}],[\"这是一个博客主页的案例\",{\"1\":{\"0\":1}}],[\"这个接口为抽象语法树总所有的节点所共享\",{\"1\":{\"188\":1}}],[\"这个接口使得这一子系统更加容易使用\",{\"1\":{\"173\":1}}],[\"这个解释器使用该表示来解释语言中的句子\",{\"1\":{\"188\":1}}],[\"这个类可以保证没有其他实例可以被创建\",{\"1\":{\"182\":1}}],[\"这个实例定义当前的状态\",{\"1\":{\"177\":1}}],[\"这个对象看起来像是改变了其类\",{\"1\":{\"177\":1}}],[\"这个主题对象在状态发生变化时\",{\"1\":{\"175\":1}}],[\"这个时间期限取决于网络延时\",{\"1\":{\"70\":1}}],[\"这个现象称为网络分区\",{\"1\":{\"65\":1}}],[\"这两个因素都会导致partition\",{\"1\":{\"68\":1}}],[\"这三个基本需求\",{\"1\":{\"66\":1}}],[\"这就对分布式一致性提出挑战\",{\"1\":{\"65\":1}}],[\"这些对象内部构建间的建造顺序通常是稳定的\",{\"1\":{\"174\":1}}],[\"这些局部小集群会独立完成原本需要整个分布式才能完成的功能\",{\"1\":{\"65\":1}}],[\"这些接口称为tx接口\",{\"1\":{\"59\":1}}],[\"这种超时询问机制能够防止上游系统因在传输过程中丢失commit\",{\"1\":{\"61\":1}}],[\"这里是内容\",{\"1\":{\"39\":1,\"40\":1,\"44\":1,\"45\":1,\"49\":1,\"50\":1,\"54\":1,\"55\":1,\"200\":1,\"201\":1,\"205\":1,\"206\":1,\"210\":1,\"211\":1,\"215\":1,\"216\":1,\"220\":1,\"221\":1,\"225\":1,\"226\":1,\"230\":1,\"231\":1,\"235\":1,\"236\":1}}],[\"这意味着你可以在\",{\"1\":{\"35\":1}}],[\"日\",{\"1\":{\"33\":1}}],[\"月\",{\"1\":{\"33\":1}}],[\"年\",{\"1\":{\"33\":1}}],[\"ptr\",{\"1\":{\"122\":1,\"125\":3}}],[\"per\",{\"1\":{\"115\":1,\"134\":1,\"136\":2}}],[\"persistent\",{\"1\":{\"74\":1}}],[\"putval\",{\"1\":{\"111\":1}}],[\"public\",{\"1\":{\"34\":1,\"110\":1}}],[\"px\",{\"0\":{\"94\":1},\"1\":{\"94\":1}}],[\"p先于leader\",{\"1\":{\"83\":2}}],[\"p广播\",{\"1\":{\"83\":2}}],[\"point\",{\"1\":{\"137\":1}}],[\"point写入到磁盘文件\",{\"1\":{\"137\":1}}],[\"poisson\",{\"1\":{\"109\":1}}],[\"posts\",{\"0\":{\"239\":1}}],[\"post\",{\"1\":{\"193\":1}}],[\"posting\",{\"1\":{\"134\":1}}],[\"position\",{\"1\":{\"136\":2}}],[\"positions\",{\"1\":{\"136\":1}}],[\"pos\",{\"1\":{\"136\":1}}],[\"pool\",{\"1\":{\"117\":1}}],[\"power\",{\"1\":{\"111\":1}}],[\"po\",{\"1\":{\"83\":1}}],[\"placed\",{\"1\":{\"109\":1}}],[\"pl和follower完成状态同步后pl变成正式leader\",{\"1\":{\"83\":1}}],[\"pl补齐相比follower多数派缺失的状态\",{\"1\":{\"83\":1}}],[\"pl收集follower\",{\"1\":{\"83\":1}}],[\"plugin\",{\"1\":{\"18\":1}}],[\"principle\",{\"0\":{\"161\":1}}],[\"privdata\",{\"1\":{\"126\":1}}],[\"private\",{\"1\":{\"107\":2,\"108\":1,\"111\":6}}],[\"prevlengh\",{\"1\":{\"124\":1}}],[\"prev\",{\"1\":{\"108\":1,\"125\":1}}],[\"prepare阶段proposer发起提议问询提议值\",{\"1\":{\"80\":1}}],[\"prototype\",{\"0\":{\"171\":1},\"1\":{\"171\":1}}],[\"protocol\",{\"0\":{\"83\":1}}],[\"product\",{\"1\":{\"170\":1,\"176\":1}}],[\"producer\",{\"1\":{\"143\":1}}],[\"producer生产数据\",{\"1\":{\"143\":1}}],[\"proxy类\",{\"1\":{\"169\":1}}],[\"proxy\",{\"0\":{\"169\":1}}],[\"problem\",{\"1\":{\"151\":1}}],[\"progress\",{\"1\":{\"126\":1}}],[\"prospective\",{\"1\":{\"83\":1}}],[\"promise\",{\"1\":{\"80\":1}}],[\"proposal\",{\"1\":{\"80\":1}}],[\"proposer\",{\"1\":{\"80\":1,\"81\":1}}],[\"proposer发起的每项提议分别用一个id标识\",{\"1\":{\"80\":1}}],[\"proposer和acceptor需满足\",{\"1\":{\"80\":1}}],[\"propose+precommit+commit\",{\"1\":{\"78\":1}}],[\"propose\",{\"1\":{\"77\":1}}],[\"processing\",{\"1\":{\"59\":1}}],[\"p2b约束的是提议被确定后proposer的行为\",{\"1\":{\"80\":1}}],[\"p2b\",{\"1\":{\"80\":1}}],[\"p2a\",{\"1\":{\"80\":1}}],[\"p2\",{\"1\":{\"80\":1}}],[\"p1\",{\"1\":{\"80\":1}}],[\"phase\",{\"0\":{\"77\":1,\"78\":1}}],[\"p\",{\"1\":{\"67\":1}}],[\"parents\",{\"1\":{\"152\":1}}],[\"participant记录历史状态\",{\"1\":{\"77\":1}}],[\"participants\",{\"1\":{\"77\":1}}],[\"partition物理上由多个segment组成\",{\"1\":{\"143\":1}}],[\"partition里的message不会重分配\",{\"1\":{\"143\":1}}],[\"partition中每个message只能被一个组中的consumer消费\",{\"1\":{\"143\":1}}],[\"partitioned\",{\"1\":{\"76\":1}}],[\"partition\",{\"1\":{\"66\":2,\"76\":1,\"143\":2}}],[\"path\",{\"1\":{\"151\":1}}],[\"patch\",{\"1\":{\"140\":1}}],[\"packages\",{\"1\":{\"139\":1}}],[\"payload\",{\"1\":{\"143\":1}}],[\"payloads\",{\"1\":{\"136\":2}}],[\"pay\",{\"1\":{\"136\":1}}],[\"paxos中leader的存在是为了提升决议效率\",{\"1\":{\"82\":1}}],[\"paxos中有助于提升性能\",{\"1\":{\"81\":1}}],[\"paxos先把节点分为两类\",{\"1\":{\"80\":1}}],[\"paxos的核心是节点间如何确定并只确定一个值\",{\"1\":{\"80\":1}}],[\"paxos协议在节点宕机恢复\",{\"1\":{\"79\":1}}],[\"paxos\",{\"0\":{\"79\":1,\"80\":1,\"81\":1}}],[\"page\",{\"1\":{\"32\":1}}],[\"bfs\",{\"0\":{\"151\":1}}],[\"bitset\",{\"1\":{\"134\":1}}],[\"bitmaps\",{\"1\":{\"134\":1}}],[\"bin\",{\"1\":{\"111\":1}}],[\"bincount\",{\"1\":{\"111\":2}}],[\"bytes\",{\"1\":{\"143\":1}}],[\"byte\",{\"1\":{\"134\":1,\"143\":8}}],[\"byzantine\",{\"1\":{\"76\":1}}],[\"banana\",{\"0\":{\"244\":1}}],[\"bayes\",{\"1\":{\"156\":1}}],[\"balance\",{\"1\":{\"143\":1}}],[\"backward\",{\"1\":{\"127\":1}}],[\"base\",{\"1\":{\"148\":1}}],[\"base理论\",{\"0\":{\"70\":1}}],[\"basic\",{\"0\":{\"80\":1}}],[\"basically\",{\"1\":{\"70\":1}}],[\"builder\",{\"0\":{\"174\":1},\"1\":{\"174\":1}}],[\"buf\",{\"1\":{\"123\":3}}],[\"buffering\",{\"1\":{\"139\":1}}],[\"buffer内容就清空\",{\"1\":{\"137\":1}}],[\"buffer快满\",{\"1\":{\"137\":1}}],[\"buffer里面数据搜索不到\",{\"1\":{\"137\":1}}],[\"buffer\",{\"1\":{\"115\":2,\"117\":1}}],[\"bully算法是最常见的选举算法\",{\"1\":{\"85\":1}}],[\"boolean\",{\"1\":{\"110\":1,\"111\":2}}],[\"b+树\",{\"0\":{\"114\":1},\"1\":{\"103\":1}}],[\"b树\",{\"1\":{\"103\":1}}],[\"b\",{\"0\":{\"114\":1},\"1\":{\"87\":1,\"158\":2}}],[\"bridge\",{\"0\":{\"183\":1}}],[\"brief\",{\"1\":{\"136\":1}}],[\"breadth\",{\"0\":{\"151\":1}}],[\"break\",{\"1\":{\"111\":2}}],[\"broker\",{\"1\":{\"143\":1}}],[\"broadcast三个阶段\",{\"1\":{\"83\":1}}],[\"broadcast\",{\"0\":{\"83\":1},\"1\":{\"83\":1}}],[\"brain\",{\"1\":{\"76\":1}}],[\"b又发起id为n+1的提议\",{\"1\":{\"80\":1}}],[\"b3\",{\"1\":{\"80\":1}}],[\"b2\",{\"1\":{\"80\":1}}],[\"b1\",{\"1\":{\"80\":1}}],[\"blockingqueue+priorityqueue\",{\"1\":{\"197\":1}}],[\"block\",{\"1\":{\"77\":1}}],[\"bloghome\",{\"1\":{\"0\":1}}],[\"bellman\",{\"1\":{\"152\":1}}],[\"beat\",{\"1\":{\"87\":1}}],[\"be\",{\"1\":{\"32\":1}}],[\"feyman\",{\"1\":{\"155\":1}}],[\"fdt\",{\"1\":{\"136\":1}}],[\"fdx\",{\"1\":{\"136\":1}}],[\"fnm\",{\"1\":{\"136\":1}}],[\"fnextindex相等\",{\"1\":{\"82\":1}}],[\"frequencies\",{\"1\":{\"136\":1}}],[\"free\",{\"1\":{\"123\":1,\"125\":1}}],[\"frame\",{\"1\":{\"134\":1}}],[\"from\",{\"1\":{\"119\":2}}],[\"frontmatter\",{\"1\":{\"4\":1,\"10\":1,\"15\":3,\"32\":1,\"33\":1}}],[\"fh\",{\"1\":{\"111\":2}}],[\"f\",{\"1\":{\"111\":5}}],[\"ford\",{\"1\":{\"152\":1}}],[\"forward\",{\"1\":{\"127\":1}}],[\"for\",{\"1\":{\"111\":1,\"119\":1,\"161\":2}}],[\"follower多数派通过之后leader发起将状态变更落地\",{\"1\":{\"83\":1}}],[\"follower间状态不一致\",{\"1\":{\"82\":1}}],[\"follower状态机按相同顺序执行指令\",{\"1\":{\"82\":1}}],[\"facade与遗留代码交互所有复杂的工作\",{\"1\":{\"173\":1}}],[\"facade\",{\"0\":{\"173\":1},\"1\":{\"173\":1}}],[\"factory\",{\"0\":{\"170\":1,\"176\":1}}],[\"factor\",{\"1\":{\"109\":2}}],[\"failure\",{\"1\":{\"76\":1}}],[\"fail\",{\"1\":{\"76\":2}}],[\"flyweightfactory对象提供一个已创建的实例或者创建一个\",{\"1\":{\"187\":1}}],[\"flyweightfactory\",{\"1\":{\"187\":1}}],[\"flyweight可以接受并作用于外部状态\",{\"1\":{\"187\":1}}],[\"flyweight类\",{\"1\":{\"187\":1}}],[\"flyweight\",{\"0\":{\"187\":1}}],[\"flush\",{\"1\":{\"137\":1}}],[\"float\",{\"1\":{\"109\":1}}],[\"flp\",{\"1\":{\"76\":1}}],[\"flp定理\",{\"1\":{\"76\":1}}],[\"fiber\",{\"1\":{\"139\":2}}],[\"fields\",{\"1\":{\"136\":1}}],[\"field\",{\"1\":{\"135\":1,\"136\":2}}],[\"finite\",{\"1\":{\"134\":1}}],[\"finally\",{\"1\":{\"110\":1,\"111\":1}}],[\"final\",{\"1\":{\"107\":1,\"109\":8,\"110\":1,\"111\":8}}],[\"file写入磁盘\",{\"1\":{\"137\":1}}],[\"file合并为一个\",{\"1\":{\"137\":1}}],[\"file文件\",{\"1\":{\"137\":1}}],[\"files\",{\"1\":{\"115\":1}}],[\"file\",{\"1\":{\"115\":2,\"136\":2,\"137\":4,\"143\":3}}],[\"fifo\",{\"1\":{\"83\":1}}],[\"first\",{\"0\":{\"151\":1},\"1\":{\"32\":1,\"108\":1}}],[\"xa目前商业数据库支持比较理想\",{\"1\":{\"60\":1}}],[\"xa无法满足高并发场景\",{\"1\":{\"60\":1}}],[\"xa协议比较简单\",{\"1\":{\"60\":1}}],[\"xa是一个分布式事务协议\",{\"1\":{\"60\":1}}],[\"xa是dtp模型定义的接口\",{\"1\":{\"59\":1}}],[\"x\",{\"1\":{\"26\":1,\"59\":1}}],[\"标识所有新的segment\",{\"1\":{\"137\":1}}],[\"标识对应的所有segment\",{\"1\":{\"137\":1}}],[\"标识rehash完成\",{\"1\":{\"126\":1}}],[\"标签为\",{\"1\":{\"33\":1}}],[\"标题\",{\"0\":{\"39\":1,\"40\":1,\"44\":1,\"45\":1,\"49\":1,\"50\":1,\"54\":1,\"55\":1,\"200\":1,\"201\":1,\"205\":1,\"206\":1,\"210\":1,\"211\":1,\"215\":1,\"216\":1,\"220\":1,\"221\":1,\"225\":1,\"226\":1,\"230\":1,\"231\":1,\"235\":1,\"236\":1}}],[\"标题会被视为页面标题\",{\"1\":{\"32\":1}}],[\"标题和页面信息\",{\"1\":{\"10\":1}}],[\"标记\",{\"0\":{\"25\":1}}],[\"脚注\",{\"0\":{\"24\":1}}],[\"的层次结构\",{\"1\":{\"180\":1}}],[\"的关系时再考虑使用\",{\"1\":{\"165\":1}}],[\"的问题通常是np完全问题\",{\"1\":{\"154\":1}}],[\"的算法\",{\"1\":{\"151\":1}}],[\"的整数\",{\"1\":{\"128\":2}}],[\"的思路帮助我们在网络分化的情况下达成决议一致性\",{\"1\":{\"84\":1}}],[\"的系列值\",{\"1\":{\"81\":1}}],[\"的过程称为实例\",{\"1\":{\"81\":1}}],[\"的过程\",{\"1\":{\"81\":1}}],[\"的一方为proposer\",{\"1\":{\"80\":1}}],[\"的一致性\",{\"1\":{\"71\":1}}],[\"的效果\",{\"1\":{\"69\":1}}],[\"的\",{\"1\":{\"23\":1,\"32\":1,\"33\":1}}],[\"im\",{\"1\":{\"193\":1}}],[\"implementor类\",{\"1\":{\"183\":1}}],[\"impossibility\",{\"1\":{\"76\":1}}],[\"ix\",{\"1\":{\"119\":1}}],[\"ib\",{\"1\":{\"115\":1}}],[\"ibd文件\",{\"1\":{\"115\":1}}],[\"ibdata\",{\"1\":{\"115\":1}}],[\"is\",{\"1\":{\"107\":2,\"119\":1,\"165\":1}}],[\"if\",{\"1\":{\"107\":2,\"109\":4,\"111\":9,\"126\":1}}],[\"ip\",{\"1\":{\"75\":1}}],[\"i\",{\"1\":{\"35\":1,\"111\":7}}],[\"invoker类\",{\"1\":{\"184\":1}}],[\"inverted\",{\"1\":{\"135\":1,\"157\":1}}],[\"information\",{\"1\":{\"136\":2}}],[\"info\",{\"1\":{\"136\":1}}],[\"innodb行锁\",{\"1\":{\"119\":1}}],[\"innodb表元数据\",{\"1\":{\"115\":1}}],[\"innodb\",{\"1\":{\"114\":1,\"115\":2,\"120\":1}}],[\"inittable\",{\"1\":{\"111\":2}}],[\"initialization\",{\"1\":{\"111\":1}}],[\"initial\",{\"1\":{\"109\":6}}],[\"into\",{\"1\":{\"136\":1}}],[\"int8\",{\"1\":{\"128\":1}}],[\"int32\",{\"1\":{\"128\":1}}],[\"int64\",{\"1\":{\"126\":1,\"128\":1}}],[\"int编码\",{\"1\":{\"123\":1}}],[\"intset编码\",{\"1\":{\"131\":1}}],[\"intset\",{\"1\":{\"122\":1,\"128\":2}}],[\"interpreter\",{\"0\":{\"188\":1}}],[\"intention\",{\"1\":{\"119\":1}}],[\"integer\",{\"1\":{\"109\":1,\"111\":1}}],[\"int\",{\"1\":{\"107\":4,\"109\":13,\"110\":1,\"111\":10,\"122\":1,\"123\":2,\"125\":1,\"126\":2,\"127\":2}}],[\"insert\",{\"1\":{\"120\":1}}],[\"insert失败直接报错\",{\"1\":{\"91\":1}}],[\"instance\",{\"1\":{\"81\":1}}],[\"index文件中有两列\",{\"1\":{\"143\":1}}],[\"index查到对应term\",{\"1\":{\"134\":1}}],[\"index缓存到内存\",{\"1\":{\"134\":1}}],[\"index由shard组成\",{\"1\":{\"134\":1}}],[\"index\",{\"1\":{\"82\":1,\"109\":1,\"135\":1,\"136\":3,\"143\":1,\"157\":1}}],[\"in\",{\"1\":{\"32\":1,\"74\":1,\"109\":1,\"115\":1,\"119\":1,\"126\":1,\"136\":1}}],[\"id列表和term在doc中的词频\",{\"1\":{\"136\":1}}],[\"id\",{\"1\":{\"23\":1,\"80\":1}}],[\"iterator\",{\"0\":{\"181\":1},\"1\":{\"181\":1}}],[\"iterators\",{\"1\":{\"126\":2}}],[\"item\",{\"1\":{\"108\":1}}],[\"it\",{\"1\":{\"16\":2}}],[\"我在右对齐\",{\"1\":{\"22\":1}}],[\"我是居中的\",{\"1\":{\"22\":1}}],[\"handler\",{\"1\":{\"185\":1}}],[\"hash分区\",{\"1\":{\"143\":1}}],[\"hashtable编码\",{\"1\":{\"130\":1,\"131\":1}}],[\"hashtable节点\",{\"1\":{\"126\":1}}],[\"hashtable\",{\"1\":{\"122\":1}}],[\"hash索引\",{\"0\":{\"115\":1}}],[\"hashcode\",{\"1\":{\"109\":1,\"111\":1}}],[\"hash取余计算综合高位低位\",{\"1\":{\"109\":1}}],[\"hashmap\",{\"0\":{\"109\":1}}],[\"hash\",{\"0\":{\"150\":1},\"1\":{\"75\":1,\"109\":2,\"111\":4,\"122\":1,\"143\":1,\"157\":1}}],[\"hdfs中凭据寻址时间大概为10ms\",{\"1\":{\"141\":1}}],[\"hdfs块block设置\",{\"1\":{\"141\":1}}],[\"hbase\",{\"0\":{\"141\":1}}],[\"ht\",{\"1\":{\"126\":1}}],[\"html\",{\"1\":{\"120\":1}}],[\"https\",{\"1\":{\"120\":1,\"193\":1}}],[\"hellman密钥交换\",{\"1\":{\"157\":1}}],[\"helptransfer\",{\"1\":{\"111\":1}}],[\"header\",{\"1\":{\"127\":1}}],[\"head\",{\"1\":{\"125\":1}}],[\"heart\",{\"1\":{\"87\":1}}],[\"h\",{\"1\":{\"109\":3,\"126\":1}}],[\"hugecapacity\",{\"1\":{\"107\":1}}],[\"hope\",{\"1\":{\"33\":1}}],[\"home\",{\"1\":{\"0\":1}}],[\"h1\",{\"1\":{\"32\":2}}],[\"h2o\",{\"1\":{\"21\":1}}],[\"上游系统向消息中间件发送消息失败\",{\"1\":{\"62\":1}}],[\"上游系统向消息中间件投递消息是异步\",{\"1\":{\"61\":1}}],[\"上游系统在完成任务后\",{\"1\":{\"62\":1}}],[\"上游系统和消息中间件之间采用异步通信是为了提高系统并发度和用户体验\",{\"1\":{\"61\":1}}],[\"上下角标\",{\"0\":{\"21\":1}}],[\"上一篇\",{\"1\":{\"4\":1}}],[\"详情容器\",{\"1\":{\"19\":1}}],[\"危险容器\",{\"1\":{\"19\":1}}],[\"警告容器\",{\"1\":{\"19\":1}}],[\"==\",{\"1\":{\"109\":2,\"111\":10,\"126\":1}}],[\"=\",{\"1\":{\"19\":1,\"107\":6,\"109\":18,\"110\":5,\"111\":24}}],[\"adaptee\",{\"1\":{\"178\":1}}],[\"adapter\",{\"0\":{\"178\":1},\"1\":{\"178\":1}}],[\"additional\",{\"1\":{\"136\":1}}],[\"adding\",{\"1\":{\"111\":1}}],[\"addcount\",{\"1\":{\"111\":1}}],[\"add\",{\"1\":{\"110\":1}}],[\"aggregate\",{\"1\":{\"181\":1}}],[\"aggregation\",{\"1\":{\"165\":1}}],[\"agreement\",{\"1\":{\"76\":1}}],[\"algorithm\",{\"1\":{\"152\":1,\"153\":1,\"155\":1,\"157\":1}}],[\"and\",{\"1\":{\"136\":1,\"149\":1}}],[\"ak\",{\"1\":{\"111\":2}}],[\"abstractexpression\",{\"1\":{\"188\":1}}],[\"abstraction类\",{\"1\":{\"183\":1}}],[\"abstractproduct\",{\"1\":{\"176\":1}}],[\"abstractfactory\",{\"1\":{\"176\":1}}],[\"abstract\",{\"0\":{\"176\":1}}],[\"abstractclass\",{\"1\":{\"172\":1}}],[\"about\",{\"1\":{\"136\":1}}],[\"abort\",{\"1\":{\"77\":1}}],[\"abase\",{\"1\":{\"111\":4}}],[\"arrayindexscale\",{\"1\":{\"111\":1}}],[\"arraybaseoffset\",{\"1\":{\"111\":1}}],[\"arrays\",{\"1\":{\"107\":1,\"110\":1}}],[\"array\",{\"1\":{\"107\":1,\"126\":1}}],[\"arraylist\",{\"0\":{\"107\":1}}],[\"avl树是严格平衡二叉树\",{\"1\":{\"103\":1}}],[\"avl树\",{\"1\":{\"103\":1}}],[\"available\",{\"1\":{\"70\":1}}],[\"availability\",{\"1\":{\"66\":2}}],[\"attributes\",{\"1\":{\"143\":1}}],[\"attrs\",{\"0\":{\"23\":1}}],[\"atomic\",{\"0\":{\"83\":1}}],[\"a发起id为n的提议\",{\"1\":{\"80\":1}}],[\"acyclic\",{\"1\":{\"152\":1}}],[\"accept阶段完成决议\",{\"1\":{\"80\":1}}],[\"acceptor\",{\"1\":{\"81\":1}}],[\"acceptor回应问询并进行promise\",{\"1\":{\"80\":1}}],[\"acceptor完成一轮决议可归纳为prepare和accept两个阶段\",{\"1\":{\"80\":1}}],[\"acceptor同时保证\",{\"1\":{\"80\":1}}],[\"acceptor的多数派中如果存在acceptor最近一次\",{\"1\":{\"80\":1}}],[\"acceptor的多数派s中\",{\"1\":{\"80\":1}}],[\"acceptor满足以下3点\",{\"1\":{\"80\":1}}],[\"acceptor需要做到\",{\"1\":{\"80\":1}}],[\"acceptor接受一项提议时被确定\",{\"1\":{\"80\":1}}],[\"acceptor可以接受\",{\"1\":{\"80\":1}}],[\"accept\",{\"1\":{\"80\":1}}],[\"ack\",{\"1\":{\"78\":2}}],[\"a操作先于b操作\",{\"1\":{\"69\":1}}],[\"apple\",{\"0\":{\"243\":1}}],[\"application应用系统\",{\"1\":{\"59\":1}}],[\"approximation\",{\"1\":{\"153\":1}}],[\"append\",{\"1\":{\"82\":1}}],[\"ap\",{\"1\":{\"59\":1,\"67\":1}}],[\"asd\",{\"1\":{\"160\":1}}],[\"ashift\",{\"1\":{\"111\":4}}],[\"asynchronous\",{\"1\":{\"69\":1,\"76\":1}}],[\"as\",{\"1\":{\"32\":1,\"136\":1}}],[\"a\",{\"1\":{\"19\":1,\"67\":1,\"87\":1,\"107\":1,\"111\":1,\"136\":1,\"165\":1}}],[\"与其为每一个特定需求都写一个算法函数\",{\"1\":{\"188\":1}}],[\"与永久节点相反\",{\"1\":{\"96\":1}}],[\"与此同时\",{\"1\":{\"71\":1}}],[\"与用户体验直接相关的一项重要指标\",{\"1\":{\"69\":1}}],[\"与\",{\"1\":{\"19\":1}}],[\"信息容器\",{\"1\":{\"19\":1}}],[\"visitor\",{\"0\":{\"189\":1},\"1\":{\"189\":1}}],[\"view判断当前版本数据的可见性\",{\"1\":{\"120\":1}}],[\"v为顶点\",{\"1\":{\"151\":1}}],[\"v+e\",{\"1\":{\"151\":1}}],[\"vnode\",{\"1\":{\"140\":1}}],[\"vnode类\",{\"1\":{\"140\":1}}],[\"vdom\",{\"1\":{\"140\":2}}],[\"v16版本是fiber\",{\"1\":{\"139\":1}}],[\"v16版本前协调机制是stack\",{\"1\":{\"139\":1}}],[\"vertice\",{\"1\":{\"151\":1}}],[\"versioning\",{\"1\":{\"120\":1}}],[\"vector\",{\"1\":{\"136\":1}}],[\"v>\",{\"1\":{\"109\":2,\"111\":16}}],[\"volatile\",{\"1\":{\"111\":2}}],[\"void\",{\"1\":{\"107\":1,\"122\":1,\"125\":7,\"126\":3}}],[\"vote\",{\"1\":{\"77\":1}}],[\"v\",{\"1\":{\"80\":2,\"111\":5,\"126\":1}}],[\"val\",{\"1\":{\"126\":1}}],[\"value和时间戳组成\",{\"1\":{\"143\":1}}],[\"values\",{\"1\":{\"136\":1}}],[\"value键值对以紧密相连的方式放入\",{\"1\":{\"130\":1}}],[\"value\",{\"1\":{\"80\":2,\"109\":1,\"111\":3,\"125\":1,\"134\":1,\"143\":1}}],[\"validity\",{\"1\":{\"76\":1}}],[\"variables\",{\"1\":{\"115\":2}}],[\"variable\",{\"1\":{\"19\":1}}],[\"vue\",{\"0\":{\"138\":1,\"140\":1},\"1\":{\"35\":2}}],[\"vuepress\",{\"0\":{\"17\":1},\"1\":{\"13\":2,\"15\":2,\"16\":1,\"17\":2,\"18\":1,\"34\":1}}],[\"提前占用系统资源\",{\"1\":{\"182\":1}}],[\"提升决议效率\",{\"1\":{\"84\":1}}],[\"提升系统的并发度\",{\"1\":{\"61\":1}}],[\"提议统一由leader发起\",{\"1\":{\"80\":1}}],[\"提议被确定前proposer应该怎么做\",{\"1\":{\"80\":1}}],[\"提议的组成因此变为\",{\"1\":{\"80\":1}}],[\"提供一种方法顺序访问一个聚合对象中各个元素\",{\"1\":{\"181\":1}}],[\"提供一种树形结构的命名空间\",{\"1\":{\"73\":1}}],[\"提供一个创建一系列相关或相互依赖对象的接口\",{\"1\":{\"176\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"18\":1}}],[\"提示容器\",{\"0\":{\"19\":1},\"1\":{\"19\":1}}],[\"mediator的出现减少了各个colleague的耦合\",{\"1\":{\"186\":1}}],[\"mediator类\",{\"1\":{\"186\":1}}],[\"mediator\",{\"0\":{\"186\":1}}],[\"memento模式比较适用于功能比较复杂的\",{\"1\":{\"179\":1}}],[\"memento\",{\"0\":{\"179\":1},\"1\":{\"179\":1}}],[\"memory\",{\"1\":{\"74\":1}}],[\"method\",{\"0\":{\"170\":1}}],[\"metadata\",{\"1\":{\"136\":1}}],[\"message大小\",{\"1\":{\"143\":1}}],[\"message\",{\"1\":{\"143\":1}}],[\"message有key时\",{\"1\":{\"143\":1}}],[\"merge\",{\"1\":{\"137\":1}}],[\"mvcc\",{\"0\":{\"116\":1,\"120\":1}}],[\"myisam\",{\"1\":{\"114\":1}}],[\"mysql修改会先存到buffer\",{\"1\":{\"117\":1}}],[\"mysql\",{\"0\":{\"112\":1},\"1\":{\"120\":1}}],[\"mysql的xa实现\",{\"1\":{\"60\":1}}],[\"mysql数据库支持不太理想\",{\"1\":{\"60\":1}}],[\"misc\",{\"1\":{\"111\":1}}],[\"min\",{\"1\":{\"109\":1}}],[\"mincapacity\",{\"1\":{\"107\":5}}],[\"miillseconds\",{\"1\":{\"94\":1}}],[\"multiversion\",{\"0\":{\"120\":1}}],[\"multi\",{\"0\":{\"81\":1},\"1\":{\"120\":1}}],[\"map\",{\"1\":{\"157\":1}}],[\"mapreduce\",{\"1\":{\"157\":1}}],[\"magic\",{\"1\":{\"143\":1}}],[\"match\",{\"1\":{\"125\":1}}],[\"maximum\",{\"1\":{\"109\":4}}],[\"max\",{\"1\":{\"107\":1,\"109\":1}}],[\"machine\",{\"1\":{\"82\":1}}],[\"manager资源管理器\",{\"1\":{\"59\":1}}],[\"manager事务管理器\",{\"1\":{\"59\":1}}],[\"markdown\",{\"0\":{\"13\":1,\"14\":1,\"15\":1,\"16\":1},\"1\":{\"13\":2,\"14\":3,\"15\":1,\"16\":3,\"17\":2,\"18\":1,\"19\":1,\"32\":3,\"33\":1,\"34\":2,\"35\":2},\"2\":{\"30\":1}}],[\"modification\",{\"1\":{\"161\":1}}],[\"mode\",{\"1\":{\"119\":1}}],[\"model\",{\"1\":{\"59\":1}}],[\"mongodb\",{\"0\":{\"142\":1}}],[\"monotonic\",{\"1\":{\"71\":2}}],[\"moved\",{\"1\":{\"111\":1}}],[\"more\",{\"1\":{\"31\":1}}],[\"ms\",{\"1\":{\"33\":1}}],[\"md\",{\"1\":{\"18\":1}}],[\"请求共享或排他锁时\",{\"1\":{\"119\":1}}],[\"请求交由leader处理\",{\"1\":{\"82\":1}}],[\"请求只能一直等待\",{\"1\":{\"66\":1}}],[\"请使用绝对链接\",{\"1\":{\"34\":1}}],[\"请阅读\",{\"1\":{\"17\":1}}],[\"请先阅读\",{\"1\":{\"14\":1}}],[\"语法\",{\"1\":{\"18\":1,\"35\":1,\"158\":2}}],[\"语法进行了扩展\",{\"1\":{\"17\":1}}],[\"语法扩展\",{\"1\":{\"16\":1}}],[\"对文法中每一条规则r1\",{\"1\":{\"188\":1}}],[\"对请求排队或记录请求日志\",{\"1\":{\"184\":1}}],[\"对抽象产品的具体分类的实现\",{\"1\":{\"176\":1}}],[\"对字符串做细微修改\",{\"1\":{\"157\":1}}],[\"对比变化前后的虚拟dom节点\",{\"1\":{\"138\":1}}],[\"对document进行路由\",{\"1\":{\"137\":1}}],[\"对最短posting\",{\"1\":{\"134\":1}}],[\"对应文件夹\",{\"1\":{\"143\":1}}],[\"对应文件列表\",{\"1\":{\"136\":1}}],[\"对应符合的文档id存储在posting\",{\"1\":{\"134\":1}}],[\"对应lucene的library\",{\"1\":{\"134\":1}}],[\"对acceptor做两个要求\",{\"1\":{\"80\":1}}],[\"对等性\",{\"1\":{\"64\":1}}],[\"对系统a而言\",{\"1\":{\"61\":1}}],[\"对于客户端来说\",{\"1\":{\"170\":1}}],[\"对于更改封闭\",{\"1\":{\"161\":1}}],[\"对于扩展开放\",{\"1\":{\"161\":1}}],[\"对于处理过的节点\",{\"1\":{\"152\":1}}],[\"对于该节点的邻居\",{\"1\":{\"152\":1}}],[\"对于同一层级的一组子节点\",{\"1\":{\"139\":1}}],[\"对于β中的任意提议b\",{\"1\":{\"80\":1}}],[\"对于提议\",{\"1\":{\"80\":1}}],[\"对于数据库来说是一阶段提交\",{\"1\":{\"63\":1}}],[\"对于不支持事务型消息的消息中间件\",{\"1\":{\"62\":1}}],[\"对于一个业务系统的设计目标是\",{\"1\":{\"61\":1}}],[\"对于\",{\"1\":{\"34\":1}}],[\"对\",{\"1\":{\"17\":1}}],[\"为该对象结构中concreteelement的每一个类声明一个visit操作\",{\"1\":{\"189\":1}}],[\"为文法中每一条规则至少定义了一个类\",{\"1\":{\"188\":1}}],[\"为文法中的非终结符实现解释操作\",{\"1\":{\"188\":1}}],[\"为所有的具体观察者定义一个接口\",{\"1\":{\"175\":1}}],[\"为创建一个product对象的各个部件指定的抽象接口\",{\"1\":{\"174\":1}}],[\"为子系统中的一组接口提供一个一致的界面\",{\"1\":{\"173\":1}}],[\"为一个对象在不同的地址空间提供局部代表\",{\"1\":{\"169\":1}}],[\"为一个节点注册监听器\",{\"1\":{\"73\":1}}],[\"为其他对象提供一种代理以控制这个对象的访问\",{\"1\":{\"169\":1}}],[\"为最佳状态\",{\"1\":{\"141\":1}}],[\"为减少打开文件的数量\",{\"1\":{\"136\":1}}],[\"为界限分块\",{\"1\":{\"134\":1}}],[\"为下次rehash做准备\",{\"1\":{\"126\":1}}],[\"为ht\",{\"1\":{\"126\":1}}],[\"为节省内存每个元素所占内存大小可以不同\",{\"1\":{\"124\":1}}],[\"为删除行保存当前系统版本号作为行删除标识\",{\"1\":{\"120\":1}}],[\"为新插入行保存当前系统版本号作为行版本号\",{\"1\":{\"120\":1}}],[\"为汇编指令cmpxhg\",{\"1\":{\"111\":1}}],[\"为实现po\",{\"1\":{\"83\":1}}],[\"为实现p2\",{\"1\":{\"80\":1}}],[\"为保证p2c\",{\"1\":{\"80\":1}}],[\"为做到确定并只确定一个值acceptor需做到\",{\"1\":{\"80\":1}}],[\"为服务器赋予一定的权值\",{\"1\":{\"75\":1}}],[\"为0表示未锁定状态\",{\"1\":{\"73\":1}}],[\"为了使对象可以共享\",{\"1\":{\"187\":1}}],[\"为了方便反向遍历ziplist\",{\"1\":{\"124\":1}}],[\"为了允许行锁和表锁共存\",{\"1\":{\"119\":1}}],[\"为了高可用\",{\"1\":{\"67\":1}}],[\"为了丰富文档写作\",{\"1\":{\"17\":1}}],[\"为每个\",{\"1\":{\"15\":1}}],[\"扩展\",{\"0\":{\"16\":1,\"17\":1},\"1\":{\"17\":1}}],[\"中介者\",{\"1\":{\"192\":1}}],[\"中介者使各对象不需要显式地相互引用\",{\"1\":{\"186\":1}}],[\"中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合\",{\"1\":{\"186\":1}}],[\"中介者模式\",{\"0\":{\"186\":1}}],[\"中间存储阵列\",{\"1\":{\"143\":1}}],[\"中剩余可用空间的长度\",{\"1\":{\"123\":1}}],[\"中已占用空间的长度\",{\"1\":{\"123\":1}}],[\"中设置页面信息\",{\"1\":{\"33\":1}}],[\"中设置页面标题\",{\"1\":{\"32\":1}}],[\"中使用\",{\"1\":{\"19\":1,\"35\":1}}],[\"中的第一个\",{\"1\":{\"32\":1}}],[\"中的\",{\"1\":{\"17\":1}}],[\"中很重要的一个概念\",{\"1\":{\"15\":1}}],[\"中自定义它们\",{\"1\":{\"10\":1}}],[\"是否结尾\",{\"1\":{\"181\":1}}],[\"是否存储\",{\"1\":{\"136\":1}}],[\"是构建一个使用builder接口的对象\",{\"1\":{\"174\":1}}],[\"是一个32位无符号整数\",{\"1\":{\"124\":1}}],[\"是独立节点间如何达成协议的问题\",{\"1\":{\"85\":1}}],[\"是分布式系统实践中常见的问题\",{\"1\":{\"84\":1}}],[\"是分布式系统最常见概念之一\",{\"1\":{\"64\":1}}],[\"是被讨论最广泛的一致性协议\",{\"1\":{\"79\":1}}],[\"是整个业务活动的操作方\",{\"1\":{\"63\":1}}],[\"是\",{\"1\":{\"15\":1}}],[\"配置\",{\"0\":{\"15\":1}}],[\"演示\",{\"1\":{\"14\":1}}],[\"介绍\",{\"0\":{\"14\":1},\"1\":{\"14\":1,\"15\":1}}],[\"介绍页\",{\"0\":{\"1\":1}}],[\"展示\",{\"0\":{\"13\":1}}],[\"打印按钮\",{\"1\":{\"10\":1}}],[\"夜间模式按钮\",{\"1\":{\"10\":1}}],[\"主线程被js占用\",{\"1\":{\"139\":1}}],[\"主业务服务为整个业务活动的发起方\",{\"1\":{\"63\":1}}],[\"主备切换会导致主库与备库数据不一致\",{\"1\":{\"60\":1}}],[\"主题扩展了更多\",{\"1\":{\"18\":1}}],[\"主题扩展\",{\"0\":{\"18\":1}}],[\"主题也带有以下元素\",{\"1\":{\"10\":1}}],[\"主要是一个interpret\",{\"1\":{\"188\":1}}],[\"主要用来确保合理地共享flyweight\",{\"1\":{\"187\":1}}],[\"主要负责创建自己的唯一实例\",{\"1\":{\"182\":1}}],[\"主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况\",{\"1\":{\"177\":1}}],[\"主要从\",{\"1\":{\"13\":1}}],[\"主要功能与配置演示\",{\"0\":{\"2\":1}}],[\"文法中每一个终结符都有一个具体终结表达式与之相对应\",{\"1\":{\"188\":1}}],[\"文件保存索引字段加权数据\",{\"1\":{\"136\":1}}],[\"文件个数由innodb\",{\"1\":{\"115\":1}}],[\"文件夹的图片\",{\"1\":{\"34\":1}}],[\"文件放置在一起使用相对路径进行引用\",{\"1\":{\"34\":1}}],[\"文件\",{\"1\":{\"13\":1}}],[\"文件生成页面\",{\"1\":{\"13\":1}}],[\"文章标题列表\",{\"1\":{\"10\":1}}],[\"文字\",{\"1\":{\"7\":2}}],[\"文字段落\",{\"1\":{\"7\":24}}],[\"templatemethod\",{\"0\":{\"172\":1}}],[\"template模板先编译成vnode并缓存\",{\"1\":{\"140\":1}}],[\"terminalexpression\",{\"1\":{\"188\":1}}],[\"termination\",{\"1\":{\"76\":1}}],[\"term\",{\"1\":{\"135\":1,\"136\":4}}],[\"tvf\",{\"1\":{\"136\":1}}],[\"tvd\",{\"1\":{\"136\":1}}],[\"tvx\",{\"1\":{\"136\":1}}],[\"t整数值\",{\"1\":{\"128\":1}}],[\"t\",{\"1\":{\"126\":2,\"128\":7}}],[\"target\",{\"1\":{\"178\":1}}],[\"tail\",{\"1\":{\"125\":1,\"127\":1}}],[\"tabat\",{\"1\":{\"111\":2}}],[\"tab\",{\"1\":{\"111\":19}}],[\"table选项\",{\"1\":{\"115\":1}}],[\"table\",{\"0\":{\"150\":1},\"1\":{\"109\":1,\"111\":5,\"119\":2,\"126\":2}}],[\"tablesizefor\",{\"1\":{\"109\":1}}],[\"typedef\",{\"1\":{\"122\":1,\"125\":2,\"126\":3,\"127\":2,\"128\":1}}],[\"type\",{\"1\":{\"111\":1,\"122\":1,\"126\":1}}],[\"tip\",{\"1\":{\"136\":1}}],[\"timer\",{\"0\":{\"198\":1}}],[\"timeout\",{\"1\":{\"87\":1}}],[\"tim\",{\"1\":{\"136\":1}}],[\"title\",{\"1\":{\"32\":3}}],[\"throw\",{\"1\":{\"111\":2}}],[\"thread\",{\"1\":{\"111\":1}}],[\"threshold\",{\"1\":{\"109\":7}}],[\"three\",{\"0\":{\"78\":1}}],[\"this\",{\"1\":{\"107\":1,\"110\":1,\"111\":1}}],[\"the\",{\"0\":{\"161\":1},\"1\":{\"32\":1,\"136\":2}}],[\"two\",{\"0\":{\"77\":1},\"1\":{\"111\":1}}],[\"topicname\",{\"1\":{\"143\":1}}],[\"topic物理上分组\",{\"1\":{\"143\":1}}],[\"topic\",{\"1\":{\"143\":1}}],[\"to\",{\"1\":{\"107\":1,\"111\":1}}],[\"total\",{\"1\":{\"81\":1}}],[\"tolerance\",{\"1\":{\"66\":2}}],[\"toc\",{\"1\":{\"10\":1}}],[\"tcc\",{\"0\":{\"63\":1}}],[\"tm\",{\"1\":{\"59\":1}}],[\"tree\",{\"1\":{\"136\":1,\"139\":5}}],[\"tree索引\",{\"0\":{\"114\":1}}],[\"treeify\",{\"1\":{\"109\":2}}],[\"translog\",{\"1\":{\"137\":1}}],[\"transducers\",{\"1\":{\"134\":1}}],[\"transient\",{\"1\":{\"107\":1,\"108\":2,\"111\":2}}],[\"transaction\",{\"1\":{\"59\":2}}],[\"try\",{\"1\":{\"63\":3,\"110\":1,\"111\":1}}],[\"true\",{\"1\":{\"0\":1,\"110\":1}}],[\"2个字节表示最大数\",{\"1\":{\"134\":1}}],[\"2^16\",{\"1\":{\"134\":1}}],[\"2把锁\",{\"1\":{\"95\":1}}],[\"2在z上注册自己\",{\"1\":{\"87\":1}}],[\"2点保证事务fifo\",{\"1\":{\"83\":1}}],[\"2pc\",{\"0\":{\"77\":1}}],[\"2+1\",{\"1\":{\"73\":1}}],[\"2020\",{\"1\":{\"33\":1}}],[\"2\",{\"0\":{\"39\":1,\"44\":1,\"49\":1,\"54\":1,\"92\":1,\"95\":1,\"200\":1,\"204\":1,\"205\":1,\"210\":1,\"215\":1,\"220\":1,\"224\":1,\"225\":1,\"230\":1,\"235\":1},\"1\":{\"7\":14,\"26\":1,\"61\":1,\"62\":1,\"63\":1,\"73\":1,\"74\":1,\"75\":1,\"80\":2,\"83\":2,\"91\":1,\"95\":2,\"96\":1,\"109\":1,\"111\":1,\"126\":1,\"169\":1}}],[\"1时\",{\"1\":{\"143\":1}}],[\"19位数字字符长度\",{\"1\":{\"143\":1}}],[\"19th\",{\"1\":{\"21\":1}}],[\"1l\",{\"1\":{\"111\":1}}],[\"16\",{\"1\":{\"109\":2}}],[\"10\",{\"1\":{\"107\":1,\"224\":1}}],[\"1和2竞选leader\",{\"1\":{\"87\":1}}],[\"1的选择\",{\"0\":{\"69\":1}}],[\"1\",{\"0\":{\"91\":1,\"94\":1,\"199\":1,\"219\":1},\"1\":{\"7\":12,\"19\":1,\"26\":1,\"33\":2,\"35\":2,\"61\":1,\"62\":1,\"63\":1,\"73\":1,\"74\":1,\"75\":1,\"80\":2,\"83\":2,\"87\":1,\"91\":1,\"95\":2,\"96\":1,\"99\":2,\"101\":2,\"102\":2,\"104\":1,\"107\":1,\"109\":8,\"110\":1,\"111\":3,\"115\":1,\"123\":1,\"126\":9,\"132\":1,\"134\":2,\"143\":2,\"169\":1}}],[\"段落\",{\"1\":{\"7\":2}}],[\"密码加密的文章\",{\"0\":{\"7\":1}}],[\"页面都会被转换为一个\",{\"1\":{\"35\":1}}],[\"页面内容\",{\"0\":{\"34\":1}}],[\"页面标题\",{\"0\":{\"32\":1},\"1\":{\"32\":1}}],[\"页面配置\",{\"0\":{\"31\":1},\"1\":{\"33\":1},\"2\":{\"37\":1}}],[\"页面引入配置\",{\"1\":{\"15\":1}}],[\"页面信息\",{\"0\":{\"33\":1},\"1\":{\"4\":1}}],[\"页脚\",{\"1\":{\"4\":1,\"10\":1}}],[\"评论\",{\"1\":{\"4\":1,\"10\":1}}],[\"贡献者\",{\"1\":{\"4\":1,\"10\":1}}],[\"路径导航\",{\"1\":{\"4\":1,\"10\":1}}],[\"侧边栏\",{\"1\":{\"4\":1,\"10\":1}}],[\"你也可以创建并引入你自己的组件\",{\"1\":{\"35\":1}}],[\"你需要阅读\",{\"1\":{\"15\":1}}],[\"你应该创建和编写\",{\"1\":{\"13\":1}}],[\"你应该在页面前端设置\",{\"1\":{\"0\":1}}],[\"你可以将图片和\",{\"1\":{\"34\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"34\":1}}],[\"你可以在\",{\"1\":{\"32\":1,\"33\":1}}],[\"你可以在主题选项和页面的\",{\"1\":{\"10\":1}}],[\"你可以标记\",{\"1\":{\"25\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"13\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"4\":1}}],[\"博客主页\",{\"1\":{\"0\":1}}],[\"和递归条件\",{\"1\":{\"148\":1}}],[\"和data\",{\"1\":{\"143\":1}}],[\"和term\",{\"1\":{\"82\":1}}],[\"和节点a无因果关系的节点c的数据访问没有这样的限制\",{\"1\":{\"71\":1}}],[\"和a\",{\"1\":{\"67\":1}}],[\"和\",{\"1\":{\"0\":1,\"14\":1,\"33\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
