# 算法简介

## 选择排序

## 递归

如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要

每个递归函数都有两部分：基线条件(base case，函数不再调用自己，避免形成无限循环)和递归条件(recursive case，函数调用自己)

栈包含未完成的函数调用，无需自己跟踪。但是存储详尽的信息可能占用大量的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息（考虑使用循环）

## 快速排序

分而治之(divide and conquer, D&C)

合并排序和快速排序：快速查找的常量比合并查找小，所以快速查找速度将更快

平均情况和最糟情况：假设总是将第一个元素用作基准值，且要处理的数组是有序的，快速排序不检查输入数组是否有序，导致栈长为o(n)，最佳情况下，栈长为o(logn)。调用栈每层都涉及o(n)个元素。所以最糟情况是o(n^2)，最佳情况是o(nlogn)。只要每次都随机选择一个数组元素作为基准值，最佳情况也是平均情况

## 散列表(hash table)

被用于大海捞针式的查找。如将网址映射到IP地址，称为DNS解析(DNS resolution)

避免冲突：较低的填装因子（越低发生冲突的可能性越小，经验规则：一旦填装因子大于0.7，就调整散列表的长度），良好的散列函数

## 广度优先搜索(breadth-first search, BFS)

解决最短路径问题(shortest-path problem)的算法

广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系。

创建一个队列，用于存储要检查的对象，从队列弹出一个对象，检查是否符合条件，如果不符合，将这个对象的所有邻居都加入队列，循环反复，使用一个列表记录检查过的对象（避免导致无限循环），如找到，则结束，如队列为空，则说明没有符合条件的对象

时间复杂度o(V+E)，V为顶点(vertice)数，E为边数

## 狄克斯特拉算法

找出总权重最小的路径，只适用于有向无环图(directed acyclic graph, DAG)。找出可在最短时间内到达的节点，对于该节点的邻居，检查是否有前往它们的更短路径，如有，更新其开销，重复直到对图中每个节点都进行计算，计算最终路径

需要三个散列表，GRAPH(节点所有邻居),COSTS(开销),PARENTS(存储父节点)，一个数组，用于记录处理过的节点

如果有负权边，就不能使用狄克斯特拉算法(没有比不支付任何费用更便宜的方式，基于假设：对于处理过的节点，没有前往该节点的更短路径，仅在没有负权边时才成立)

包含负权边的图，可使用贝尔曼-福德算法(Bellman-Ford algorithm)

## 贪婪算法

每步都选择局部最优解，最终得到的就是全局最优解

当只需找到能够大致解决问题的算法，可使用贪婪算法，因为实现容易，得到的结果与正确结果接近

近似算法(approximation algorithm)：在获得精确解需要时间太长，可使用。判断标准：速度，近似解与最优解的接近程度

## NP完全问题

以难解著称的问题，如旅行商问题和集合覆盖问题

判断是不是NP完全问题：

元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢；

涉及“所有组合”的问题通常是NP完全问题；

不能将问题分成小问题，必须考虑各种可能的情况，可能是；

如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，可能是；

如果问题涉及集合（如广播台集合）且难以解决，可能是；

如果问题可转换为集合覆盖问题或旅行商问题，肯定是。

## 动态规划

每个子问题都是离散的，即不依赖于其他子问题时

费曼算法（Feyman algorithm)：将问题写下来；好好思考；将答案写下来

应用场景：需要在给定约束条件下优化某种指标；问题可分解为离散子问题时

## K最近邻算法(k-nearest neighbours, KNN)

余弦相似度(consine similarity) 不计算两个矢量的距离，而比较角度，更适合处理不同用户评分方式的差异

推荐系统

光学字符识别(OCR, optional character recognition) 

垃圾邮件过滤器 朴素贝叶斯分类器(Naive Bayes classifier) 

预测股票市场

## 其他

树

反向索引(inverted index)

傅里叶变换

并行算法：速度提升并非线性(并行性管理开销，负载均衡)

MapReduce：映射(map)，归并(reduce)

布隆过滤器和HyperLogLog(近似计算集合中不同元素数)

SHA(安全散列，secure hash algorithm)算法

局部敏感的散列算法(Simhash，对字符串做细微修改，生成的散列值也只存在细微的差别，用于检查两项内容的相似程度)

Diffe-Hellman密钥交换(公钥，私钥)

线性规划：在给定约束条件下最大限度改善指定的指标 Simplex算法
