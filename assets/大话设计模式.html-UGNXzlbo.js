const e=JSON.parse('{"key":"v-4a777ccc","path":"/%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html","title":"大话设计模式","lang":"zh-CN","frontmatter":{"description":"大话设计模式 单一职责原则（SRP） 就一个类而言，应该仅有一个引起它变化的原因。如果能够想到多于一个动机去改变一个类，那么这个类就具有多于一个的职责[ASD]，就应该考虑类的职责分离 开放-关闭原则（The Open-Closed Principle, OCP） 软件实体（类、模块、函数等）应该可以扩展，但不可修改。对于扩展开放(Open for extension)，对于更改封闭（Closed for modification）。可维护，可扩展，可复用，灵活性好 依赖倒转原则 抽象不应该依赖细节，细节应该依赖于抽象。高层模块不应该依赖低层模块，两个都应该依赖抽象","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/vuepress-theme-hope/%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"大话设计模式"}],["meta",{"property":"og:description","content":"大话设计模式 单一职责原则（SRP） 就一个类而言，应该仅有一个引起它变化的原因。如果能够想到多于一个动机去改变一个类，那么这个类就具有多于一个的职责[ASD]，就应该考虑类的职责分离 开放-关闭原则（The Open-Closed Principle, OCP） 软件实体（类、模块、函数等）应该可以扩展，但不可修改。对于扩展开放(Open for extension)，对于更改封闭（Closed for modification）。可维护，可扩展，可复用，灵活性好 依赖倒转原则 抽象不应该依赖细节，细节应该依赖于抽象。高层模块不应该依赖低层模块，两个都应该依赖抽象"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-17T11:44:33.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2023-12-17T11:44:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"大话设计模式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-12-17T11:44:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"单一职责原则（SRP）","slug":"单一职责原则-srp","link":"#单一职责原则-srp","children":[]},{"level":2,"title":"开放-关闭原则（The Open-Closed Principle, OCP）","slug":"开放-关闭原则-the-open-closed-principle-ocp","link":"#开放-关闭原则-the-open-closed-principle-ocp","children":[]},{"level":2,"title":"依赖倒转原则","slug":"依赖倒转原则","link":"#依赖倒转原则","children":[]},{"level":2,"title":"里式代换原则(LSP)","slug":"里式代换原则-lsp","link":"#里式代换原则-lsp","children":[]},{"level":2,"title":"迪米特法则(LoD)","slug":"迪米特法则-lod","link":"#迪米特法则-lod","children":[]},{"level":2,"title":"合成/聚合复用原则（CARP）","slug":"合成-聚合复用原则-carp","link":"#合成-聚合复用原则-carp","children":[]},{"level":2,"title":"简单工厂模式","slug":"简单工厂模式","link":"#简单工厂模式","children":[]},{"level":2,"title":"策略模式(Strategy)","slug":"策略模式-strategy","link":"#策略模式-strategy","children":[]},{"level":2,"title":"装饰模式(Decorator)","slug":"装饰模式-decorator","link":"#装饰模式-decorator","children":[]},{"level":2,"title":"代理模式（Proxy）","slug":"代理模式-proxy","link":"#代理模式-proxy","children":[]},{"level":2,"title":"工厂方法模式（Factory Method）","slug":"工厂方法模式-factory-method","link":"#工厂方法模式-factory-method","children":[]},{"level":2,"title":"原型模式 (Prototype)","slug":"原型模式-prototype","link":"#原型模式-prototype","children":[]},{"level":2,"title":"模板方法模式(TemplateMethod)","slug":"模板方法模式-templatemethod","link":"#模板方法模式-templatemethod","children":[]},{"level":2,"title":"外观模式（Facade，门面模式）","slug":"外观模式-facade-门面模式","link":"#外观模式-facade-门面模式","children":[]},{"level":2,"title":"建造者模式（Builder）","slug":"建造者模式-builder","link":"#建造者模式-builder","children":[]},{"level":2,"title":"观察者模式（Observer, 发布-订阅Publish/Subscribe模式）","slug":"观察者模式-observer-发布-订阅publish-subscribe模式","link":"#观察者模式-observer-发布-订阅publish-subscribe模式","children":[]},{"level":2,"title":"抽象工厂模式（Abstract Factory)","slug":"抽象工厂模式-abstract-factory","link":"#抽象工厂模式-abstract-factory","children":[]},{"level":2,"title":"状态模式（State）","slug":"状态模式-state","link":"#状态模式-state","children":[]},{"level":2,"title":"适配器模式(Adapter)","slug":"适配器模式-adapter","link":"#适配器模式-adapter","children":[]},{"level":2,"title":"备忘录模式(Memento)","slug":"备忘录模式-memento","link":"#备忘录模式-memento","children":[]},{"level":2,"title":"组合模式(Composite)","slug":"组合模式-composite","link":"#组合模式-composite","children":[]},{"level":2,"title":"迭代器模式(Iterator)","slug":"迭代器模式-iterator","link":"#迭代器模式-iterator","children":[]},{"level":2,"title":"单例模式(Singleton)","slug":"单例模式-singleton","link":"#单例模式-singleton","children":[]},{"level":2,"title":"桥接模式(Bridge)","slug":"桥接模式-bridge","link":"#桥接模式-bridge","children":[]},{"level":2,"title":"命令模式(Command)","slug":"命令模式-command","link":"#命令模式-command","children":[]},{"level":2,"title":"职责链模式(Chain of Responsibility)","slug":"职责链模式-chain-of-responsibility","link":"#职责链模式-chain-of-responsibility","children":[]},{"level":2,"title":"中介者模式（调停者模式，Mediator）","slug":"中介者模式-调停者模式-mediator","link":"#中介者模式-调停者模式-mediator","children":[]},{"level":2,"title":"享元模式(Flyweight)","slug":"享元模式-flyweight","link":"#享元模式-flyweight","children":[]},{"level":2,"title":"解释器模式(interpreter)","slug":"解释器模式-interpreter","link":"#解释器模式-interpreter","children":[]},{"level":2,"title":"访问者模式(Visitor)","slug":"访问者模式-visitor","link":"#访问者模式-visitor","children":[]},{"level":2,"title":"创建型模式","slug":"创建型模式","link":"#创建型模式","children":[]},{"level":2,"title":"结构型模式","slug":"结构型模式","link":"#结构型模式","children":[]},{"level":2,"title":"行为型模式","slug":"行为型模式","link":"#行为型模式","children":[]}],"git":{"createdTime":1702813473000,"updatedTime":1702813473000,"contributors":[{"name":"wuyanluoye","email":"refersearch@163.com","commits":1}]},"readingTime":{"minutes":22.49,"words":6747},"filePathRelative":"知识点/大话设计模式.md","localizedDate":"2023年12月17日","excerpt":"<h1> 大话设计模式</h1>\\n<h2> 单一职责原则（SRP）</h2>\\n<p>就一个类而言，应该仅有一个引起它变化的原因。如果能够想到多于一个动机去改变一个类，那么这个类就具有多于一个的职责[ASD]，就应该考虑类的职责分离</p>\\n<h2> 开放-关闭原则（The Open-Closed Principle, OCP）</h2>\\n<p>软件实体（类、模块、函数等）应该可以扩展，但不可修改。对于扩展开放(Open for extension)，对于更改封闭（Closed for modification）。可维护，可扩展，可复用，灵活性好</p>\\n<h2> 依赖倒转原则</h2>\\n<p>抽象不应该依赖细节，细节应该依赖于抽象。高层模块不应该依赖低层模块，两个都应该依赖抽象</p>","autoDesc":true}');export{e as data};
