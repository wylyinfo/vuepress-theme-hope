const e=JSON.parse('{"key":"v-132cd25c","path":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3.html","title":"算法简介","lang":"zh-CN","frontmatter":{"description":"算法简介 选择排序 递归 如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要 每个递归函数都有两部分：基线条件(base case，函数不再调用自己，避免形成无限循环)和递归条件(recursive case，函数调用自己) 栈包含未完成的函数调用，无需自己跟踪。但是存储详尽的信息可能占用大量的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息（考虑使用循环） 快速排序 分而治之(divide and conquer, D&amp;C)","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"算法简介"}],["meta",{"property":"og:description","content":"算法简介 选择排序 递归 如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要 每个递归函数都有两部分：基线条件(base case，函数不再调用自己，避免形成无限循环)和递归条件(recursive case，函数调用自己) 栈包含未完成的函数调用，无需自己跟踪。但是存储详尽的信息可能占用大量的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息（考虑使用循环） 快速排序 分而治之(divide and conquer, D&amp;C)"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-17T11:44:33.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2023-12-17T11:44:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"算法简介\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-12-17T11:44:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"选择排序","slug":"选择排序","link":"#选择排序","children":[]},{"level":2,"title":"递归","slug":"递归","link":"#递归","children":[]},{"level":2,"title":"快速排序","slug":"快速排序","link":"#快速排序","children":[]},{"level":2,"title":"散列表(hash table)","slug":"散列表-hash-table","link":"#散列表-hash-table","children":[]},{"level":2,"title":"广度优先搜索(breadth-first search, BFS)","slug":"广度优先搜索-breadth-first-search-bfs","link":"#广度优先搜索-breadth-first-search-bfs","children":[]},{"level":2,"title":"狄克斯特拉算法","slug":"狄克斯特拉算法","link":"#狄克斯特拉算法","children":[]},{"level":2,"title":"贪婪算法","slug":"贪婪算法","link":"#贪婪算法","children":[]},{"level":2,"title":"NP完全问题","slug":"np完全问题","link":"#np完全问题","children":[]},{"level":2,"title":"动态规划","slug":"动态规划","link":"#动态规划","children":[]},{"level":2,"title":"K最近邻算法(k-nearest neighbours, KNN)","slug":"k最近邻算法-k-nearest-neighbours-knn","link":"#k最近邻算法-k-nearest-neighbours-knn","children":[]},{"level":2,"title":"其他","slug":"其他","link":"#其他","children":[]}],"git":{"createdTime":1702813473000,"updatedTime":1702813473000,"contributors":[{"name":"wuyanluoye","email":"refersearch@163.com","commits":1}]},"readingTime":{"minutes":4.8,"words":1441},"filePathRelative":"数据结构与算法/算法图解.md","localizedDate":"2023年12月17日","excerpt":"<h1> 算法简介</h1>\\n<h2> 选择排序</h2>\\n<h2> 递归</h2>\\n<p>如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要</p>\\n<p>每个递归函数都有两部分：基线条件(base case，函数不再调用自己，避免形成无限循环)和递归条件(recursive case，函数调用自己)</p>\\n<p>栈包含未完成的函数调用，无需自己跟踪。但是存储详尽的信息可能占用大量的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息（考虑使用循环）</p>\\n<h2> 快速排序</h2>\\n<p>分而治之(divide and conquer, D&amp;C)</p>","autoDesc":true}');export{e as data};
