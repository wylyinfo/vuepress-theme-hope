import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as r,f as p}from"./app-lybKqyLW.js";const h={},i=p('<h1 id="算法简介" tabindex="-1"><a class="header-anchor" href="#算法简介" aria-hidden="true">#</a> 算法简介</h1><h2 id="选择排序" tabindex="-1"><a class="header-anchor" href="#选择排序" aria-hidden="true">#</a> 选择排序</h2><h2 id="递归" tabindex="-1"><a class="header-anchor" href="#递归" aria-hidden="true">#</a> 递归</h2><p>如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要</p><p>每个递归函数都有两部分：基线条件(base case，函数不再调用自己，避免形成无限循环)和递归条件(recursive case，函数调用自己)</p><p>栈包含未完成的函数调用，无需自己跟踪。但是存储详尽的信息可能占用大量的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息（考虑使用循环）</p><h2 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序" aria-hidden="true">#</a> 快速排序</h2><p>分而治之(divide and conquer, D&amp;C)</p><p>合并排序和快速排序：快速查找的常量比合并查找小，所以快速查找速度将更快</p><p>平均情况和最糟情况：假设总是将第一个元素用作基准值，且要处理的数组是有序的，快速排序不检查输入数组是否有序，导致栈长为o(n)，最佳情况下，栈长为o(logn)。调用栈每层都涉及o(n)个元素。所以最糟情况是o(n^2)，最佳情况是o(nlogn)。只要每次都随机选择一个数组元素作为基准值，最佳情况也是平均情况</p><h2 id="散列表-hash-table" tabindex="-1"><a class="header-anchor" href="#散列表-hash-table" aria-hidden="true">#</a> 散列表(hash table)</h2><p>被用于大海捞针式的查找。如将网址映射到IP地址，称为DNS解析(DNS resolution)</p><p>避免冲突：较低的填装因子（越低发生冲突的可能性越小，经验规则：一旦填装因子大于0.7，就调整散列表的长度），良好的散列函数</p><h2 id="广度优先搜索-breadth-first-search-bfs" tabindex="-1"><a class="header-anchor" href="#广度优先搜索-breadth-first-search-bfs" aria-hidden="true">#</a> 广度优先搜索(breadth-first search, BFS)</h2><p>解决最短路径问题(shortest-path problem)的算法</p><p>广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系。</p><p>创建一个队列，用于存储要检查的对象，从队列弹出一个对象，检查是否符合条件，如果不符合，将这个对象的所有邻居都加入队列，循环反复，使用一个列表记录检查过的对象（避免导致无限循环），如找到，则结束，如队列为空，则说明没有符合条件的对象</p><p>时间复杂度o(V+E)，V为顶点(vertice)数，E为边数</p><h2 id="狄克斯特拉算法" tabindex="-1"><a class="header-anchor" href="#狄克斯特拉算法" aria-hidden="true">#</a> 狄克斯特拉算法</h2><p>找出总权重最小的路径，只适用于有向无环图(directed acyclic graph, DAG)。找出可在最短时间内到达的节点，对于该节点的邻居，检查是否有前往它们的更短路径，如有，更新其开销，重复直到对图中每个节点都进行计算，计算最终路径</p><p>需要三个散列表，GRAPH(节点所有邻居),COSTS(开销),PARENTS(存储父节点)，一个数组，用于记录处理过的节点</p><p>如果有负权边，就不能使用狄克斯特拉算法(没有比不支付任何费用更便宜的方式，基于假设：对于处理过的节点，没有前往该节点的更短路径，仅在没有负权边时才成立)</p><p>包含负权边的图，可使用贝尔曼-福德算法(Bellman-Ford algorithm)</p><h2 id="贪婪算法" tabindex="-1"><a class="header-anchor" href="#贪婪算法" aria-hidden="true">#</a> 贪婪算法</h2><p>每步都选择局部最优解，最终得到的就是全局最优解</p><p>当只需找到能够大致解决问题的算法，可使用贪婪算法，因为实现容易，得到的结果与正确结果接近</p><p>近似算法(approximation algorithm)：在获得精确解需要时间太长，可使用。判断标准：速度，近似解与最优解的接近程度</p><h2 id="np完全问题" tabindex="-1"><a class="header-anchor" href="#np完全问题" aria-hidden="true">#</a> NP完全问题</h2><p>以难解著称的问题，如旅行商问题和集合覆盖问题</p><p>判断是不是NP完全问题：</p><p>元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢；</p><p>涉及“所有组合”的问题通常是NP完全问题；</p><p>不能将问题分成小问题，必须考虑各种可能的情况，可能是；</p><p>如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，可能是；</p><p>如果问题涉及集合（如广播台集合）且难以解决，可能是；</p><p>如果问题可转换为集合覆盖问题或旅行商问题，肯定是。</p><h2 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划" aria-hidden="true">#</a> 动态规划</h2><p>每个子问题都是离散的，即不依赖于其他子问题时</p><p>费曼算法（Feyman algorithm)：将问题写下来；好好思考；将答案写下来</p><p>应用场景：需要在给定约束条件下优化某种指标；问题可分解为离散子问题时</p><h2 id="k最近邻算法-k-nearest-neighbours-knn" tabindex="-1"><a class="header-anchor" href="#k最近邻算法-k-nearest-neighbours-knn" aria-hidden="true">#</a> K最近邻算法(k-nearest neighbours, KNN)</h2><p>余弦相似度(consine similarity) 不计算两个矢量的距离，而比较角度，更适合处理不同用户评分方式的差异</p><p>推荐系统</p><p>光学字符识别(OCR, optional character recognition)</p><p>垃圾邮件过滤器 朴素贝叶斯分类器(Naive Bayes classifier)</p><p>预测股票市场</p><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h2><p>树</p><p>反向索引(inverted index)</p><p>傅里叶变换</p><p>并行算法：速度提升并非线性(并行性管理开销，负载均衡)</p><p>MapReduce：映射(map)，归并(reduce)</p><p>布隆过滤器和HyperLogLog(近似计算集合中不同元素数)</p><p>SHA(安全散列，secure hash algorithm)算法</p><p>局部敏感的散列算法(Simhash，对字符串做细微修改，生成的散列值也只存在细微的差别，用于检查两项内容的相似程度)</p><p>Diffe-Hellman密钥交换(公钥，私钥)</p><p>线性规划：在给定约束条件下最大限度改善指定的指标 Simplex算法</p>',57),n=[i];function d(t,s){return e(),r("div",null,n)}const l=a(h,[["render",d],["__file","算法图解.html.vue"]]);export{l as default};
