import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as r,f as h}from"./app-m5dcxRin.js";const d={},i=h('<h1 id="分布式锁需要具备哪些条件" tabindex="-1"><a class="header-anchor" href="#分布式锁需要具备哪些条件" aria-hidden="true">#</a> 分布式锁需要具备哪些条件</h1><ol><li>获取锁和释放锁的性能要好</li><li>判断是否获得锁必须是原子性的，否则可能导致多个请求都获取到锁</li><li>网络中断或宕机无法释放锁时，锁必须被清除，不然会发生死锁</li><li>可重入一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接 执行调用的方法，而无需重新获得锁（避免死锁）</li><li>阻塞锁和非阻塞锁，阻塞锁即没有获取到锁，则继续等待获取锁；费阻塞锁即没有获取到锁后，不继续等待，直接返回锁失败。</li></ol><h2 id="分布式锁实现方式" tabindex="-1"><a class="header-anchor" href="#分布式锁实现方式" aria-hidden="true">#</a> 分布式锁实现方式</h2><h2 id="一、数据库锁" tabindex="-1"><a class="header-anchor" href="#一、数据库锁" aria-hidden="true">#</a> 一、数据库锁</h2><h2 id="_1-基于mysql锁表" tabindex="-1"><a class="header-anchor" href="#_1-基于mysql锁表" aria-hidden="true">#</a> 1.基于MySQL锁表</h2><p>完全依靠数据库唯一索引实现，当想要获得锁时，即向数据库中插入一条记录，释放锁时就删除该记录。存在以下问题：1）锁没有失效时间，解锁失败会导致死锁，其他线程无法再获取到锁，因为唯一索引insert都会返回失败；2）只能是非阻塞锁，insert失败直接报错，无法进入队列重试；3）不可重入，同一线程在没有释放锁之前无法再获取到锁。</p><h2 id="_2-采用乐观锁增加版本号" tabindex="-1"><a class="header-anchor" href="#_2-采用乐观锁增加版本号" aria-hidden="true">#</a> 2.采用乐观锁增加版本号</h2><p>根据版本号来判断更新之前有没有其他线程更新过，如果被更新过，则获取锁失败。</p><h2 id="二、缓存锁" tabindex="-1"><a class="header-anchor" href="#二、缓存锁" aria-hidden="true">#</a> 二、缓存锁</h2><h2 id="_1-基于-sex-px-nx" tabindex="-1"><a class="header-anchor" href="#_1-基于-sex-px-nx" aria-hidden="true">#</a> 1.基于 sex PX NX</h2><p>PX miillseconds 设置键key的过期时间，单位毫秒，NX 只有键key不存在时才会设置key的值</p><h2 id="_2-redlock算法" tabindex="-1"><a class="header-anchor" href="#_2-redlock算法" aria-hidden="true">#</a> 2.RedLock算法</h2><p>1）获取当前时间；2）尝试从5个相互独立redis客户端获取锁；3）计算获取所有锁消耗的时间，当且仅当客户端从多数节点获取锁，并且获取锁的时间小于锁的有效时间，认为获得锁；4）重新计算有效期时间，原有效时间减去获取锁消耗的时间；5）删除所有实例的锁。</p><p>redlock算法相对于单节点redis锁可靠性更高，实现条件较为苛刻：1）必须部署5个节点才能让Redlock的可靠性更强。2）需要请求5个节点才能获取到锁，通过Future方式，先并发向5个节点请求，再一起获得响应结果，能缩短响应时间，不过还是比单节点redis锁耗费更多时间。由于必须获取到5个节点中3个以上，可能出现获取锁冲突，即都获得1-2把锁，结果都不能获取到锁。redlock采用通过冲突后在随机时间开始，降低冲突时间，但不能很好避免，特别是第一次获取锁时，所以获取锁的时间成本增加。如果5个节点有2个宕机，此时锁的可用性会极大降低，首先必须等待这两个宕机节点的结果超时才能返回，另外只有3个节点，客户端必须获取到全部3个节点的锁才能拥有锁，难度加大了。如果出现网络分区，可能出现客户端永远无法获取锁的情况。</p><h2 id="zookeeper分布式锁" tabindex="-1"><a class="header-anchor" href="#zookeeper分布式锁" aria-hidden="true">#</a> zookeeper分布式锁</h2><p>zookeeper为分布式应用提供一致性服务，内部是一个分层的文件系统目录树结构，规定一个目录下只能有一个唯一文件名。</p><p>数据模型：永久节点：节点创建后，不会因为会话失效而消失；临时节点：与永久节点相反，如果客户端连接失效，则立即删除节点；顺序节点：会自动在节点名后加一个数字后缀，并且有序。</p><p>监视器(watcher)：当创建一个节点时，可以注册一个该节点的监视器，当节点状态发生改变时，watch被触发时，zookeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次。</p><p>实现分布式锁：1）创建一个锁目录lock；2）希望获得锁的线程A在lock目录下，创建临时顺序节点；3）获取锁目录下所有子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；4）线程B获取所有节点，判断自己不是最小节点，设置监听（watcher）比自己次小的节点（只关注比自己次小的节点是为了防止发生“羊群效应”)；5）线程A处理完，删除自己的节点，线程B监听到变更时间，判断自己是最小节点，获得锁。</p><h2 id="分布式锁比较" tabindex="-1"><a class="header-anchor" href="#分布式锁比较" aria-hidden="true">#</a> 分布式锁比较</h2><p>数据库锁：优点：直接使用数据库，使用简单；缺点：分布式系统大多数瓶颈都在数据库，使用数据库锁会增加数据库负担。</p><p>缓存锁：优点：性能高，实现方便，在允许偶发的锁失效的情况，不影响系统正常使用，建议采用缓存锁；缺点：通过锁超时机制不是十分可靠，当线程获得锁后，处理时间过长导致锁超时，就失去锁的作用</p><p>zookeeper锁：优点：不依靠超时时间释放锁，可靠性高，系统要求高可靠性时，建议采用zookeeper锁；缺点：性能比不上缓存锁，因为要频繁创建删除节点</p>',23),o=[i];function c(n,t){return a(),r("div",null,o)}const p=e(d,[["render",c],["__file","分布式锁.html.vue"]]);export{p as default};
